/*
 * Copyright(C) 2012 Sandia Corporation.  Under the terms of Contract
 * DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
 * certain rights in this software
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above
 *   copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided
 *   with the distribution.
 *
 * * Neither the name of Sandia Corporation nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/**********************************************************************/
/* matlab mat file to exodus II.  This takes .mat files exactly as
   generated by the tool exo2mat written by mrtabba and converts them
   back to exodus II format

   rmnaeth. August 8, 2003

   modified by D. Todd Griffith on 12/09/2005
   * modifcations include:
   1) writes global, nodal and element variable names
   2) writes global, nodal and elemnent variable results
   3) writes complete set of time steps (previous version
          skipped first step)
   4) writes complete node set information (node set numbers,
          dist. factors, etc)
   5) writes complete side set information (side set numbers,
          dist. factors, etc)

   modified by D. Todd Griffith on 12/16/2005
   * side set distribution factors now written as double (not int)

   modified by Greg Sjaardema, 07/05/2012 to use matio instead of matlab libraries.
*/

#include <vector>

#include <exodusII.h>                   // for ex_inquire_int, ex_put_var, etc
#include <stddef.h>                     // for size_t
#include <stdio.h>                      // for sprintf, NULL, printf, etc
#include <stdlib.h>                     // for calloc, free, exit
#include <string.h>                     // for strtok, memcpy, strcat, etc
#include "add_to_log.h"                 // for add_to_log
#include "matio.h"                      // for matvar_t, Mat_VarFree, etc

/**********************************************************************/
#if __cplusplus > 199711L
#define TOPTR(x) x.data()
#else
#define TOPTR(x) (x.empty() ? NULL : &x[0])
#endif

mat_t *mat_file=0;  /* file for binary .mat input */

/**********************************************************************/
static const char *qainfo[] =
{
  "mat2exo",
  "2014/07/16",
  "2.03",
};

/**********************************************************************/
int matGetStr  (const char *name,char *str);
int matGetDbl  (const char *name,int n1,int n2, std::vector<double> &data);
int matGetInt  (const char *name,int n1,int n2, std::vector<int> &data);
int matGetInt  (const char *name, int *data);
int matArrNRow (const char *name);
int matArrNCol (const char *name);
void del_arg(int *argc, char* argv[], int j);

/**********************************************************************/
int main (int argc, char *argv[]){

  char **str2,*line,*curr;

  const char* ext=".exo";

  size_t line_size = 0;

  int
    i,j,k,n,n1,cpu_word_size,io_word_size,exo_file,
    num_axes,num_nodes,num_elements,num_blocks,
    num_side_sets,num_node_sets,num_time_steps,
    num_global_vars,
    num_nodal_vars,num_element_vars;

  char * blknames = NULL;

  /* QA Info */
  printf("%s: %s, %s\n", qainfo[0], qainfo[2], qainfo[1]);

  /* usage message*/
  if(argc != 2){
    printf("%s matlab_file_name.\n",argv[0]);
    printf("   the matlab_file_name is required\n");
    printf("%d", argc);
    exit(1);
  }

  /*open input file*/
  mat_file = Mat_Open(argv[1], MAT_ACC_RDONLY);
  if (mat_file == NULL) {
    printf("Error opening matlab file %s\n", argv[1]);
    return(1);
  }

  /*open output file*/
  cpu_word_size=sizeof(double);
  io_word_size=sizeof(double);
  /* QA records */
  ext=".exo";

  /* Possibly overestimates size, but that is ok */
  line_size = strlen(argv[1]) + strlen(ext) + 1;
  line = (char *) calloc (line_size,sizeof(char));
  strcpy(line,argv[1]);
  strtok(line,".");
  strcat(line,ext);
  exo_file = ex_create(line,EX_CLOBBER,&cpu_word_size,&io_word_size);
  if (exo_file < 0){
    printf("error creating %s\n",line);
    exit(1);
  }

  /* print */
  fprintf(stderr,"translating %s to %s ... ",argv[1],line);

  /* read database parameters */
  matGetInt("naxes",  &num_axes);
  matGetInt("nnodes", &num_nodes);
  matGetInt("nelems", &num_elements);
  matGetInt("nblks",  &num_blocks);
  matGetInt("nnsets", &num_node_sets);
  matGetInt("nssets", &num_side_sets);
  matGetInt("nsteps", &num_time_steps);
  matGetInt("ngvars", &num_global_vars);
  matGetInt("nnvars", &num_nodal_vars);
  matGetInt("nevars", &num_element_vars);

  printf("naxes = %d\n", num_axes);
  /*export parameters */
  ex_put_init(exo_file,line,
              num_axes,num_nodes,num_elements,num_blocks,
              num_node_sets,num_side_sets);
  free(line);

  if ( num_global_vars > 0 ){
    ex_put_variable_param(exo_file,EX_GLOBAL,num_global_vars);
  }

  if ( num_nodal_vars > 0 ){
    ex_put_variable_param(exo_file,EX_NODAL,num_nodal_vars);
  }

  if ( num_element_vars > 0 ){
    ex_put_variable_param(exo_file,EX_ELEM_BLOCK,num_element_vars);
  }

  /* nodal coordinates */
  {
    std::vector<double> x(num_nodes);
    std::vector<double> y(num_nodes);
    std::vector<double> z;
    if (num_axes == 3) {
      z.resize(num_nodes);
    }
    matGetDbl("x0", num_nodes, 1, x);
    matGetDbl("y0", num_nodes, 1, y);
    if (num_axes == 3) {
      matGetDbl("z0", num_nodes,1,z);
    }
    ex_put_coord(exo_file, TOPTR(x), TOPTR(y), TOPTR(z));
  }

  std::vector<int> ids;

  /* side sets (section by dgriffi) */
  if(num_side_sets > 0){
    ids.resize(num_side_sets);
    /* ssids */
    matGetInt("ssids",num_side_sets, 1, ids);

    /* nsssides */
    std::vector<int> nsssides(num_side_sets);
    matGetInt("nsssides",num_side_sets,1,nsssides);

    /* nssdfac */
    std::vector<int> nssdfac(num_side_sets);
    matGetInt("nssdfac",num_side_sets,1,nssdfac);

    for(i=0;i<num_side_sets;i++){
      char name[32];

      ex_put_set_param(exo_file,EX_SIDE_SET,ids[i],nsssides[i],nssdfac[i]);
      std::vector<int> elem_list(nsssides[i]);
      std::vector<int> side_list(nsssides[i]);
      std::vector<double> escr(nssdfac[i]);

      sprintf(name,"sselem%02d",i+1);
      matGetInt(name,nsssides[i],1,elem_list);

      sprintf(name,"ssside%02d",i+1);
      matGetInt(name,nsssides[i],1,side_list);
      ex_put_set(exo_file,EX_SIDE_SET,ids[i], TOPTR(elem_list), TOPTR(side_list));

      sprintf(name,"ssfac%02d",i+1);
      matGetDbl(name,nssdfac[i],1,escr);
      ex_put_set_dist_fact(exo_file,EX_SIDE_SET,ids[i], TOPTR(escr));
    }

  }

  /* node sets (section by dgriffi) */
  if(num_node_sets > 0){

    /* nsids */
    ids.resize(num_node_sets);
    matGetInt("nsids",num_node_sets, 1, ids);

    /* nnsnodes */
    std::vector<int> nnsnodes(num_node_sets);
    matGetInt("nnsnodes",num_node_sets,1,nnsnodes);

    /* nnsdfac */
    std::vector<int> nnsdfac(num_node_sets);
    matGetInt("nnsdfac",num_node_sets,1,nnsdfac);

    std::vector<double> escr;
    std::vector<int> node_list;
    for(i=0;i<num_node_sets;i++){
      char name[32];

      ex_put_set_param(exo_file,EX_NODE_SET,ids[i],nnsnodes[i],nnsdfac[i]);
      node_list.resize(nnsnodes[i]);
      escr.resize(nnsdfac[i]);

      sprintf(name,"nsnod%02d",i+1);
      matGetInt(name,nnsnodes[i],1,node_list);
      ex_put_set(exo_file,EX_NODE_SET,ids[i], TOPTR(node_list),NULL);

      sprintf(name,"nsfac%02d",i+1);
      matGetDbl(name,nnsdfac[i],1,escr);
      ex_put_set_dist_fact(exo_file,EX_NODE_SET,ids[i], TOPTR(escr));
    }
  }


  /* element blocks */
  /* get elem block ids */
  ids.resize(num_blocks);
  matGetInt("blkids",num_blocks,1, ids);

  /* get elem block types */
  blknames = (char *) calloc(num_blocks*(MAX_STR_LENGTH+1),sizeof(char));
  matGetStr("blknames",blknames);
  std::vector<int> num_elem_in_block(num_blocks);
  std::vector<int> iscr;
  curr = blknames;
  curr = strtok(curr,"\n");
  for(i=0;i<num_blocks;i++){
    char name[32];

    sprintf(name,"blk%02d",i+1);
    n1 = matArrNRow(name);
    n = matArrNCol(name);
    iscr.resize(n*n1);
    matGetInt(name,n1,n,iscr);
    num_elem_in_block[i]=n;
    ex_put_elem_block(exo_file,ids[i],curr,n,n1,0);
    ex_put_conn(exo_file,EX_ELEM_BLOCK,ids[i], TOPTR(iscr),NULL,NULL);
    curr = strtok(NULL, "\n");
  }
  free(blknames);

  /* time values */
  if (num_time_steps > 0 ) {
    std::vector<double> scr(num_time_steps);
    matGetDbl( "time", num_time_steps, 1,scr);
    for (i=0;i<num_time_steps;i++){
      ex_put_time(exo_file,i+1,&scr[i]);
    }
  }

  /* global variables */
  if (num_global_vars > 0 ){
    int max_name_length = ex_inquire_int(exo_file, EX_INQ_DB_MAX_USED_NAME_LENGTH);
    char *str = (char *) calloc(num_global_vars * (max_name_length+1), sizeof(char));
    matGetStr("gnames",str);
    str2 = (char **) calloc(num_global_vars,sizeof(char*));
    curr = strtok(str,"\n");
    for(i=0;i<num_global_vars;i++){
      str2[i]=curr;
      curr = strtok(NULL,"\n");
    }
    ex_put_variable_names(exo_file, EX_GLOBAL, num_global_vars, str2);
    free(str);
    free(str2);

    {
      std::vector<double> global_var_vals(num_global_vars*num_time_steps);
      std::vector<double> temp(num_time_steps);
      for (j=0;j<num_global_vars;j++) {
        char name[32];
        sprintf(name,"gvar%02d",j+1);
        matGetDbl(name,num_time_steps,1,temp);
        for (i=0; i < num_time_steps; i++) {
          global_var_vals[num_global_vars*i+j]=temp[i];
        }
      }
      for (i=0; i<num_time_steps; i++) {
        size_t offset = num_global_vars * i;
        ex_put_var(exo_file,i+1,EX_GLOBAL,1,0,num_global_vars,&global_var_vals[offset]);
      }
    }
  }


  /* nodal variables */ /* section by dtg */

  if (num_nodal_vars > 0){
    int max_name_length = ex_inquire_int(exo_file, EX_INQ_DB_MAX_USED_NAME_LENGTH);
    char *str = (char *) calloc(num_nodal_vars * (max_name_length+1), sizeof(char));
    matGetStr("nnames",str);
    str2 = (char **) calloc(num_nodal_vars,sizeof(char*));
    curr = strtok(str,"\n");
    for(i=0;i<num_nodal_vars;i++){
      str2[i]=curr;
      curr = strtok(NULL,"\n");
    }
    ex_put_variable_names(exo_file, EX_NODAL, num_nodal_vars, str2);
    free(str);
    free(str2);
    {
      std::vector<double> nodal_var_vals;
      for (i=0;i<num_nodal_vars;i++) {
        char name[32];
        nodal_var_vals.resize(num_nodes*num_time_steps);
        sprintf(name,"nvar%02d",i+1);
        matGetDbl(name,num_nodes,num_time_steps,nodal_var_vals);
        for (j=0;j<num_time_steps;j++) {
          ex_put_var(exo_file,j+1,EX_NODAL,i+1,0,num_nodes,&nodal_var_vals[num_nodes*j]);
        }
      }
    }
  }

  /* elemental variables */ /* section by dtg */

  if (num_element_vars > 0){
    int max_name_length = ex_inquire_int(exo_file, EX_INQ_DB_MAX_USED_NAME_LENGTH);
    char *str = (char *) calloc(num_element_vars * (max_name_length+1), sizeof(char));
    matGetStr("enames",str);
    str2 = (char **) calloc(num_element_vars,sizeof(char*));
    curr = strtok(str,"\n");
    for(i=0;i<num_element_vars;i++){
      str2[i]=curr;
      curr = strtok(NULL,"\n");
    }
    ex_put_variable_names(exo_file, EX_ELEM_BLOCK, num_element_vars, str2);
    free(str);
    free(str2);
    {
      std::vector<double> element_var_vals(num_elements*num_time_steps);
      for (i=0;i<num_element_vars;i++) {
        char name[32];
        sprintf(name,"evar%02d",i+1);
        matGetDbl(name,num_elements,num_time_steps,element_var_vals);
        n=0;
        for (j=0;j<num_time_steps;j++) {
          for (k=0;k<num_blocks;k++) {
            ex_put_var(exo_file,j+1,EX_ELEM_BLOCK, i+1,ids[k],num_elem_in_block[k],&element_var_vals[n]);
            n=n+num_elem_in_block[k];
          }
        }
      }
    }
  }

  /* node and element number maps */
  ids.resize(num_nodes);
  if ( !matGetInt("node_num_map",num_nodes,1, ids)){
    ex_put_node_num_map(exo_file,TOPTR(ids));
  }

  ids.resize(num_elements);
  if ( !matGetInt("elem_num_map",num_elements,1,ids)){
    ex_put_elem_num_map(exo_file,TOPTR(ids));
  }

  /* close exo file */
  ex_close(exo_file);

  /* close mat file */
  Mat_Close(mat_file);

  /* */
  fprintf(stderr,"done.\n");

  /* exit status */
  add_to_log("mat2exo", 0);
  return(0);
}

/**********************************************************************/
int matGetStr (const char *name,char *data)
{
  matvar_t *matvar = Mat_VarRead(mat_file, name);
  if (matvar == NULL)
    return -1;

  int strlen = matvar->nbytes;

  if (matvar->dims[0] != 1)
    printf("Error: Multiline string copy attempted\n");

  memcpy(data, matvar->data, strlen);

  Mat_VarFree(matvar);
  return 0;
}

/**********************************************************************/
int matGetDbl (const char *name,int n1,int n2, std::vector<double> &data)
{
    matvar_t *matvar = Mat_VarRead(mat_file, name);
    if (matvar == NULL)
      return -1;

    memcpy(data.data(), static_cast<int*>(matvar->data), n1*n2*sizeof(double));

    Mat_VarFree(matvar);
    return 0;
}

/**********************************************************************/
int matGetInt (const char *name,int n1,int n2, std::vector<int> &data)
{
    matvar_t *matvar = Mat_VarRead(mat_file, name);
    if (matvar == NULL)
      return -1;

    memcpy(data.data(), static_cast<int*>(matvar->data), n1*n2*sizeof(int));

    Mat_VarFree(matvar);
    return 0;
}

/**********************************************************************/
int matGetInt (const char *name, int *data)
{
    matvar_t *matvar = Mat_VarRead(mat_file, name);
    if (matvar == NULL)
      return -1;

    memcpy(data, matvar->data, sizeof(int));

    Mat_VarFree(matvar);
    return 0;
}

/**********************************************************************/
int matArrNRow (const char *name)
{
  matvar_t *matvar = Mat_VarRead(mat_file, name);
  if (matvar == NULL)
    return -1;

  int nrow = matvar->dims[0];
  Mat_VarFree(matvar);
  return nrow;
}

/**********************************************************************/
int matArrNCol (const char *name)
{
  matvar_t *matvar = Mat_VarRead(mat_file, name);
  if (matvar == NULL)
    return -1;

  int ncol = matvar->dims[1];
  Mat_VarFree(matvar);
  return ncol;
}


/**********************************************************************/
/* remove an argument from the list */
void del_arg(int *argc, char* argv[], int j)
{
  for (int jj=j+1; jj<*argc; jj++)
    argv[jj-1]=argv[jj];
  (*argc)--;
  argv[*argc]=0;
}
