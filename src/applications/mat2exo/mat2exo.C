/*
 * Copyright(C) 2012 Sandia Corporation.  Under the terms of Contract
 * DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
 * certain rights in this software
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above
 *   copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided
 *   with the distribution.
 *
 * * Neither the name of Sandia Corporation nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/**********************************************************************/
/* matlab mat file to exodus II.  This takes .mat files exactly as
   generated by the tool exo2mat written by mrtabba and converts them
   back to exodus II format

   rmnaeth. August 8, 2003

   modified by D. Todd Griffith on 12/09/2005
   * modifcations include:
   1) writes global, nodal and element variable names
   2) writes global, nodal and elemnent variable results
   3) writes complete set of time steps (previous version
          skipped first step)
   4) writes complete node set information (node set numbers,
          dist. factors, etc)
   5) writes complete side set information (side set numbers,
          dist. factors, etc)

   modified by D. Todd Griffith on 12/16/2005
   * side set distribution factors now written as double (not int)

   modified by Greg Sjaardema, 07/05/2012 to use matio instead of matlab libraries.
*/

#include <vector>
#include <string>
#include <numeric>

#include <exodusII.h>                   // for ex_inquire_int, ex_put_var, etc
#include <stddef.h>                     // for size_t
#include <stdio.h>                      // for sprintf, NULL, printf, etc
#include <stdlib.h>                     // for calloc, free, exit
#include <string.h>                     // for strtok, memcpy, strcat, etc
#include <assert.h>
#include "add_to_log.h"                 // for add_to_log
#include "matio.h"                      // for matvar_t, Mat_VarFree, etc

/**********************************************************************/
#if __cplusplus > 199711L
#define TOPTR(x) x.data()
#else
#define TOPTR(x) (x.empty() ? NULL : &x[0])
#endif

mat_t *mat_file=0;  /* file for binary .mat input */

/**********************************************************************/
static const char *qainfo[] =
{
  "mat2exo",
  "2015/07/16",
  "3.01",
};

/**********************************************************************/
void get_put_names(int exo_file, ex_entity_type entity, int num_vars, const std::string &name);

int matGetStr  (const char *name,char *str);
int matGetDbl  (const char *name,size_t n1,size_t n2, std::vector<double> &data);
int matGetInt  (const char *name,size_t n1,size_t n2, std::vector<int> &data);
int matGetInt  (const char *name);
int matArrNRow (const char *name);
int matArrNCol (const char *name);
void del_arg(int *argc, char* argv[], int j);

/**********************************************************************/
int main (int argc, char *argv[]){

  char *line,*curr;

  const char* ext=".exo";

  size_t line_size = 0;

  int i,j,k,n,n1,exo_file;

  char * blknames = NULL;

  /* QA Info */
  printf("%s: %s, %s\n", qainfo[0], qainfo[2], qainfo[1]);

  /* usage message*/
  if(argc != 2){
    printf("%s matlab_file_name.\n",argv[0]);
    printf("   the matlab_file_name is required\n");
    printf("%d", argc);
    exit(1);
  }

  /*open input file*/
  mat_file = Mat_Open(argv[1], MAT_ACC_RDONLY);
  if (mat_file == NULL) {
    printf("Error opening matlab file %s\n", argv[1]);
    return(1);
  }

  /*open output file*/
  int cpu_word_size=sizeof(double);
  int io_word_size=sizeof(double);
  /* QA records */
  /* Possibly overestimates size, but that is ok */
  line_size = strlen(argv[1]) + strlen(ext) + 1;
  line = (char *) calloc (line_size,sizeof(char));
  strcpy(line,argv[1]);
  strtok(line,".");
  strcat(line,ext);
  exo_file = ex_create(line,EX_CLOBBER,&cpu_word_size,&io_word_size);
  if (exo_file < 0){
    printf("error creating %s\n",line);
    exit(1);
  }

  /* print */
  fprintf(stderr,"translating %s to %s ... ",argv[1],line);

  /* read database parameters */
  int num_axes = matGetInt("naxes");
  int num_nodes = matGetInt("nnodes");
  int num_elements = matGetInt("nelems");
  int num_blocks   = matGetInt("nblks");
  int num_node_sets = matGetInt("nnsets");
  int num_side_sets = matGetInt("nssets");
  int num_time_steps = matGetInt("nsteps");
  int num_global_vars = matGetInt("ngvars");
  int num_nodal_vars = matGetInt("nnvars");
  int num_element_vars = matGetInt("nevars");
  int num_nodeset_vars = matGetInt("nnsvars");
  int num_sideset_vars = matGetInt("nssvars");

  /*export parameters */
  ex_put_init(exo_file,line,
              num_axes,num_nodes,num_elements,num_blocks,
              num_node_sets,num_side_sets);
  free(line);

  if ( num_global_vars > 0 ){
    ex_put_variable_param(exo_file,EX_GLOBAL,num_global_vars);
  }

  if ( num_nodal_vars > 0 ){
    ex_put_variable_param(exo_file,EX_NODAL,num_nodal_vars);
  }

  if ( num_element_vars > 0 ){
    ex_put_variable_param(exo_file,EX_ELEM_BLOCK,num_element_vars);
  }

  if ( num_nodeset_vars > 0 ){
    ex_put_variable_param(exo_file,EX_NODE_SET,num_nodeset_vars);
  }

  if ( num_sideset_vars > 0 ){
    ex_put_variable_param(exo_file,EX_SIDE_SET,num_sideset_vars);
  }

  /* nodal coordinates */
  {
    std::vector<double> x;
    std::vector<double> y;
    std::vector<double> z;
    matGetDbl("x0", num_nodes, 1, x);
    if (num_axes > 1)
      matGetDbl("y0", num_nodes, 1, y);
    if (num_axes == 3) {
      matGetDbl("z0", num_nodes,1,z);
    }
    ex_put_coord(exo_file, TOPTR(x), TOPTR(y), TOPTR(z));
  }

  std::vector<int> ids;

  /* side sets */
  std::vector<int> num_sideset_sides(num_side_sets);
  if(num_side_sets > 0){
    /* ssids */
    matGetInt("ssids",num_side_sets, 1, ids);

    /* num_sides_in_sset */
    matGetInt("nsssides",num_side_sets,1,num_sideset_sides);

    /* nssdfac */
    std::vector<int> nssdfac(num_side_sets);
    matGetInt("nssdfac",num_side_sets,1,nssdfac);

    std::vector<int> elem_list;
    std::vector<int> side_list;
    std::vector<double> escr;
    for(i=0;i<num_side_sets;i++){
      char name[32];

      ex_put_set_param(exo_file,EX_SIDE_SET,ids[i],num_sideset_sides[i],nssdfac[i]);

      sprintf(name,"sselem%02d",i+1);
      matGetInt(name,num_sideset_sides[i],1,elem_list);

      sprintf(name,"ssside%02d",i+1);
      matGetInt(name,num_sideset_sides[i],1,side_list);
      ex_put_set(exo_file,EX_SIDE_SET,ids[i], TOPTR(elem_list), TOPTR(side_list));

      sprintf(name,"ssfac%02d",i+1);
      matGetDbl(name,nssdfac[i],1,escr);
      ex_put_set_dist_fact(exo_file,EX_SIDE_SET,ids[i], TOPTR(escr));
    }

  }

  /* node sets */
  std::vector<int> num_nodeset_nodes;
  if(num_node_sets > 0){

    /* nsids */
    matGetInt("nsids",num_node_sets, 1, ids);

    matGetInt("nnsnodes",num_node_sets,1,num_nodeset_nodes);

    /* nnsdfac */
    std::vector<int> nnsdfac;
    matGetInt("nnsdfac",num_node_sets,1,nnsdfac);

    std::vector<double> escr;
    std::vector<int> node_list;
    for(i=0;i<num_node_sets;i++){
      char name[32];

      ex_put_set_param(exo_file,EX_NODE_SET,ids[i],num_nodeset_nodes[i],nnsdfac[i]);

      sprintf(name,"nsnod%02d",i+1);
      matGetInt(name,num_nodeset_nodes[i],1,node_list);
      ex_put_set(exo_file,EX_NODE_SET,ids[i], TOPTR(node_list),NULL);

      sprintf(name,"nsfac%02d",i+1);
      matGetDbl(name,nnsdfac[i],1,escr);
      ex_put_set_dist_fact(exo_file,EX_NODE_SET,ids[i], TOPTR(escr));
    }
  }


  /* element blocks */
  /* get elem block ids */
  matGetInt("blkids",num_blocks,1, ids);

  /* get elem block types */
  blknames = (char *) calloc(num_blocks*(MAX_STR_LENGTH+1),sizeof(char));
  matGetStr("blknames",blknames);
  std::vector<int> num_elem_in_block(num_blocks);
  std::vector<int> iscr;
  curr = blknames;
  curr = strtok(curr,"\n");
  for(i=0;i<num_blocks;i++){
    char name[32];

    sprintf(name,"blk%02d",i+1);
    n1 = matArrNRow(name);
    n = matArrNCol(name);
    matGetInt(name,n1,n,iscr);
    num_elem_in_block[i]=n;
    ex_put_elem_block(exo_file,ids[i],curr,n,n1,0);
    ex_put_conn(exo_file,EX_ELEM_BLOCK,ids[i], TOPTR(iscr),NULL,NULL);
    curr = strtok(NULL, "\n");
  }
  free(blknames);

  /* time values */
  if (num_time_steps > 0 ) {
    std::vector<double> scr;
    matGetDbl( "time", num_time_steps, 1,scr);
    for (i=0;i<num_time_steps;i++){
      ex_put_time(exo_file,i+1,&scr[i]);
    }
  }

  std::vector<double> var_vals;

  /* global variables */
  if (num_global_vars > 0 ){
    get_put_names(exo_file, EX_GLOBAL, num_global_vars, "gnames");

    var_vals.resize(num_global_vars*num_time_steps);
    std::vector<double> temp(num_time_steps);
    for (j=0;j<num_global_vars;j++) {
      char name[32];
      sprintf(name,"gvar%02d",j+1);
      matGetDbl(name,num_time_steps,1,temp);
      for (i=0; i < num_time_steps; i++) {
        var_vals[num_global_vars*i+j]=temp[i];
      }
    }
    for (i=0; i<num_time_steps; i++) {
      size_t offset = num_global_vars * i;
      ex_put_var(exo_file,i+1,EX_GLOBAL,1,0,num_global_vars,&var_vals[offset]);
    }
  }


  /* nodal variables */
  if (num_nodal_vars > 0){
    get_put_names(exo_file, EX_NODAL, num_nodal_vars, "nnames");

    for (i=0;i<num_nodal_vars;i++) {
      char name[32];
      sprintf(name,"nvar%02d",i+1);
      matGetDbl(name,num_nodes,num_time_steps,var_vals);
      for (j=0;j<num_time_steps;j++) {
        ex_put_var(exo_file,j+1,EX_NODAL,i+1,0,num_nodes,&var_vals[num_nodes*j]);
      }
    }
  }

  /* elemental variables */
  if (num_element_vars > 0){
    matGetInt("blkids",num_blocks,1, ids);
    get_put_names(exo_file, EX_ELEM_BLOCK, num_element_vars, "enames");

    for (i=0;i<num_element_vars;i++) {
      char name[32];
      sprintf(name,"evar%02d",i+1);
      matGetDbl(name,num_elements,num_time_steps,var_vals);
      n=0;
      for (j=0;j<num_time_steps;j++) {
        for (k=0;k<num_blocks;k++) {
          ex_put_var(exo_file,j+1,EX_ELEM_BLOCK, i+1,ids[k],num_elem_in_block[k],&var_vals[n]);
          n=n+num_elem_in_block[k];
        }
      }
    }
  }

  /* nodeset variables */
  if (num_nodeset_vars > 0){
    matGetInt("nsids",num_node_sets, 1, ids);
    get_put_names(exo_file, EX_NODE_SET, num_nodeset_vars, "nsnames");

    size_t num_nodes_in_nset = std::accumulate(num_nodeset_nodes.begin(), num_nodeset_nodes.end(), 0);

    for (i=0;i<num_nodeset_vars;i++) {
      char name[32];
      sprintf(name,"nsvar%02d",i+1);
      matGetDbl(name,num_nodes_in_nset,num_time_steps,var_vals);
      n=0;
      for (j=0;j<num_time_steps;j++) {
        for (k=0;k<num_node_sets;k++) {
          ex_put_var(exo_file,j+1,EX_NODE_SET, i+1,ids[k],num_nodeset_nodes[k],&var_vals[n]);
          n=n+num_nodeset_nodes[k];
        }
      }
    }
  }

  /* sideset variables */
  if (num_sideset_vars > 0){
    matGetInt("ssids",num_side_sets, 1, ids);
    get_put_names(exo_file, EX_SIDE_SET, num_sideset_vars, "ssnames");

    size_t num_sides_in_sset = std::accumulate(num_sideset_sides.begin(), num_sideset_sides.end(), 0);

    for (i=0;i<num_sideset_vars;i++) {
      char name[32];
      sprintf(name,"ssvar%02d",i+1);
      matGetDbl(name,num_sides_in_sset,num_time_steps,var_vals);
      n=0;
      for (j=0;j<num_time_steps;j++) {
        for (k=0;k<num_side_sets;k++) {
          ex_put_var(exo_file,j+1,EX_SIDE_SET, i+1,ids[k],num_sideset_sides[k],&var_vals[n]);
          n=n+num_sideset_sides[k];
        }
      }
    }
  }

  /* node and element number maps */
  if ( !matGetInt("node_num_map",num_nodes,1, ids)){
    ex_put_node_num_map(exo_file,TOPTR(ids));
  }

  if ( !matGetInt("elem_num_map",num_elements,1,ids)){
    ex_put_elem_num_map(exo_file,TOPTR(ids));
  }

  /* close exo file */
  ex_close(exo_file);

  /* close mat file */
  Mat_Close(mat_file);

  /* */
  fprintf(stderr,"done.\n");

  /* exit status */
  add_to_log("mat2exo", 0);
  return(0);
}

/**********************************************************************/
int matGetStr (const char *name,char *data)
{
  matvar_t *matvar = Mat_VarRead(mat_file, name);
  if (matvar == NULL)
    return -1;

  int strlen = matvar->nbytes;

  if (matvar->dims[0] != 1)
    printf("Error: Multiline string copy attempted\n");

  memcpy(data, matvar->data, strlen);

  Mat_VarFree(matvar);
  return 0;
}

/**********************************************************************/
int matGetDbl (const char *name,size_t n1,size_t n2, std::vector<double> &data)
{
    matvar_t *matvar = Mat_VarRead(mat_file, name);
    if (matvar == NULL)
      return -1;

    assert(matvar->dims[0] == n1);
    assert(matvar->dims[1] == n2);

    data.resize(n1*n2);
    memcpy(data.data(), static_cast<int*>(matvar->data), n1*n2*sizeof(double));

    Mat_VarFree(matvar);
    return 0;
}

/**********************************************************************/
int matGetInt (const char *name,size_t n1,size_t n2, std::vector<int> &data)
{
    matvar_t *matvar = Mat_VarRead(mat_file, name);
    if (matvar == NULL)
      return -1;

    assert(matvar->dims[0] == n1);
    assert(matvar->dims[1] == n2);

    data.resize(n1*n2);
    memcpy(data.data(), static_cast<int*>(matvar->data), n1*n2*sizeof(int));

    Mat_VarFree(matvar);
    return 0;
}

/**********************************************************************/
int matGetInt (const char *name)
{
  matvar_t *matvar = Mat_VarRead(mat_file, name);
  if (matvar == NULL)
    return -1;

  assert(matvar->dims[0] == 1);
  assert(matvar->dims[1] == 1);

  int data = static_cast<int*>(matvar->data)[0];

  Mat_VarFree(matvar);
  return data;
}

/**********************************************************************/
int matArrNRow (const char *name)
{
  matvar_t *matvar = Mat_VarRead(mat_file, name);
  if (matvar == NULL)
    return -1;

  int nrow = matvar->dims[0];
  Mat_VarFree(matvar);
  return nrow;
}

/**********************************************************************/
int matArrNCol (const char *name)
{
  matvar_t *matvar = Mat_VarRead(mat_file, name);
  if (matvar == NULL)
    return -1;

  int ncol = matvar->dims[1];
  Mat_VarFree(matvar);
  return ncol;
}


/**********************************************************************/
/* remove an argument from the list */
void del_arg(int *argc, char* argv[], int j)
{
  for (int jj=j+1; jj<*argc; jj++)
    argv[jj-1]=argv[jj];
  (*argc)--;
  argv[*argc]=0;
}

void get_put_names(int exo_file, ex_entity_type entity, int num_vars, const std::string &name)
{
  int max_name_length = ex_inquire_int(exo_file, EX_INQ_DB_MAX_USED_NAME_LENGTH);
  char *str = (char *) calloc(num_vars * (max_name_length+1), sizeof(char));
  matGetStr(name.c_str(), str);
  char **str2 = (char **) calloc(num_vars,sizeof(char*));
  char *curr = strtok(str,"\n");
  for (int i=0; i<num_vars; i++) {
    str2[i]=curr;
    curr = strtok(NULL,"\n");
  }
  ex_put_variable_names(exo_file, entity, num_vars, str2);
  free(str);
  free(str2);
}
