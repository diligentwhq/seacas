<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 7.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="exodusII.book.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>
 Table of Contents
</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<P CLASS="Body">
<A NAME="50334049_pgfId-31"></A>&nbsp;</P>
<DIV>
<H2 CLASS="Title-toc">
<A NAME="50334050_pgfId-26"></A>Table of Contents</H2>
<P CLASS="Body">
<A NAME="50334050_pgfId-25"></A>			Page</P>
<P CLASS="FM1HeadingTOC">
<A NAME="50334050_pgfId-2232"></A>Introduction 	1</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2233"></A>Availability 	2</P>
<P CLASS="FM1HeadingTOC">
<A NAME="50334050_pgfId-2234"></A>Development of EXODUS II 	3</P>
<P CLASS="FM1HeadingTOC">
<A NAME="50334050_pgfId-2235"></A>Description of Data Objects 	4</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2236"></A>Global Parameters 	5</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2237"></A>Quality Assurance Data 	6</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2238"></A>Information Data 	6</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2239"></A>Nodal Coordinates 	6</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2240"></A>Coordinate Names 	6</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2241"></A>Node Number Map 	7</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2242"></A>Element Number Map 	7</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2243"></A>Optimized Element Order Map 	8</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2244"></A>Element Blocks 	8</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2245"></A>Element Block Parameters 	8</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2246"></A>Element Connectivity 	9</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2247"></A>Element Attributes 	9</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2248"></A>Node Sets 	11</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2249"></A>Node Set Parameters 	11</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2250"></A>Node Set Node List 	11</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2251"></A>Node Set Distribution Factors 	11</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2252"></A>Concatenated Node Sets 	11</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2253"></A>Side Sets 	12</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2254"></A>Side Set Parameters 	14</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2255"></A>Side Set Element List 	14</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2256"></A>Side Set Side List 	14</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2257"></A>Side Set Node List 	14</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2258"></A>Side Set Node Count List 	15</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2259"></A>Side Set Distribution Factors 	15</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2260"></A>Concatenated Side Sets 	15</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2261"></A>Object Properties 	17</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2262"></A>Property Parameters 	18</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2263"></A>Property Values 	18</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2264"></A>Results Parameters 	19</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2265"></A>Results Names 	19</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2266"></A>Results Data 	19</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2267"></A>Time Values 	19</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2268"></A>Global Results 	19</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2269"></A>Nodal Results 	19</P>
<P CLASS="FM3HeadingTOC">
<A NAME="50334050_pgfId-2270"></A>Element Results 	20</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2271"></A>Element Variable Truth Table 	20</P>
<P CLASS="FM1HeadingTOC">
<A NAME="50334050_pgfId-2272"></A>Application Programming Interface (API) 	21</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2273"></A>Data File Utilities 	22</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2274"></A>Create EXODUS II File 	23</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2275"></A>Open EXODUS II File 	25</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2276"></A>Close EXODUS II File 	27</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2277"></A>Update EXODUS II File 	28</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2278"></A>Write Initialization Parameters 	29</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2279"></A>Read Initialization Parameters 	31</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2280"></A>Write QA Records 	33</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2281"></A>Read QA Records 	35</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2282"></A>Write Information Records 	37</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2283"></A>Read Information Records 	39</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2284"></A>Inquire EXODUS Parameters 	41</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2285"></A>Error Reporting 	45</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2286"></A>Set Error Reporting Level 	47</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2287"></A>Model Description 	48</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2288"></A>Write Nodal Coordinates 	49</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2289"></A>Read Nodal Coordinates 	51</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2290"></A>Write Coordinate Names 	53</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2291"></A>Read Coordinate Names 	55</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2292"></A>Write Node Number Map 	56</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2293"></A>Read Node Number Map 	58</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2294"></A>Write Element Number Map 	59</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2295"></A>Read Element Number Map 	61</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2296"></A>Write Element Order Map 	62</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2297"></A>Read Element Order Map 	64</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2298"></A>Write Element Block Parameters 	65</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2299"></A>Read Element Block Parameters 	68</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2300"></A>Read Element Blocks IDs 	70</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2301"></A>Write Element Block Connectivity 	71</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2302"></A>Read Element Block Connectivity 	72</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2303"></A>Write Element Block Attributes 	73</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2304"></A>Read Element Block Attributes 	75</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2305"></A>Write Node Set Parameters 	77</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2306"></A>Read Node Set Parameters 	79</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2307"></A>Write Node Set 	81</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2308"></A>Read Node Set 	82</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2309"></A>Write Node Set Distribution Factors 	83</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2310"></A>Read Node Set Distribution Factors 	85</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2311"></A>Read Node Sets IDs 	86</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2312"></A>Write Concatenated Node Sets 	87</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2313"></A>Read Concatenated Node Sets 	91</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2314"></A>Write Side Set Parameters 	94</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2315"></A>Read Side Set Parameters 	96</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2316"></A>Write Side Set 	98</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2317"></A>Read Side Set 	100</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2318"></A>Write Side Set Distribution Factors 	102</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2319"></A>Read Side Set Distribution Factors 	104</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2320"></A>Read Side Sets IDs 	105</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2321"></A>Read Side Set Node List 	106</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2322"></A>Write Concatenated Side Sets 	108</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2323"></A>Read Concatenated Side Sets 	112</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2324"></A>Convert Side Set Nodes to Sides 	115</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2325"></A>Write Property Arrays Names 	118</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2326"></A>Read Property Arrays Names 	120</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2327"></A>Write Object Property 	122</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2328"></A>Read Object Property 	124</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2329"></A>Write Object Property Array 	126</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2330"></A>Read Object Property Array 	128</P>
<P CLASS="FM2HeadingTOC">
<A NAME="50334050_pgfId-2331"></A>Results Data 	130</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2332"></A>Write Results Variables Parameters 	131</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2333"></A>Read Results Variables Parameters 	133</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2334"></A>Write Results Variables Names 	135</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2335"></A>Read Results Variables Names 	137</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2336"></A>Write Time Value for a Time Step 	139</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2337"></A>Read Time Value for a Time Step 	141</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2338"></A>Read All Time Values 	143</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2339"></A>Write Element Variable Truth Table 	145</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2340"></A>Read Element Variable Truth Table 	147</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2341"></A>Write Element Variable Values at a Time Step 	149</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2342"></A>Read Element Variable Values at a Time Step 	152</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2343"></A>Read Element Variable Values through Time 	154</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2344"></A>Write Global Variables Values at a Time Step 	157</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2345"></A>Read Global Variables Values at a Time Step 	159</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2346"></A>Read Global Variable Values through Time 	161</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2347"></A>Write Nodal Variable Values at a Time Step 	163</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2348"></A>Read Nodal Variable Values at a Time Step 	165</P>
<P CLASS="Heading3TOC">
<A NAME="50334050_pgfId-2349"></A>Read Nodal Variable Values through Time 	167</P>
<P CLASS="FM1HeadingTOC">
<A NAME="50334050_pgfId-2350"></A>References 	169</P>
<DIV>
<H6 CLASS="AppendixTOC">
<A NAME="50334050_pgfId-2351"></A>Appendix A 	A-1</H6>
<DIV>
<H6 CLASS="AppTitleTOC">
<A NAME="50334050_pgfId-2352"></A>	Implementation of EXODUS II with netCDF 	A-1</H6>
<P CLASS="HeadingTOC">
<A NAME="50334050_pgfId-2353"></A>		Description 	A-1</P>
<P CLASS="HeadingTOC">
<A NAME="50334050_pgfId-2354"></A>		Efficiency Issues 	A-1</P>
<P CLASS="HeadingTOC">
<A NAME="50334050_pgfId-2355"></A>		netCDF Data Objects 	A-1</P>
<P CLASS="AppMinorTOC">
<A NAME="50334050_pgfId-2356"></A>		Attributes 	A-2</P>
<P CLASS="AppMinorTOC">
<A NAME="50334050_pgfId-2357"></A>		Dimensions 	A-2</P>
<P CLASS="AppMinorTOC">
<A NAME="50334050_pgfId-2358"></A>		Variables 	A-4</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="AppendixTOC">
<A NAME="50334050_pgfId-2359"></A>Appendix B 	B-1</H6>
<DIV>
<H6 CLASS="AppTitleTOC">
<A NAME="50334050_pgfId-2360"></A>	Function Call Summary 	B-1</H6>
<P CLASS="HeadingTOC">
<A NAME="50334050_pgfId-2361"></A>		C binding routines 	B-1</P>
<P CLASS="HeadingTOC">
<A NAME="50334050_pgfId-2362"></A>		FORTRAN binding routines 	B-9</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="AppendixTOC">
<A NAME="50334050_pgfId-2363"></A>Appendix C 	C-1</H6>
<DIV>
<H6 CLASS="AppTitleTOC">
<A NAME="50334050_pgfId-2364"></A>	Error Messages 	C-1</H6>
</DIV>
</DIV>
<DIV>
<H6 CLASS="AppendixTOC">
<A NAME="50334050_pgfId-2365"></A>Appendix D 	D-1</H6>
<DIV>
<H6 CLASS="AppTitleTOC">
<A NAME="50334050_pgfId-2366"></A>	 Sample Codes 	D-1</H6>
<P CLASS="HeadingTOC">
<A NAME="50334050_pgfId-2367"></A>		C Write Example Code 	D-1</P>
<P CLASS="HeadingTOC">
<A NAME="50334050_pgfId-2368"></A>		C Read Example Code 	D-10</P>
<P CLASS="HeadingTOC">
<A NAME="50334050_pgfId-2369"></A>		FORTRAN Write Example Code 	D-17</P>
<P CLASS="HeadingTOC">
<A NAME="50334050_pgfId-2370"></A>		FORTRAN Read Example Code 	D-24</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Title-indTOC">
<A NAME="50334050_pgfId-2371"></A>Index 	I-1</H6>
</DIV>
</DIV>
<DIV>
<H2 CLASS="FM1Heading">
<A NAME="50334051_pgfId-643"></A><A NAME="50334051_11154"></A>Introduction</H2>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-646"></A>EXODUS II is the successor of the widely used finite element (FE) data file format EXODUS [1] (henceforth referred to as EXODUS I) developed by Mills-Curran and Flanagan. It continues the concept of a common database for multiple application codes (mesh generators, analysis codes, visualization software, etc.) rather than code-specific utilities, affording flexibility and robustness for both the application code developer and application code user. By using the EXODUS II data model, a user inherits the flexibility of using a large array of application codes (including vendor-supplied codes) which access this common data file directly or via translators.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-647"></A>The uses of the EXODUS II data model include the following, as illustrated in <A HREF="exodusII.html#50334051_14389" CLASS="XRef">See Uses of EXODUS II</A>:</P>
<UL>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-648"></A>problem definition -- mesh generation, specification of locations of boundary conditions and load application, specification of material types.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-649"></A>simulation -- model input and results output.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-650"></A>visualization -- model verification, results postprocessing, data interrogation, and analysis tracking.</LI>
</UL>
<DIV>
<MAP NAME="exodusII.book-1">
</MAP>
<IMG SRC="exodusII.book-1.gif" USEMAP="#exodusII.book-1">
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-738"></A>Availability</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-739"></A>The EXODUS II library is maintained in the Sandia National Laboratories Engineering Analysis Code Access System (SEACAS) [2] and is available on a licensed basis. For more information on obtaining the EXODUS II library, contact:</P>
<P CLASS="single-line">
<A NAME="50334051_pgfId-743"></A>Marilyn K. Smith</P>
<P CLASS="single-line">
<A NAME="50334051_pgfId-744"></A>Research Programs Department</P>
<P CLASS="single-line">
<A NAME="50334051_pgfId-745"></A>Department 9103; MS 0833</P>
<P CLASS="single-line">
<A NAME="50334051_pgfId-746"></A>Sandia National Laboratories</P>
<P CLASS="single-line">
<A NAME="50334051_pgfId-747"></A>P.O. Box 5800</P>
<P CLASS="single-line">
<A NAME="50334051_pgfId-748"></A>Albuquerque, NM 87185-0833</P>
<P CLASS="single-line">
<A NAME="50334051_pgfId-749"></A>PHONE:		(505) 844-3082</P>
<P CLASS="single-line">
<A NAME="50334051_pgfId-6473"></A>FAX: 		(505) 844-8251</P>
<P CLASS="single-line">
<A NAME="50334051_pgfId-6474"></A>EMAIL		mksmith@sandia.gov</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-8705"></A>For bug reports, documentation errors, and enhancement suggestions, contact:</P>
<P CLASS="single-line">
<A NAME="50334051_pgfId-8706"></A>Larry A. Schoof</P>
<P CLASS="single-line">
<A NAME="50334051_pgfId-8707"></A>PHONE:		(505) 844-5156</P>
<P CLASS="single-line">
<A NAME="50334051_pgfId-8708"></A>EMAIL:		laschoo@sandia.gov</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="FM1Heading">
<A NAME="50334051_pgfId-652"></A>Development of EXODUS II</H2>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-653"></A>The evolution of the EXODUS data model has been steered by FE application code developers who desire the advantages of a common data format. The EXODUS II model has been designed to overcome deficiencies in the EXODUS I file format and meet the following functional requirements as specified by these developers:</P>
<UL>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-3263"></A>random read/write access.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-3264"></A>application programming interface (API) -- provide routines callable from FORTRAN, C, and C++ application codes.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-3276"></A>extensible -- allow new data objects to be added without modifying the application programs that use the file format.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-3282"></A>machine independent -- data should be independent of the machine which generated it.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-3285"></A>real time access during analysis -- allow access to the data in a file while the file is being created.</LI>
</UL>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-3307"></A>To address these requirements, the public domain database library <A NAME="50334051_marker-303"></A>netCDF [3] was selected to handle the low-level data storage. The EXODUS II library functions provide the mapping between FE data objects and netCDF dimensions, attributes, and variables. (These mappings are documented in <A HREF="exodusII.book.html#50334052_41997" CLASS="XRef"></A>.) Thus, the code developer interacts with the data model using the vocabulary of an FE analyst (element connectivity, nodal coordinates, etc.) and is relieved of the details of the data access mechanism. To provide machine independency, the netCDF library stores data in eXternal Data Representation (<A NAME="50334051_marker-304"></A>XDR) [4] format.</P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-3242"></A>Because an EXODUS II file is a netCDF file, an application program can access data via the EXODUS II API, the netCDF API, or XDR function calls directly. This functionality is illustrated in <A HREF="exodusII.html#50334051_13659" CLASS="XRef">See EXODUS II Implementation</A>. Although the latter two methods require more in-depth understanding of netCDF and/or XDR, this capability is a powerful feature that allows the development of auxiliary libraries of special purpose functions not offered in the standard EXODUS II library. For example, if an application required access to the coordinates of a single node (the standard library function returns the coordinates for all of the nodes in the model), a simple function could be written that calls netCDF routines directly to read the data of interest. </P>
<DIV>
<MAP NAME="exodusII.book-2">
</MAP>
<IMG SRC="exodusII.book-2.gif" USEMAP="#exodusII.book-2">
</DIV>
</DIV>
<DIV>
<H2 CLASS="FM1Heading">
<A NAME="50334051_pgfId-656"></A>Description of Data Objects </H2>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-703"></A>The data in EXODUS II files can be divided into three primary categories: <A NAME="50334051_marker-305"></A>initialization data, <A NAME="50334051_marker-306"></A>model, and <A NAME="50334051_marker-307"></A>results. </P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-617"></A>Initialization data includes sizing parameters (number of nodes, number of elements, etc.), optional quality assurance information (names of codes that have operated on the data), and optional informational text. </P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-618"></A>The model is described by data which are static (do not change through time). This data includes nodal coordinates, element connectivity (node lists for each element), element attributes, and node sets and side sets (used to aid in applying loading conditions and boundary constraints). </P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-705"></A>The results are optional and include three types of variables -- nodal, element, and global -- each of which is stored through time. Nodal results are output (at each time step) for all the nodes in the model. An example of a <A NAME="50334051_marker-308"></A>nodal variable is displacement in the X direction. Element results are output (at each time step) for all elements in one or more element blocks. For example, stress may be an <A NAME="50334051_marker-309"></A>element variable. Another use of element variables is to record element status (a binary flag indicating whether each element is &quot;alive&quot; or &quot;dead&quot;) through time. Global results are output (at each time step) for a single element or node, or for a single property. Linear momentum of a structure and the acceleration at a particular point are both examples of <A NAME="50334051_marker-310"></A>global variables. Although these examples correspond to typical FE applications, the data format is flexible enough to accomodate a spectrum of uses.</P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-708"></A>A few <A NAME="50334051_marker-313"></A>conventions and limitations must be cited:</P>
<UL>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-706"></A>There are no restrictions on the frequency of results output except that the time value associated with each successive time step must increase monotonically.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-721"></A>To output results at different frequencies (i.e., variable A at every simulation time step, variable B at every other time step) multiple EXODUS II files must be used.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-707"></A>There are no limits to the number of each type of results, but once declared, the number cannot change. </LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4718"></A>If the mesh geometry changes in time (i.e., number of nodes increases, connectivity changes), the new geometry must be output to a new EXODUS II file.</LI>
</UL>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-616"></A>The following sections describe the data objects that can be stored in an EXODUS II file. API functions that read / write the particular objects are included for reference. API routines for the C binding are in lower case; functions for the Fortran binding are in upper case. Refer to <A HREF="exodusII.book.html#50334051_33195" CLASS="XRef">See Application Programming Interface (API)</A> for a detailed description of each API function.</P>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-657"></A>Global Parameters </H3>
<P CLASS="api-func">
<A NAME="50334051_pgfId-619"></A><EM CLASS="code">
API functions: 	ex_put_init, ex_get_init; EXPINI, EXGINI</EM>
<A NAME="50334051_marker-17"></A><A NAME="50334051_marker-167"></A><A NAME="50334051_marker-168"></A><A NAME="50334051_marker-169"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-665"></A>Every EXODUS II file is initialized with the following parameters:</P>
<UL>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-658"></A>Title -- data file <A NAME="50334051_marker-314"></A>title of length <EM CLASS="code">
MAX_LINE_LENGTH</EM>
 (<EM CLASS="code">
MXLNLN</EM>
 in Fortran). Refer to discussion below for definition of <EM CLASS="code">
MAX_LINE_LENGTH</EM>
.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-724"></A>Number of nodes -- the total <A NAME="50334051_marker-315"></A>number of nodes in the model.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-659"></A>Problem <A NAME="50334051_marker-316"></A>dimension -- the number of spatial coordinates per node (1, 2, or 3).</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-660"></A>Number of elements -- the total <A NAME="50334051_marker-317"></A>number of elements of all types in the file.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-661"></A>Number of <A NAME="50334051_marker-318"></A>element blocks -- within the EXODUS data model, elements are grouped together into blocks. Refer to <A HREF="exodusII.book.html#50334051_23804" CLASS="XRef">See Element Blocks</A> for a description of element blocks. </LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-662"></A>Number of <A NAME="50334051_marker-319"></A>node sets -- node sets are a convenient method for referring to groups of nodes. Refer to <A HREF="exodusII.book.html#50334051_25958" CLASS="XRef">See Node Sets</A> for a description of node sets.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-663"></A>Number of <A NAME="50334051_marker-320"></A>side sets -- side sets are used to identify elements (and their sides) for specific purposes. Refer to <A HREF="exodusII.book.html#50334051_36506" CLASS="XRef">See Side Sets</A> for a description of side sets.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-664"></A>Database <A NAME="50334051_marker-321"></A>version number -- the version of the data objects stored in the file. This document describes database version is 2.02.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-722"></A>API version number -- the version of the EXODUS library functions which stored the data in the file. The API version can change without changing the database version and vice versa. This document describes API version 2.03.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-723"></A>I/O <A NAME="50334051_marker-322"></A>word size -- indicates the precision of the floating point data stored in the file. Currently, four- or eight-byte floating point numbers are supported. It is not necessary that an application code be written to handle the same precision as the data stored in the file. If required, the routines in the EXODUS II library perform automatic conversion between four- and eight-byte numbers.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-725"></A>Length of <A NAME="50334051_marker-332"></A>character strings -- all character data stored in an EXODUS II file is either of length <EM CLASS="code">
MAX_STR_LENGTH</EM>
 (<EM CLASS="code">
MXSTLN</EM>
 in Fortran) or <EM CLASS="code">
MAX_LINE_LENGTH</EM>
 (<EM CLASS="code">
MXLNLN</EM>
 in Fortran). This allows Fortran application codes to declare the lengths of character variables as predefined constants. These two constants are defined in the file exodusII.h (exodusII.inc for Fortran). Current values are 32 and 80, respectively.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-726"></A>Length of character lines -- see description above for length of character strings.</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-666"></A>Quality Assurance Data</H3>
<P CLASS="api-func">
<A NAME="50334051_pgfId-667"></A>API functions: <EM CLASS="code">
	ex_put_qa</EM>
<A NAME="50334051_marker-170"></A>, <EM CLASS="code">
ex_get_qa</EM>
<A NAME="50334051_marker-171"></A>; <EM CLASS="code">
EXPQA</EM>
<A NAME="50334051_marker-172"></A>, <EM CLASS="code">
EXGQA</EM>
<A NAME="50334051_marker-173"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-633"></A>Q<A NAME="50334051_marker-323"></A>uality assurance (QA) data is optional information that can be included to indicate which application codes have operated on the data in the file. Any number of QA records can be included, with each record containing four character strings of length <EM CLASS="code">
MAX_STR_LENGTH</EM>
 (<EM CLASS="code">
MXSTLN</EM>
 in Fortran). The four character strings are the following (in order):</P>
<OL>
<LI CLASS="number1">
<A NAME="50334051_pgfId-669"></A>Code name -- indicates the application code that has operated on the EXODUS II file.</LI>
<LI CLASS="number">
<A NAME="50334051_pgfId-670"></A>Code QA descriptor -- provides a location for a version identifier of the application code.</LI>
<LI CLASS="number">
<A NAME="50334051_pgfId-671"></A>Date -- the date on which the application code was executed; should be in the format 01/25/93.</LI>
<LI CLASS="number">
<A NAME="50334051_pgfId-672"></A>Time -- the 24-hour time at which the application code was executed; should be in the format hours:minutes:seconds, such as 16:30:15.</LI>
</OL>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-674"></A><A NAME="50334051_marker-324"></A>Information Data</H3>
<P CLASS="api-func">
<A NAME="50334051_pgfId-668"></A>API functions: <EM CLASS="code">
	ex_put_info</EM>
<A NAME="50334051_marker-174"></A>, <EM CLASS="code">
ex_get_info</EM>
<A NAME="50334051_marker-175"></A>; <EM CLASS="code">
EXPINF</EM>
<A NAME="50334051_marker-176"></A>, <EM CLASS="code">
EXGINF</EM>
<A NAME="50334051_marker-177"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-634"></A>This is for storage of optional supplementary text. Each text record is of length <EM CLASS="code">
MAX_LINE_LENGTH</EM>
 (<EM CLASS="code">
MXLNLN</EM>
 in Fortran); there is no limit to the number of text records.</P>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-678"></A>Nodal Coordinates</H3>
<P CLASS="api-func">
<A NAME="50334051_pgfId-673"></A>API functions: <EM CLASS="code">
	ex_put_coord</EM>
<A NAME="50334051_marker-178"></A>, <EM CLASS="code">
ex_get_coord</EM>
<A NAME="50334051_marker-179"></A>; <EM CLASS="code">
EXPCOR</EM>
<A NAME="50334051_marker-180"></A>, <EM CLASS="code">
EXGCOR</EM>
<A NAME="50334051_marker-181"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-635"></A>The <A NAME="50334051_marker-325"></A>nodal coordinates are the floating point spatial coordinates of all the nodes in the model. The number of nodes and the problem dimension define the length of this array. The node index cycles faster than the dimension index, thus the X coordinates for all the nodes is written before any Y coordinate data are written. Internal node numbers (beginning with 1) are implied from a nodes's place in the nodal coordinates record. See <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A> for a discussion of internal node numbers.</P>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-679"></A>Coordinate Names </H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-680"></A>API functions: <EM CLASS="code">
	ex_put_coord_names</EM>
<A NAME="50334051_marker-182"></A>, <EM CLASS="code">
ex_get_coord_names</EM>
<A NAME="50334051_marker-183"></A>; <EM CLASS="code">
EXPCON</EM>
<A NAME="50334051_marker-184"></A>, <EM CLASS="code">
EXGCON</EM>
<A NAME="50334051_marker-185"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-636"></A>The <A NAME="50334051_marker-326"></A>coordinate names are character strings of length <EM CLASS="code">
MAX_STR_LENGTH</EM>
 (<EM CLASS="code">
MXSTLN</EM>
 in Fortran) which name the spatial coordinates. There is one string for each dimension in the model, thus there are one to three strings.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-681"></A><A NAME="50334051_marker-8748"></A><A NAME="50334051_19003"></A>Node Number Map</H3>
<P CLASS="api-func">
<A NAME="50334051_pgfId-8729"></A>API functions: <EM CLASS="code">
	ex_put_node_num_map, ex_get_node_num_map, EXPNNM, EXGNNM</EM>
<A NAME="50334051_marker-8744"></A><A NAME="50334051_marker-8745"></A><A NAME="50334051_marker-8746"></A><A NAME="50334051_marker-8747"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-8760"></A>Within the data model, internal node IDs are indices into the nodal coordinate array and internal element IDs are indices into the element connectivity array. Thus, internal node and element numbers (IDs) are contiguous (i.e., 1 . . . <EM CLASS="code">
number_of_nodes</EM>
 and 1 . . . <EM CLASS="code">
number_of_elements</EM>
, respectively). Optional node and element number maps can be stored to relate user-defined node and element IDs to these internal node and element numbers. The length of these maps are <EM CLASS="code">
number_of_nodes</EM>
 and <EM CLASS="code">
number_of_elements</EM>
, respectively. As an example, suppose a database contains exactly one QUAD element with four nodes.  The user desires the element ID to be 100 and the node IDs to be 10, 20, 30, and 40 as shown in <A HREF="exodusII.html#50334051_28033" CLASS="XRef">See User-defined Node and Element IDs</A>. </P>
<DIV>
<MAP NAME="exodusII.book-3">
</MAP>
<IMG SRC="exodusII.book-3.gif" USEMAP="#exodusII.book-3">
</DIV>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-8819"></A>The internal data structures representing the above model would be the following:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-8820"></A><EM CLASS="code">
nodal coordinate array</EM>
: <EM CLASS="computer">
(0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0)</EM>
</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-8821"></A><EM CLASS="code">
connectivity array</EM>
<EM CLASS="computer">
: (1, 2, 3, 4)</EM>
</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-8883"></A><EM CLASS="code">
node number map</EM>
<EM CLASS="computer">
: (10, 20, 30, 40)</EM>
</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-8822"></A><EM CLASS="code">
element number map</EM>
<EM CLASS="computer">
: (100)</EM>
</P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-8824"></A>Internal (contiguously numbered) node and element IDs must be used for all data structures that contain node or element numbers (IDs), including node set node lists, side set element lists, and element connectivity.  Additionally, to inquire the value(s) of node or element results variables, an application code must pass the internal node or element number for the node or element of interest.</P>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-6556"></A><A NAME="50334051_marker-9371"></A>Element Number Map</H3>
<P CLASS="api-func">
<A NAME="50334051_pgfId-8938"></A>API functions: <EM CLASS="code">
	ex_put_elem_num_map, ex_get_elem_num_map, EXPENM, EXGENM</EM>
<A NAME="50334051_marker-8936"></A><A NAME="50334051_marker-8937"></A><A NAME="50334051_marker-8939"></A><A NAME="50334051_marker-8940"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-8945"></A>Refer to <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A> for a discussion of the optional element number map.</P>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-6555"></A>Optimized Element Order Map</H3>
<P CLASS="api-func">
<A NAME="50334051_pgfId-682"></A>API functions: <EM CLASS="code">
	ex_put_map</EM>
<A NAME="50334051_marker-186"></A>, <EM CLASS="code">
ex_get_map</EM>
<A NAME="50334051_marker-187"></A>; <EM CLASS="code">
EXPMAP</EM>
<A NAME="50334051_marker-188"></A>, <EM CLASS="code">
EXGMAP</EM>
<A NAME="50334051_marker-189"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-638"></A>The optional <A NAME="50334051_marker-327"></A>element order map defines the element order in which a solver (e.g., a wavefront solver) should process the elements. For example, the first entry is the number of the element which should be processed first by the solver. The length of this map is the total number of elements in the model. </P>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-683"></A><A NAME="50334051_23804"></A>Element Blocks</H3>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-675"></A>For efficient storage and to minimize I/O, elements are grouped into <A NAME="50334051_marker-328"></A>element blocks. Within an element block, all elements are of the same type (basic geometry and number of nodes). This definition does not preclude multiple element blocks containing the same element type (i.e., &quot;QUAD&quot; elements may be in more than one element block); only that each element block may contain only one element type.</P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-676"></A>The internal number of an <A NAME="50334051_marker-329"></A>element is defined implicitly by the order in which it appears in the file. Elements are numbered internally (beginning with 1) consecutively across all element blocks. See <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A> for a discussion of internal element numbering.</P>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-684"></A>Element Block Parameters </H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-677"></A>API functions: <EM CLASS="code">
	ex_put_elem_block</EM>
<A NAME="50334051_marker-190"></A>, <EM CLASS="code">
ex_get_elem_block</EM>
<A NAME="50334051_marker-191"></A>, <EM CLASS="code">
ex_get_elem_blk_ids</EM>
<A NAME="50334051_marker-194"></A>; <EM CLASS="code">
EXPELB</EM>
<A NAME="50334051_marker-192"></A>, <EM CLASS="code">
EXGELB</EM>
<A NAME="50334051_marker-193"></A>, <EM CLASS="code">
EXGEBI</EM>
<A NAME="50334051_marker-195"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-755"></A>The following parameters are defined for each element block:</P>
<UL>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-685"></A><A NAME="50334051_marker-330"></A>Element block ID -- an arbitrary, unique, positive integer which identifies the particular element block. This ID is used as a &quot;handle&quot; into the database that allows users to specify a group of elements to the application code without having to know the order in which element blocks are stored in the file.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-727"></A><A NAME="50334051_marker-331"></A>Element type -- a character string of length <EM CLASS="code">
MAX_STR_LENGTH</EM>
 (<EM CLASS="code">
MXSTLN</EM>
 in Fortran) to distinguish element types. All elements within the element block are of this type. Refer to <A HREF="exodusII.html#50334051_22749" CLASS="XRef">See Element Types and Attributes</A> for a list of names that are currently accepted. For historical reasons, the names should be all upper case. It should be noted that the EXODUS II library routines do not verify element type names against a standard list; the interpretation of the element type is left to the application codes which read or write the data. In general, the first three characters uniquely identify the element type. Application codes can append characters to the element type string (up to the maximum length allowed) to further classify the element for specific purposes.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-686"></A>Number of elements -- the number of elements in the element block.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-687"></A>Nodes per element -- the number of nodes per element for the element block.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-688"></A>Number of <A NAME="50334051_marker-333"></A>attributes -- the number of attributes per element in the element block. See below for a discussion of element attributes.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-690"></A>Element Connectivity </H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-689"></A>API functions: 	<EM CLASS="code">
ex_put_elem_conn</EM>
<A NAME="50334051_marker-196"></A>, <EM CLASS="code">
ex_get_elem_conn</EM>
<A NAME="50334051_marker-197"></A>; <EM CLASS="code">
EXPELC</EM>
<A NAME="50334051_marker-198"></A>, <EM CLASS="code">
EXGELC</EM>
<A NAME="50334051_marker-199"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-728"></A>The <A NAME="50334051_marker-165"></A>element connectivity contains the list of nodes (internal node IDs; see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A> for a discussion of node IDs) which define each element in the element block. The length of this list is the product of the number of elements and the number of nodes per element as specified in the element block parameters. The node index cycles faster than the element index. <A NAME="50334051_marker-336"></A>Node ordering follows the <A NAME="50334051_marker-337"></A>conventions illustrated in <A HREF="exodusII.html#50334051_35102" CLASS="XRef">See Node Ordering for Standard Element Types</A>, which includes ordering for higher order elements. For lower order elements, simply omit the unused nodes. These node ordering conventions follow the <A NAME="50334051_marker-338"></A>element topology used in PATRAN [5]. Thus, for higher order elements than those illustrated, use the ordering prescribed in the PATRAN User Manual. For elements of type CIRCLE or SPHERE, the topology is one node at the center of the circle or sphere element. .</P>
<DIV>
<MAP NAME="exodusII.book-4">
</MAP>
<IMG SRC="exodusII.book-4.gif" USEMAP="#exodusII.book-4">
</DIV>
</DIV>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-691"></A>Element Attributes </H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-692"></A>API functions: 	<EM CLASS="code">
ex_put_elem_attr</EM>
<A NAME="50334051_marker-200"></A>, <EM CLASS="code">
ex_get_elem_attr</EM>
<A NAME="50334051_marker-201"></A>; <EM CLASS="code">
EXPEAT</EM>
<A NAME="50334051_marker-202"></A>, <EM CLASS="code">
EXGEAT</EM>
<A NAME="50334051_marker-203"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-654"></A>Element <A NAME="50334051_marker-339"></A>attributes are optional floating point numbers that can be assigned to each element. Every element in an element block must have the same number of attributes (as specified in the element block parameters) but the attributes may vary among elements within the block. The length of the attributes array is thus the product of the number of attributes per element and the number of elements in the element block. <A HREF="exodusII.html#50334051_22749" CLASS="XRef">See Element Types and Attributes</A> lists the standard attributes for the given element types. </P>
<DIV>
<MAP NAME="exodusII.book-5">
</MAP>
<IMG SRC="exodusII.book-5.gif" USEMAP="#exodusII.book-5">
</DIV>
</DIV>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-4640"></A><A NAME="50334051_25958"></A><A NAME="50334051_marker-340"></A>Node Sets</H3>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-805"></A>Node sets provide a means to reference a group of nodes with a single ID. Node sets may be used to specify load or <A NAME="50334051_marker-341"></A>boundary conditions, or to identify nodes for a special output request. A particular node may appear in any number of node sets, but may be in a single node set only once. (This restriction is not checked by EXODUS II routines.) Node sets may be accessed individually (using node set parameters, node set node list, and node set distribution factors) or in a concatenated format (described in <A HREF="exodusII.book.html#50334051_17183" CLASS="XRef">See Concatenated Node Sets</A>). The node sets data are stored identically in the data file regardless of which method (individual or concatenated) was used to output them.</P>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-694"></A>Node Set Parameters</H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-4086"></A>API functions: 	<EM CLASS="code">
ex_put_node_set_param</EM>
<A NAME="50334051_marker-204"></A>, <EM CLASS="code">
ex_get_node_set_param</EM>
<A NAME="50334051_marker-205"></A>, <EM CLASS="code">
ex_get_node_set_ids</EM>
<A NAME="50334051_marker-216"></A>; <EM CLASS="code">
EXPNP</EM>
<A NAME="50334051_marker-206"></A>, <EM CLASS="code">
EXGNP,EXGNSI</EM>
<A NAME="50334051_marker-207"></A><A NAME="50334051_marker-217"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-758"></A>The following parameters define each node set:</P>
<UL>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-816"></A><A NAME="50334051_marker-344"></A>Node set ID -- a unique integer that identifies the node set.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4575"></A>Number of nodes -- the number of nodes in the node set.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4610"></A>Number of <A NAME="50334051_marker-345"></A>distribution factors -- this should be zero if there are no distribution factors for the node set. If there are any distribution factors, this number must equal the number of nodes in the node set since the factors are assigned at each node. Refer to the discussion of distribution factors below.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-4088"></A><A NAME="50334051_marker-354"></A>Node Set Node List</H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-4621"></A>API functions: 	<EM CLASS="code">
ex_put_node_set</EM>
<A NAME="50334051_marker-208"></A>, <EM CLASS="code">
ex_get_node_set</EM>
<A NAME="50334051_marker-209"></A>; <EM CLASS="code">
EXPNS</EM>
<A NAME="50334051_marker-210"></A>, <EM CLASS="code">
EXGNS</EM>
<A NAME="50334051_marker-211"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-759"></A>This is an integer list of all the nodes in the node set. Internal node IDs (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>) must be used in this list.</P>
</DIV>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-817"></A><A NAME="50334051_marker-355"></A>Node Set Distribution Factors</H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-4622"></A>API functions: 	<EM CLASS="code">
ex_put_node_set_dist_fact</EM>
<A NAME="50334051_marker-212"></A>, <EM CLASS="code">
ex_get_node_set_dist_fact</EM>
<A NAME="50334051_marker-213"></A>; <EM CLASS="code">
EXPNSD</EM>
<A NAME="50334051_marker-214"></A>, <EM CLASS="code">
EXGNSD</EM>
<A NAME="50334051_marker-215"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-760"></A>This is an optional list of floating point factors associated with the nodes in a node set. These data may be used as multipliers on applied loads. If distribution factors are stored, each entry in this list is associated with the corresponding entry in the node set node list.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-813"></A><A NAME="50334051_17183"></A><A NAME="50334051_marker-346"></A>Concatenated Node Sets</H3>
<P CLASS="api-func">
<A NAME="50334051_pgfId-761"></A>API functions: 	<EM CLASS="code">
ex_put_concat_node_sets</EM>
<A NAME="50334051_marker-218"></A>, <EM CLASS="code">
ex_get_concat_node_sets; EXPCNS,EXGCNS</EM>
<A NAME="50334051_marker-219"></A><A NAME="50334051_marker-220"></A><A NAME="50334051_marker-221"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-762"></A>Concatenated node sets provide a means of writing/reading all node sets with one function call. This is more efficient because it avoids some I/O overhead, particularly when considering the intricacies of the netCDF library. (Refer to Appendix A for a discussion of efficiency concerns.) This is accomplished with the following lists:</P>
<UL>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-812"></A>Node sets IDs -- list (of length number of node sets) of unique integer node set ID's. The ith entry in this list specifies the ID of the ith node set.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-695"></A>Node sets node counts -- list (of length number of node sets) of counts of nodes for each node set. Thus, the ith entry in this list specifies the number of nodes in the ith node set.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-818"></A>Node sets distribution factors counts -- list (of length number of node sets) of counts of distribution factors for each node set. The ith entry in this list specifies the number of distribution factors in the ith node set.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4079"></A>Node sets node pointers -- list (of length number of node sets) of indices which are pointers into the node sets node list locating the first node of each node set. The ith entry in this list is an index in the node sets node list where the first node of the ith node set can be located.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4624"></A>Node sets distribution factors pointers --  list (of length number of node sets) of indices which are pointers into the node sets distribution factors list locating the first factor of each node set. The ith entry in this list is an index in the node sets distribution factors list where the first factor of the ith node set can be located.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-697"></A>Node sets node list -- concatenated integer list of the nodes in all the node sets. Internal node IDs (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>) must be used in this list. The node sets node pointers and node sets node counts are used to find the first node and the number of nodes in a particular node set.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-698"></A>Node sets distribution factors list -- concatenated list of the (floating point) distribution factors in all the node sets. The node sets distribution factors pointers and node sets distribution factors counts are used to find the first factor and the number of factors in a particular node set.</LI>
</UL>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-6600"></A>To clarify the use of these lists, refer to the coding examples in <A HREF="exodusII.book.html#50334051_39090" CLASS="XRef">See Write Concatenated Node Sets</A> and <A HREF="exodusII.book.html#50334051_31865" CLASS="XRef">See Read Concatenated Node Sets</A>.</P>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-700"></A><A NAME="50334051_36506"></A><A NAME="50334051_marker-347"></A>Side Sets</H3>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-4407"></A>Side sets provide a second means of applying load and <A NAME="50334051_marker-348"></A>boundary conditions to a model. Unlike node sets, side sets are related to specified sides of elements rather than simply a list of nodes. For example, a pressure load must be associated with an element edge (in 2-d) or face (in 3-d) in order to apply it properly. Each side in a side set is defined by an element number and a local edge (for 2-d elements) or face (for 3-d elements) number. The local number of the edge or face of interest must conform to the conventions as illustrated in <A HREF="exodusII.html#50334051_16639" CLASS="XRef">See Side Set Side Numbering</A>.  In this figure, side set side numbers are enclosed in boxes; only the essential node numbers to describe the element topology are shown. A side set may contain sides of differing types of elements that are contained in different element blocks. For instance, a single side set may contain faces of WEDGE elements, HEX elements, and TETRA elements.</P>
<DIV>
<MAP NAME="exodusII.book-6">
</MAP>
<IMG SRC="exodusII.book-6.gif" USEMAP="#exodusII.book-6">
</DIV>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-814"></A><A NAME="50334051_marker-384"></A>Side Set Parameters</H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-4625"></A>API functions: 	<EM CLASS="code">
ex_put_side_set_param</EM>
<A NAME="50334051_marker-222"></A>, <EM CLASS="code">
ex_get_side_set_param</EM>
<A NAME="50334051_marker-223"></A>, <EM CLASS="code">
ex_get_side_set_ids</EM>
<A NAME="50334051_marker-240"></A>; <EM CLASS="code">
EXPSP</EM>
<A NAME="50334051_marker-224"></A>, <EM CLASS="code">
EXGSP</EM>
<A NAME="50334051_marker-225"></A>, <EM CLASS="code">
EXGSSI</EM>
<A NAME="50334051_marker-241"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-763"></A>The following parameters define each side set:</P>
<UL>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4626"></A><A NAME="50334051_marker-349"></A>Side set ID -- a unique integer that identifies the side set.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4627"></A>Number of sides -- the number of sides in the side set.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4628"></A>Number of <A NAME="50334051_marker-350"></A>distribution factors -- this should be zero if there are no distribution factors for the side set. If there are any distribution factors, they are assigned at the nodes on the sides of the side set. Refer to the discussion of distribution factors below.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-4629"></A><A NAME="50334051_marker-351"></A>Side Set Element List</H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-8977"></A>API functions: 	<EM CLASS="code">
ex_put_side_set</EM>
<A NAME="50334051_marker-8973"></A>, <EM CLASS="code">
ex_get_side_set</EM>
<A NAME="50334051_marker-8974"></A>; <EM CLASS="code">
EXPSS</EM>
<A NAME="50334051_marker-8975"></A>, <EM CLASS="code">
EXGSS</EM>
<A NAME="50334051_marker-8976"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-8978"></A>This is an integer list of all the elements in the side set. Internal element IDs (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>) must be used in this list.</P>
</DIV>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-8980"></A><A NAME="50334051_marker-8979"></A>Side Set Side List</H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-766"></A>API functions: 	<EM CLASS="code">
ex_put_side_set</EM>
<A NAME="50334051_marker-230"></A>, <EM CLASS="code">
ex_get_side_set</EM>
<A NAME="50334051_marker-231"></A>; <EM CLASS="code">
EXPSS</EM>
<A NAME="50334051_marker-232"></A>, <EM CLASS="code">
EXGSS</EM>
<A NAME="50334051_marker-233"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-765"></A>This is an integer list of all the sides in the side set. This list contains the local edge (for 2-d elements) or face (for 3-d elements) numbers following the conventions specified in <A HREF="exodusII.html#50334051_16639" CLASS="XRef">See Side Set Side Numbering</A>.</P>
</DIV>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-4631"></A><A NAME="50334051_marker-353"></A>Side Set Node List</H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-4637"></A>API functions: 	<EM CLASS="code">
ex_get_side_set_node_list</EM>
<A NAME="50334051_marker-234"></A>; <EM CLASS="code">
EXGSSN</EM>
<A NAME="50334051_marker-235"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-767"></A>It is important to note that the nodes on a side set are not explicitly stored in the data file, but can be extracted from the element numbers in the side set element list, local side numbers in the side set side list, and the element connectivity array. The node IDs that are output are internal node numbers (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>). They are extracted according to the following conventions:</P>
<OL>
<LI CLASS="number1">
<A NAME="50334051_pgfId-699"></A>All nodes for the first side (defined by the first element in the side set element list and the first side in the side set side list) are output before the nodes for the second side. There is no attempt to consolidate nodes; if a node is attached to four different faces, then the same node number will be output four times -- once each time the node is encountered when progressing along the side list.</LI>
<LI CLASS="number">
<A NAME="50334051_pgfId-4635"></A>The nodes for a single face (or edge) are ordered to assist an application code in determining an &quot;outward&quot; direction. Thus, the node list for a face of a 3-d element proceeds around the face so that the outward normal follows the right-hand rule. The node list for an edge of a 2-d element proceeds such that if the right hand is placed in the plane of the element palm down, thumb extended with the index (and other fingers) pointing from one node to the next in the list, the thumb points to the inside of the element. This node ordering is detailed in <A HREF="exodusII.html#50334051_10813" CLASS="XRef">See Side Set Node Ordering</A>.</LI>
<LI CLASS="number">
<A NAME="50334051_pgfId-2235"></A>The nodes required for a first-order element are output first, followed by the nodes of a higher ordered element. Again, this is illustrated in <A HREF="exodusII.html#50334051_10813" CLASS="XRef">See Side Set Node Ordering</A> </LI>
</OL>
<DIV>
<IMG SRC="exodusII.book-7.gif">
</DIV>
</DIV>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-4905"></A><A NAME="50334051_marker-356"></A>Side Set Node Count List</H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-4906"></A>API functions: 	<EM CLASS="code">
ex_get_side_set_node_list</EM>
<A NAME="50334051_marker-299"></A>; <EM CLASS="code">
EXGSSN</EM>
<A NAME="50334051_marker-300"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-4904"></A>The length of the side set node count list is the length of the side set element list. For each entry in the side set element list, there is an entry in the side set side list, designating a local side number. The corresponding entry in the side set node count list is the number of nodes which define the particular side. In conjunction with the side set node list, this node count array provides an unambiguous nodal description of the side set.</P>
</DIV>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-4636"></A><A NAME="50334051_marker-357"></A>Side Set Distribution Factors</H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-4632"></A>API functions: 	<EM CLASS="code">
ex_put_side_set_dist_fact</EM>
<A NAME="50334051_marker-236"></A>, <EM CLASS="code">
ex_get_side_set_dist_fact</EM>
<A NAME="50334051_marker-237"></A>; <EM CLASS="code">
EXPSSD</EM>
<A NAME="50334051_marker-238"></A>, <EM CLASS="code">
EXGSSD</EM>
<A NAME="50334051_marker-239"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-768"></A>This is an optional list of floating point factors associated with the nodes on a side set. These data may be used for uneven application of load or boundary conditions. Because distribution factors are assigned at the nodes, application codes that utilize these factors must read the side set node list. The distribution factors must be stored/accessed in the same order as the nodes in the side set node list; thus, the ordering conventions described above apply.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-815"></A><A NAME="50334051_26621"></A><A NAME="50334051_marker-359"></A>Concatenated Side Sets</H3>
<P CLASS="api-func">
<A NAME="50334051_pgfId-4712"></A>API functions: 	<EM CLASS="code">
ex_put_concat_side_sets</EM>
<A NAME="50334051_marker-242"></A>, <EM CLASS="code">
ex_get_concat_side_sets</EM>
<A NAME="50334051_marker-243"></A>; <EM CLASS="code">
EXPCSS</EM>
<A NAME="50334051_marker-244"></A>, <EM CLASS="code">
EXGCSS</EM>
<A NAME="50334051_marker-245"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-769"></A>Concatenated side sets provide a means of writing / reading all side sets with one function call. This is more efficient because it avoids some I/O overhead, particularly when considering the intricacies of the <A NAME="50334051_marker-360"></A>netCDF library. This is accomplished with the following lists:</P>
<UL>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4713"></A>Side sets IDs -- list (of length number of side sets) of unique integer side set ID's. The ith entry in this list specifies the ID of the ith side set.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4720"></A>Side sets side counts --  list (of length number of side sets) of counts of sides for each side set. Thus, the ith entry in this list specifies the number of sides in the ith node set. This also defines the number of elements in each side set.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4714"></A>Side sets distribution factors counts -- list (of length number of side sets) of counts of distribution factors for each side set. The ith entry in this list specifies the number of distribution factors in the ith side set.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4715"></A>Side sets side pointers -- list (of length number of side sets) of indices which are pointers into the side sets element list (and side list) locating the first element (or side) of each side set. The ith entry in this list is an index in the side sets element list (and side list) where the first element (or side) of the ith side set can be located.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4721"></A>Side sets distribution factors pointers -- list (of length number of side sets) of indices which are pointers into the side sets distribution factors list locating the first factor of each side set. The ith entry in this list is an index in the side sets distribution factors list where the first factor of the ith side set can be located.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4716"></A>Side sets element list -- concatenated integer list of the elements in all the side sets. Internal element IDs (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>) must be used in this list. The side sets side pointers and side sets side counts are used to find the first element and the number of elements in a particular side set.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4722"></A>Side sets side list -- concatenated integer list of the sides in all the side sets. The side sets side pointers and side sets side counts are used to find the first side and the number of sides in a particular side set.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-4717"></A>Side sets distribution factors list -- concatenated list of the (floating point) distribution factors in all the side sets. The side sets distribution factors pointers and side sets distribution factors counts are used to find the first factor and the number of factors in a particular side set.</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-709"></A><A NAME="50334051_marker-361"></A>Object Properties</H3>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-770"></A>Certain EXODUS II objects (currently element blocks, node sets, and side sets) can be given integer properties, providing the following capabilitities:</P>
<OL>
<LI CLASS="number1">
<A NAME="50334051_pgfId-655"></A>assign a specific integer value to a named property of an object.</LI>
<LI CLASS="number">
<A NAME="50334051_pgfId-701"></A>tag objects as members of a group. For example element blocks 1 and 3 and side sets 1 and 2 could be put in a group named &quot;TOP.&quot;</LI>
</OL>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-702"></A>This functionality is illustrated in <A HREF="exodusII.html#50334051_25874" CLASS="XRef">See Sample Property Table</A> which contains the property values of a sample EXODUS II file with three element blocks, one node set, and two side sets. Note that an application code can define properties to be valid for only specified object types. In this example, &quot;STEEL&quot; and &quot;COPPER&quot; are valid for all element blocks but are not defined for node sets and side sets. </P>
<DIV>
<IMG SRC="exodusII.book-8.gif">
</DIV>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-4680"></A>Interpretation of the integer values of the properties is left to the application codes, but in general, a nonzero positive value means the object has the named property (or is in the named group); a zero means the object does not have the named property (or is not in the named group). Thus, element block 1 has an ID of 10 (1 is a counter internal to the data base; an application code accesses the element block using the ID), node set 1 has an ID of 100, etc. The group &quot;TOP&quot; includes element block 1, element block 3, and side sets 1 and 2.</P>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-4766"></A>Property Parameters</H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-710"></A>API functions: 	<EM CLASS="code">
ex_put_prop_names</EM>
<A NAME="50334051_marker-246"></A>, <EM CLASS="code">
ex_get_prop_names</EM>
<A NAME="50334051_marker-247"></A>; <EM CLASS="code">
EXPPN</EM>
<A NAME="50334051_marker-252"></A>, <EM CLASS="code">
EXGPN</EM>
<A NAME="50334051_marker-253"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-4769"></A>The parameters include the number of properties and the names of length <EM CLASS="code">
MAX_STR_LENGTH</EM>
 (<EM CLASS="code">
MXSTLN</EM>
 in Fortran) for each property for each object type (i.e., element blocks, node sets, or side sets). In the preceding example, there are five properties for element blocks (i.e., &quot;ID&quot;, &quot;TOP&quot;, &quot;LEFT&quot;, &quot;STEEL&quot;, and &quot;COPPER&quot;), three properties for node sets (i.e., &quot;ID&quot;, &quot;TOP&quot;, and &quot;LEFT&quot;), and three properties for side sets (i.e., &quot;ID&quot;, &quot;TOP&quot;, and &quot;LEFT&quot;).</P>
</DIV>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-4767"></A><A NAME="50334051_marker-362"></A>Property Values</H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-4768"></A>API functions:	<EM CLASS="code">
ex_put_prop</EM>
<A NAME="50334051_marker-261"></A>, <EM CLASS="code">
ex_get_prop</EM>
<A NAME="50334051_marker-262"></A>, <EM CLASS="code">
ex_put_prop_array</EM>
<A NAME="50334051_marker-263"></A>, <EM CLASS="code">
ex_get_prop_array</EM>
<A NAME="50334051_marker-264"></A>; <EM CLASS="code">
EXPP</EM>
<A NAME="50334051_marker-267"></A>, <EM CLASS="code">
EXGP</EM>
<A NAME="50334051_marker-268"></A>, <EM CLASS="code">
EXPPA</EM>
<A NAME="50334051_marker-269"></A>, <EM CLASS="code">
EXGPA</EM>
<A NAME="50334051_marker-270"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-4770"></A>Valid values for the properties are positive integers and zero. Property values are stored in arrays in the data file but can be written / read individually given an object type (i.e., element block, node set, or side set), object ID, and property name or as an array given an object type and property name. If accessed as an array, the order of the values in the array must correspond to the order in which the element blocks, node sets, or side sets were introduced into the file. For instance, if the parameters for element block with ID 20 were written to a file, and then parameters for element block with ID 10, followed by the parameters for element block with ID 30, the first, second, and third elements in the property array would correspond to element block 20, element block 10, and element block 30, respectively. This order can be determined with a call to <EM CLASS="code">
ex_get_elem_blk_ids</EM>
 (<EM CLASS="code">
EXGEBI</EM>
 for Fortran) which returns an array of element block IDs in the order that the corresponding element blocks were introduced to the data file.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-711"></A>Results Parameters </H3>
<P CLASS="api-func">
<A NAME="50334051_pgfId-4719"></A>API functions: 	<EM CLASS="code">
ex_put_var_param</EM>
<A NAME="50334051_marker-248"></A>, <EM CLASS="code">
ex_get_var_param</EM>
<A NAME="50334051_marker-249"></A>; <EM CLASS="code">
EXPVP</EM>
<A NAME="50334051_marker-250"></A>, <EM CLASS="code">
EXGVP</EM>
<A NAME="50334051_marker-251"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-4771"></A>The number of each type of results variables (element, nodal, and global) is specified only once, and cannot change through time.</P>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-712"></A><A NAME="50334051_marker-363"></A>Results Names </H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-713"></A>API functions: 	<EM CLASS="code">
ex_put_var_names</EM>
<A NAME="50334051_marker-254"></A>, <EM CLASS="code">
ex_get_var_names</EM>
<A NAME="50334051_marker-255"></A>; <EM CLASS="code">
EXPVAN</EM>
<A NAME="50334051_marker-256"></A>, <EM CLASS="code">
EXGVAN</EM>
<A NAME="50334051_marker-257"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-4772"></A>Associated with each results variable is a unique name of length <EM CLASS="code">
MAX_STR_LENGTH</EM>
 (<EM CLASS="code">
MXSTLN</EM>
 in Fortran).</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-716"></A><A NAME="50334051_marker-366"></A>Results Data</H3>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-4724"></A>An integer output <A NAME="50334051_marker-367"></A>time step number (beginning with 1) is used as an index into the results variables written to or read from an EXODUS II file. It is a counter of the number of &quot;data planes&quot; that have been written to the file. The maximum time step number (i.e., the number of time steps that have been written) is available via a call to the database inquire function (<A HREF="exodusII.book.html#50334051_23612" CLASS="XRef">See Inquire EXODUS Parameters</A>). For each output time step, the following information is stored.</P>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-717"></A><A NAME="50334051_marker-368"></A>Time Values</H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-4725"></A>API functions:	<A NAME="50334051_marker-271"></A><EM CLASS="code">
ex_put_time</EM>
, <EM CLASS="code">
ex_get_time</EM>
<A NAME="50334051_marker-272"></A>, <EM CLASS="code">
ex_get_all_times</EM>
<A NAME="50334051_marker-273"></A>; <EM CLASS="code">
EXPTIM</EM>
<A NAME="50334051_marker-274"></A>, <EM CLASS="code">
EXGTIM</EM>
<A NAME="50334051_marker-10047"></A>, <EM CLASS="code">
EXGATM</EM>
<A NAME="50334051_marker-275"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-4774"></A>A floating point value must be stored for each time step to identify the &quot;data plane.&quot; Typically, this is the analysis time but can be any floating point variable that distinguishes the time steps. For instance, for a modal analysis, the natural frequency for each mode may be stored as a &quot;time value&quot; to discriminate the different sets of eigen vectors. The only restriction on the time values is that they must monotonically increase. </P>
</DIV>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-718"></A><A NAME="50334051_marker-369"></A>Global Results </H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-4775"></A>API functions:	<EM CLASS="code">
ex_put_glob_vars</EM>
<A NAME="50334051_marker-276"></A>, <EM CLASS="code">
ex_get_glob_vars</EM>
<A NAME="50334051_marker-277"></A>, <EM CLASS="code">
ex_get_glob_var_time</EM>
<A NAME="50334051_marker-278"></A>; <EM CLASS="code">
EXPGV</EM>
<A NAME="50334051_marker-279"></A>, <EM CLASS="code">
EXGGV</EM>
<A NAME="50334051_marker-280"></A>, <EM CLASS="code">
EXGGVT</EM>
<A NAME="50334051_marker-281"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-4726"></A>This object contains the floating point global data for the time step. The length of the array is the number of global variables, as specified in the results parameters.</P>
</DIV>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-719"></A><A NAME="50334051_marker-370"></A>Nodal Results </H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-4776"></A>API functions:	<EM CLASS="code">
ex_put_nodal_var</EM>
<A NAME="50334051_marker-282"></A>, <EM CLASS="code">
ex_get_nodal_var</EM>
<A NAME="50334051_marker-283"></A>, <EM CLASS="code">
ex_get_nodal_var_time</EM>
<A NAME="50334051_marker-284"></A>; <EM CLASS="code">
EXPNV</EM>
<A NAME="50334051_marker-285"></A>, <EM CLASS="code">
EXGNV</EM>
<A NAME="50334051_marker-286"></A>, <EM CLASS="code">
EXGNVT</EM>
<A NAME="50334051_marker-287"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-4727"></A>This object contains the floating point nodal data for the time step. The size of the array is the number of nodes, as specified in the global parameters, times the number of nodal variables.</P>
</DIV>
<DIV>
<H5 CLASS="FM3Heading">
<A NAME="50334051_pgfId-720"></A><A NAME="50334051_marker-371"></A>Element Results </H5>
<P CLASS="api-func">
<A NAME="50334051_pgfId-4777"></A>API functions:	<EM CLASS="code">
ex_put_elem_var</EM>
<A NAME="50334051_marker-288"></A>, <EM CLASS="code">
ex_get_elem_var</EM>
<A NAME="50334051_marker-289"></A>, <EM CLASS="code">
ex_get_elem_var_time</EM>
<A NAME="50334051_marker-290"></A>; <EM CLASS="code">
EXPEV</EM>
<A NAME="50334051_marker-291"></A>, <EM CLASS="code">
EXGEV</EM>
<A NAME="50334051_marker-292"></A>, <EM CLASS="code">
EXGEVT</EM>
<A NAME="50334051_marker-293"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-4728"></A>Element variables are output for a given element block and a given element variable. Thus, at each time step, up to m element variable objects (where m is the product of the number of element blocks and the number of element variables) may be stored. However, since not all element variables must be output for all element blocks (see <A HREF="exodusII.book.html#50334051_16440" CLASS="XRef">See Element Variable Truth Table</A> below), m is the maximum number of element variable objects. The actual number of objects stored is the number of unique combinations of element variable index and element block ID passed to <EM CLASS="code">
ex_put_elem_var</EM>
 (<EM CLASS="code">
EXPEV</EM>
 for Fortran) or the number of non-zero entries in the <A NAME="50334051_marker-372"></A>element variable truth table (if it is used). The length of each object is the number of elements in the given element block.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-6691"></A><A NAME="50334051_16440"></A><A NAME="50334051_marker-6690"></A>Element Variable Truth Table </H3>
<P CLASS="api-func">
<A NAME="50334051_pgfId-6695"></A>API functions: <EM CLASS="code">
	ex_put_elem_var_tab</EM>
<A NAME="50334051_marker-6692"></A>, <EM CLASS="code">
ex_get_elem_var_tab</EM>
<A NAME="50334051_marker-6693"></A>; <EM CLASS="code">
EXPVTT</EM>
<A NAME="50334051_marker-6694"></A>, <EM CLASS="code">
EXGVTT</EM>
<A NAME="50334051_marker-6696"></A></P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-6697"></A>Because some element variables are not applicable (and thus not computed by a simulation code) for all element types, the element variable truth table is an optional mechanism for specifying whether a particular element result is output for the elements in a particular element block. For example, hydrostatic stress may be an output result for the elements in element block 3, but not those in element block 6.</P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-6703"></A>It is helpful to describe the <A NAME="50334051_marker-6699"></A>truth table as a two dimensional array, as shown in <A HREF="exodusII.html#50334051_41789" CLASS="XRef">See Element Variable Truth Table</A> Each row of the array is associated with an element variable; each column of the array is associated with an element block. If a datum in the truth table is zero (<EM CLASS="code">
table(i,j)=0</EM>
), then no results are output for the <EM CLASS="code">
i</EM>
th element variable for the <EM CLASS="code">
j</EM>
th element block. A nonzero entry indicates that the appropriate result will be output. In this example, element variable 1 will be stored for all element blocks; element variable 2 will be stored for element blocks 1 and 4; and element variable 3 will be stored for element blocks 3 and 4. The table is stored such that the variable index cycles faster than the block index.</P>
<DIV>
<IMG SRC="exodusII.book-9.gif">
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="FM1Heading">
<A NAME="50334051_pgfId-775"></A><A NAME="50334051_33195"></A>Application Programming Interface (API)</H2>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-615"></A>EXODUS II files can be written and read by application codes written in C, C++, or Fortran via calls to functions in the application programming interface (API). Functions within the API are categorized as data file utilities, model description functions, or results data functions. </P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-7010"></A>In general, the following pattern is followed for writing data objects to a file:</P>
<OL>
<LI CLASS="number1">
<A NAME="50334051_pgfId-620"></A>create the file with <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran);</LI>
<LI CLASS="number">
<A NAME="50334051_pgfId-622"></A>write out global parameters to the file using <EM CLASS="code">
ex_put_init</EM>
 (or <EM CLASS="code">
EXPINI</EM>
 for Fortran);</LI>
<LI CLASS="number">
<A NAME="50334051_pgfId-623"></A>write out specific data object parameters; for example, put out element block parameters with <EM CLASS="code">
ex_put_elem_block</EM>
 (or <EM CLASS="code">
EXPELB</EM>
 for Fortran);</LI>
<LI CLASS="number">
<A NAME="50334051_pgfId-624"></A>write out the data object; for example, put out the connectivity for an element block with <EM CLASS="code">
ex_put_elem_conn</EM>
 (or <EM CLASS="code">
EXPELC</EM>
 for Fortran);</LI>
<LI CLASS="number">
<A NAME="50334051_pgfId-625"></A>close the file with <EM CLASS="code">
ex_close</EM>
 (or <EM CLASS="code">
EXCLOS</EM>
 for Fortran).</LI>
</OL>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-621"></A>Steps 3 and 4 are repeated within this pattern for each data object (i.e., nodal coordinates, element blocks, node sets, side sets, results variables, etc.). For some data object types, steps 3 and 4 are combined in a single call. For instance, <EM CLASS="code">
ex_put_qa</EM>
 (or <EM CLASS="code">
EXPQA</EM>
 for Fortran) writes out the parameters (number of QA records) as well as the data object itself (the QA records). During the database writing process, there are a few order dependencies (e.g., an element block must be written before element variables for that element block are written) which are documented in the description of each library function.</P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-626"></A>The invocation of the EXODUS II API functions for reading data is order independent, providing random read access. The following steps are typically used for reading data:</P>
<OL>
<LI CLASS="number1">
<A NAME="50334051_pgfId-627"></A>open the file with <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran);</LI>
<LI CLASS="number">
<A NAME="50334051_pgfId-628"></A>read the global parameters for dimensioning purposes with <EM CLASS="code">
ex_get_init</EM>
 (or <EM CLASS="code">
EXGINI</EM>
 for Fortran);</LI>
<LI CLASS="number">
<A NAME="50334051_pgfId-629"></A>read specific data object parameters; for example, read node set parameters with <EM CLASS="code">
ex_get_node_set_param</EM>
 (or <EM CLASS="code">
EXGNSP</EM>
 for Fortran);</LI>
<LI CLASS="number">
<A NAME="50334051_pgfId-630"></A>read the data object; for example, read the node set node list with <EM CLASS="code">
ex_get_node_set</EM>
 (or <EM CLASS="code">
EXGNS</EM>
 for Fortran);</LI>
<LI CLASS="number">
<A NAME="50334051_pgfId-631"></A>close the file with <EM CLASS="code">
ex_close</EM>
 (or <EM CLASS="code">
EXCLOS</EM>
 for Fortran).</LI>
</OL>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-632"></A>Again, steps 3 and 4 are repeated for each object. For some object parameters, step 3 may be accomplished with a call to <EM CLASS="code">
ex_inquire</EM>
 (or <EM CLASS="code">
EXINQ</EM>
 for Fortran) to inquire the size of certain objects.</P>
<P CLASS="Body-txt">
<A NAME="50334051_pgfId-6080"></A>In developing applications using the EXODUS II API, the following points may prove beneficial:</P>
<UL>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-742"></A>All functions that write objects to the database begin with <EM CLASS="code">
ex_put_</EM>
 (<EM CLASS="code">
EXP</EM>
 for Fortran); functions that read objects from the database begin with <EM CLASS="code">
ex_get_</EM>
 (<EM CLASS="code">
EXG</EM>
 for Fortran). </LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-8323"></A>Function arguments are classified as readable (R), writable (W), or both (RW). Readable arguments are not modified by the API routines; writable arguments are modified; read-write arguments may be either depending on the value of the argument.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-8332"></A>All application codes which use the EXODUS II API must include the file `exodusII.h' for C or `exodusII.inc' for Fortran. These files define constants that are used (1) as arguments to the API routines, (2) to set global parameters such as maximum string length and database version, and (3) as error condition or function return values.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-8338"></A>Throughout this section, sample code segments have been included to aid the application developer in using the API routines. These segments are not complete and there has been no attempt to include all calling sequence dependencies within them. Additionally, most arrays in the Fortran coding examples are shown dimensioned to some maximum value (i.e., <EM CLASS="code">
MAXQA</EM>
, <EM CLASS="code">
MAXINF</EM>
, <EM CLASS="code">
MAXNOD</EM>
, etc.). These values are not predefined constants so the library routines cannot check actual numbers of records against them. They are shown in this document simply to give an indication of how to statically dimension the arrays if necessary. </LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-8341"></A>Because 2-dimensional arrays cannot be statically dimensioned, either dynamic dimensioning or user indexing is required. Most of the sample code segments utilize user indexing within 1-dimensional arrays even though the variables are logically 2-dimensional.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-8322"></A>There are many <A NAME="50334051_marker-610"></A>netCDF utilities that prove useful. <EM CLASS="code">
ncdump</EM>
<A NAME="50334051_marker-611"></A>, which <A NAME="50334051_marker-613"></A>converts a binary netCDF file to a readable <A NAME="50334051_marker-612"></A>ASCII file, is the most notable.</LI>
<LI CLASS="bullet">
<A NAME="50334051_pgfId-741"></A>Because netCDF buffers I/O, it is important to <A NAME="50334051_marker-614"></A>flush all buffers (with <A NAME="50334051_marker-609"></A><EM CLASS="code">
ex_update</EM>
 in C or <A NAME="50334051_marker-608"></A><EM CLASS="code">
EXUPDA</EM>
 in Fortran) when debugging an application that produces an EXODUS II file.</LI>
</UL>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-4778"></A>Data File Utilities</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-2114"></A>This section describes data file utility functions for creating / opening a file, initializing a file with global parameters, reading / writing information text, inquiring on parameters stored in the data file, and error reporting . </P>
</DIV>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-819"></A><A NAME="50334051_21931"></A>Create EXODUS II File</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-820"></A>The function <EM CLASS="code">
ex_create</EM>
 or (<EM CLASS="code">
EXCRE</EM>
 for Fortran) creates a new EXODUS II file and returns an ID that can subsequently be used to refer to the file.  </P>
<P CLASS="Body">
<A NAME="50334051_pgfId-821"></A>All floating point values in an EXODUS II file are stored as either 4-byte (&quot;float&quot; in C; &quot;REAL*4&quot; in FORTRAN) or 8-byte (&quot;double&quot; in C; &quot;REAL*8&quot; or &quot;DOUBLE PRECISION&quot; in FORTRAN) numbers; no mixing of 4- and 8-byte numbers in a single file is allowed. An application code can compute either 4- or 8-byte values and can designate that the values be stored in the EXODUS II file as either 4- or 8-byte numbers; conversion between the 4- and 8-byte values is performed automatically by the API routines. Thus, there are four possible combinations of compute word size and storage (or I/O) word size.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-822"></A>In case of an error, <EM CLASS="code">
ex_create</EM>
 returns a negative number; <EM CLASS="code">
EXCRE</EM>
 returns a nonzero error number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-823"></A>Passing a file name that includes a directory that does not exist.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-824"></A>Specifying a file name of a file that exists and also specifying a no clobber option.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-825"></A>Attempting to create a file in a directory without permission to create files there.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2918"></A>Passing an invalid file clobber mode.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-826"></A>ex_create:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-827"></A><EM CLASS="code">
	int ex_create (path, cmode, comp_ws, io_ws);</EM>
<A NAME="50334051_marker-21"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-828"></A><EM CLASS="code">
char* path (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2237"></A>The file name of the new EXODUS II file.  This can be given as either an absolute path name (from the root of the file system) or a relative path name (from the current directory).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-829"></A><EM CLASS="code">
int cmode (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2238"></A><A NAME="50334051_marker-373"></A>Clobber mode.  Use one of the following predefined constants:</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-1605"></A><EM CLASS="code">
EX_NOCLOBBER</EM>
 	To create the new file only if the given file name does not refer to a file that already exists.  </P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2197"></A><EM CLASS="code">
EX_CLOBBER</EM>
 	To create the new file, regardless of whether a file with the same name already exists.  If a file with the same name does exist, its contents will be erased.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-830"></A><EM CLASS="code">
int* comp_ws (RW)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2239"></A>The <A NAME="50334051_marker-374"></A>word size in bytes (0, 4 or 8) of the floating point variables used in the application program. If 0 (zero) is passed, the default <EM CLASS="code">
sizeof(float)</EM>
 will be used and returned in this variable. WARNING: all EXODUS II functions requiring floats must be passed floats declared with this passed in or returned compute word size (4 or 8).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-831"></A><EM CLASS="code">
int* io_ws (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2240"></A>The <A NAME="50334051_marker-375"></A>word size in bytes (4 or 8) of the floating point data as they are to be stored in the EXODUS II file.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3028"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-9604"></A>The following code segment creates an EXODUS II file called <EM CLASS="code">
test.exo</EM>
:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3041"></A><EM CLASS="code">
#include&quot;exodusII.h&quot;</EM>
</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3043"></A>int CPU_word_size, IO_word_size, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3031"></A><EM CLASS="code">
CPU_word_size = sizeof(float);				/* use float or double */</EM>
</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3032"></A><EM CLASS="code">
IO_word_size = 8;			 	/* store variables as doubles */</EM>
</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3034"></A><EM CLASS="code">
/* create EXODUS II file */</EM>
</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3036"></A><EM CLASS="code">
exoid = ex_create (&quot;test.exo&quot;,			 	/* filename path */</EM>
</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3037"></A><EM CLASS="code">
		EX_CLOBBER,	 	/* create mode */</EM>
</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3038"></A><EM CLASS="code">
		&amp;CPU_word_size,	 	/* CPU float word size in bytes */</EM>
</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3039"></A><EM CLASS="code">
		&amp;IO_word_size);	 	/* I/O float word size in bytes */</EM>
</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-832"></A>EXCRE:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-833"></A><EM CLASS="code">
	INTEGER FUNCTION EXCRE (PATH, ICMODE, ICOMPWS, IOWS, IERR)</EM>
<A NAME="50334051_marker-22"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-834"></A><EM CLASS="code">
CHARACTER*(*) PATH (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-835"></A>The file name of the new EXODUS II file.  This can be given as either an absolute path name (from the root of the file system) or a relative path name (from the current directory).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-836"></A><EM CLASS="code">
INTEGER ICMODE (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2241"></A><A NAME="50334051_marker-376"></A>Clobber mode.  Use one of the following predefined constants: </P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2854"></A><EM CLASS="code">
EXNOCL</EM>
 	To create the new file only if the given file name does not refer to a file that already exists. </P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2855"></A><EM CLASS="code">
EXCLOB</EM>
 	To create the new file, regardless of whether a file with the same name already exists.  If a file with the same name does exist, its contents will be erased.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-837"></A><EM CLASS="code">
INTEGER ICOMPWS (RW)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2242"></A>The <A NAME="50334051_marker-377"></A>word size in bytes (0, 4 or 8) of the floating point (REAL) variables used in the application program. If 0 (zero) is passed, the default size of floating point values for the machine will be used and returned in this variable. WARNING: all EXODUS II functions requiring reals must be passed reals declared with this passed in or returned compute word size (4 or 8).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-838"></A><EM CLASS="code">
INTEGER IOWS (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2243"></A>The <A NAME="50334051_marker-378"></A>word size in bytes (4 or 8) of the floating point (REAL) data as they are to be stored in the EXODUS II file.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-839"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2244"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3915"></A>The following code segment creates an EXODUS II file called <EM CLASS="code">
test.exo</EM>
, specifying default values for compute and I/O word sizes:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3914"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3923"></A>	 integer cpu_ws, io_ws</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3916"></A>c create EXODUS II files;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3917"></A>c REAL variables are default reals; store in file as DOUBLE PRECISION</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3918"></A>	 cpu_ws = 0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3919"></A>	 io_ws = 8</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3920"></A>	 idexo = excre (`test.exo', EXCLOB, cpu_ws, io_ws, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-840"></A><A NAME="50334051_marker-379"></A><A NAME="50334051_14859"></A>Open EXODUS II File</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-841"></A>The function <EM CLASS="code">
ex_open</EM>
 or (<EM CLASS="code">
EXOPEN</EM>
 for Fortran) opens an existing EXODUS II file and returns an ID that can subsequently be used to refer to the file, the word size of the floating point values stored in the file, and the version of the EXODUS II database (returned as a &quot;float&quot; in C or &quot;REAL&quot; in Fortran, regardless of the compute or I/O word size).  Multiple files may be &quot;open&quot; simultaneously.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-842"></A>In case of an error, <EM CLASS="code">
ex_open</EM>
 returns a negative number; <EM CLASS="code">
EXOPEN</EM>
 returns a nonzero error number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-843"></A>The specified file does not exist.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-844"></A>The mode specified is something other than the predefined constant <EM CLASS="code">
EX_READ</EM>
 (<EM CLASS="code">
EXREAD</EM>
 for Fortran) or <EM CLASS="code">
EX_WRITE</EM>
 (<EM CLASS="code">
EXWRIT</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2919"></A>Database version is earlier than 2.0.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-845"></A>ex_open:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-846"></A><EM CLASS="code">
	int ex_open (path, mode, comp_ws, io_ws, version);</EM>
<A NAME="50334051_marker-23"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-847"></A><EM CLASS="code">
char* path (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2188"></A>The file name of the EXODUS II file.  This can be given as either an absolute path name (from the root of the file system) or a relative path name (from the current directory).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-848"></A><EM CLASS="code">
int mode (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2257"></A><A NAME="50334051_marker-507"></A>Access mode.  Use one of the following predefined constants:</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2852"></A><EM CLASS="code">
EX_READ</EM>
 	To open the file just for reading. </P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2853"></A><EM CLASS="code">
EX_WRITE</EM>
 	To open the file for writing and reading.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-849"></A><EM CLASS="code">
int* comp_ws (RW)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2258"></A>The <A NAME="50334051_marker-381"></A>word size in bytes (0, 4 or 8) of the floating point variables used in the application program. If 0 (zero) is passed, the default size of floating point values for the machine will be used and returned in this variable. WARNING: all EXODUS II functions requiring reals must be passed reals declared with this passed in or returned compute word size (4 or 8).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-850"></A><EM CLASS="code">
int* io_ws (RW)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2259"></A>The <A NAME="50334051_marker-382"></A>word size in bytes (0, 4 or 8) of the floating point data as they are stored in the EXODUS II file. If the word size does not match the word size of data stored in the file, a fatal error is returned. If this argument is 0, the word size of the floating point data already stored in the file is returned.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-851"></A><EM CLASS="code">
float* version (W)</EM>
<A NAME="50334051_marker-383"></A></P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2260"></A>Returned EXODUS II database version number.  The current version is 2.02</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-852"></A>The following opens an EXODUS II file named <EM CLASS="code">
test.exo</EM>
 for read only, using default settings for compute and I/O word sizes: </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3045"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3046"></A>int CPU_word_size,IO_word_size, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3057"></A>float version;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3048"></A>CPU_word_size = sizeof(float);			 	/* float or double */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3047"></A>IO_word_size = 0;		 		/* use what is stored in file */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3049"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3050"></A>/* open EXODUS II files */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3052"></A>exoid = ex_open (&quot;test.exo&quot;,				/* filename path */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3053"></A>		EX_READ,	 	/* access mode = READ */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3054"></A>		&amp;CPU_word_size, 		/* CPU word size */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3055"></A>		&amp;IO_word_size,	 	/* IO word size */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3056"></A>		&amp;version);		/* ExodusII library version */</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-3044"></A>EXOPEN:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-853"></A><EM CLASS="code">
	INTEGER FUNCTION EXOPEN (PATH, IMODE, ICOMPWS, IOWS, VERS, IERR)</EM>
<A NAME="50334051_marker-24"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-854"></A><EM CLASS="code">
CHARACTER*(*) PATH (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-855"></A>The file name of the  EXODUS II file.  This can be given as either an absolute path name (from the root of the file system) or a relative path name (from the current directory).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-856"></A><EM CLASS="code">
INTEGER IMODE (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2264"></A><A NAME="50334051_marker-508"></A>Access mode.  Use one of the following predefined constants:</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2856"></A><EM CLASS="code">
EXREAD</EM>
 	To open the file just for reading. </P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2858"></A><EM CLASS="code">
EXWRIT</EM>
 	To open the file for writing and reading.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-730"></A><EM CLASS="code">
INTEGER ICOMPWS (RW)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-731"></A>The <A NAME="50334051_marker-385"></A>word size in bytes (0, 4 or 8) of the floating point variables used in the application program. If 0 (zero) is passed, the default size of floating point values for the machine will be used and returned in this variable. WARNING: all EXODUS II functions requiring reals must be passed reals declared with this passed in or returned compute word size.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-857"></A><EM CLASS="code">
INTEGER IOWS (RW)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2265"></A>The <A NAME="50334051_marker-386"></A>word size in bytes (0, 4 or 8) of the floating point data as they are stored in the EXODUS II file. If the word size does not match the word size of data stored in the file, a fatal error is returned. If this argument is 0, the word size of the floating point data already stored in the file is returned.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-858"></A><EM CLASS="code">
REAL VERS (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2266"></A>Returned EXODUS II <A NAME="50334051_marker-387"></A>version number.  The current version is 2.02</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-859"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2267"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3925"></A>The following opens an EXODUS II file named <EM CLASS="code">
test.exo</EM>
 for read only, using default settings for compute and I/O word sizes: </P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3933"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3935"></A>	 integer cpu_ws, io_ws</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3936"></A>	 real vers</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3921"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3926"></A>c open EXODUS II file</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3929"></A>	 cpu_ws = 0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3930"></A>	 io_ws = 0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3932"></A>	 idexo = exopen (`test.exo', EXREAD, cpu_ws, io_ws, vers, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-860"></A><A NAME="50334051_marker-512"></A><A NAME="50334051_12158"></A>Close EXODUS II File</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-861"></A>The function <EM CLASS="code">
ex_close</EM>
 or (<EM CLASS="code">
EXCLOS</EM>
 for Fortran) updates and then closes an open EXODUS II file.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-862"></A>In case of an error, <EM CLASS="code">
ex_close</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXCLOS</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-874"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-864"></A>ex_close:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-865"></A><EM CLASS="code">
	int ex_close (exoid);</EM>
<A NAME="50334051_marker-25"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-866"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2261"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3030"></A>The following code segment closes an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3061"></A>int error,exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3062"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3040"></A>error = ex_close (exoid);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-867"></A>EXCLOS:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-868"></A><EM CLASS="code">
	SUBROUTINE EXCLOS ( IDEXO, IERR)</EM>
<A NAME="50334051_marker-26"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-869"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2262"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-870"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2263"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3938"></A>The following code segment closes an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3940"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3939"></A>	 call exclos (idexo, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-871"></A><A NAME="50334051_marker-389"></A><A NAME="50334051_28073"></A>Update EXODUS II File</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-872"></A>The function <EM CLASS="code">
ex_update</EM>
 or (<EM CLASS="code">
EXUPDA</EM>
 for Fortran) flushes all buffers to an EXODUS II file that is open for writing.  This routine insures that the EXODUS II file is <A NAME="50334051_marker-390"></A>current.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-873"></A>In case of an error, <EM CLASS="code">
ex_update</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXUPDA</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1884"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-875"></A>ex_update:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-876"></A><EM CLASS="code">
	int ex_update (exoid);</EM>
<A NAME="50334051_marker-27"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-877"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2268"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3059"></A>The following code segment flushes all buffers to an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3066"></A>int error,exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3067"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3063"></A>error = ex_update (exoid);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-878"></A>EXUPDA:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-879"></A><EM CLASS="code">
	SUBROUTINE EXUPDA ( IDEXO, IERR)</EM>
<A NAME="50334051_marker-28"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-880"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2269"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-881"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2270"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3942"></A>The following code segment flushes all buffers to an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3944"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3943"></A>c update the data file; this should be done at the end of every </P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3947"></A>c time step to ensure that no data is lost if the analysis dies</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3945"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3946"></A>	 call exupda (idexo, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-882"></A><A NAME="50334051_34390"></A>Write Initialization Parameters</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-883"></A>The function <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 in Fortran) writes the <A NAME="50334051_marker-391"></A>initialization parameters to the EXODUS II file.  This function must be called once (and only once) before writing any data to the file.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-884"></A>In case of an error, <EM CLASS="code">
ex_put_init</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPINI</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-885"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-886"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2920"></A>this routine has been called previously.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-887"></A>ex_put_init:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-888"></A><EM CLASS="code">
	int ex_put_init (exoid, title, num_dim, num_nodes, num_elem, num_elem_blk, num_node_sets, num_side_sets);</EM>
<A NAME="50334051_marker-29"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-889"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2271"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-890"></A><EM CLASS="code">
char* title (R)		</EM>
<A NAME="50334051_marker-392"></A></P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2272"></A>Database title. Maximum length is <EM CLASS="code">
MAX_LINE_LENGTH</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-891"></A><EM CLASS="code">
int num_dim (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2273"></A>The <A NAME="50334051_marker-393"></A>dimensionality of the database.  This is the number of coordinates per node.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-892"></A><EM CLASS="code">
int num_nodes (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2274"></A>The <A NAME="50334051_marker-394"></A>number of nodal points.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-893"></A><EM CLASS="code">
int num_elem (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2275"></A>The <A NAME="50334051_marker-395"></A>number of elements.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-894"></A><EM CLASS="code">
int num_elem_blk (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2276"></A>The number of <A NAME="50334051_marker-396"></A>element blocks.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-895"></A><EM CLASS="code">
int num_node_sets (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2277"></A>The number of <A NAME="50334051_marker-397"></A>node sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-896"></A><EM CLASS="code">
int num_side_sets (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2278"></A>The number of <A NAME="50334051_marker-398"></A>side sets.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3060"></A>The following code segment will initialize an open EXODUS II file with the specified parameters:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3070"></A>int num_dim, num_nods, num_el, num_el_blk, num_ns, num_ss, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3080"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3078"></A>/* initialize file with parameters */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3068"></A>num_dim = 3; num_nods = 46; num_el = 5; num_el_blk = 5;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3072"></A>num_ns = 2; num_ss = 5;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3075"></A>error = ex_put_init (exoid, &quot;This is the title&quot;, num_dim, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3077"></A>		num_nods, num_el,num_el_blk, num_ns, num_ss);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-897"></A>EXPINI:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-898"></A><EM CLASS="code">
	SUBROUTINE EXPINI (IDEXO, TITLE, NDIM, NUMNP, NUMEL, NELBLK, NUMNPS, NUMESS, IERR)</EM>
<A NAME="50334051_marker-30"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-899"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2279"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-900"></A><EM CLASS="code">
CHARACTER*MXLNLN TITLE (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-901"></A>Database <A NAME="50334051_marker-399"></A>title.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-902"></A><EM CLASS="code">
INTEGER NDIM (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2280"></A>The <A NAME="50334051_marker-400"></A>dimensionality of the database.  This is the number of coordinates per node.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-903"></A><EM CLASS="code">
INTEGER NUMNP (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2281"></A>The <A NAME="50334051_marker-401"></A>number of nodal points.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-904"></A><EM CLASS="code">
INTEGER NUMEL (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2282"></A>The <A NAME="50334051_marker-402"></A>number of elements.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-905"></A><EM CLASS="code">
INTEGER NELBLK (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2283"></A>The number of <A NAME="50334051_marker-403"></A>element blocks.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-906"></A><EM CLASS="code">
INTEGER NUMNPS (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2284"></A>The number of <A NAME="50334051_marker-404"></A>node sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-907"></A><EM CLASS="code">
INTEGER NUMESS (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2286"></A>The number of <A NAME="50334051_marker-405"></A>side sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-908"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2287"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3949"></A>The following code segment will initialize an open EXODUS II file with the specified parameters:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3948"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3069"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3689"></A>	 character*(MXLNLN) title</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3684"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3552"></A>c initialize file with parameters</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3553"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3573"></A>	 title = &quot;This is the title&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3574"></A>	 num_dim = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3604"></A>	 num_nodes = 8</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3605"></A>	 num_elem = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3608"></A>	 num_elem_blk = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3614"></A>	 num_node_sets = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3615"></A>	 num_side_sets = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3642"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3651"></A>	 call expini (idexo, title, num_dim, num_nodes, num_elem, </P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3572"></A>	1	num_elem_blk, num_node_sets, num_side_sets, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-909"></A><A NAME="50334051_24784"></A>Read Initialization Parameters</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-910"></A>The function <EM CLASS="code">
ex_get_init</EM>
 (<EM CLASS="code">
EXGINI</EM>
 in Fortran) reads the <A NAME="50334051_marker-406"></A>initialization parameters from an opened EXODUS II file.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-911"></A>In case of an error, <EM CLASS="code">
ex_get_init</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGINI</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-912"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-913"></A>ex_get_init:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-914"></A><EM CLASS="code">
	int ex_get_init (exoid, title, num_dim, num_nodes, num_elem, num_elem_blk, num_node_sets, num_side_sets);</EM>
<A NAME="50334051_marker-31"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-915"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2285"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-916"></A><EM CLASS="code">
char* title (W)		</EM>
<A NAME="50334051_marker-407"></A></P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2288"></A>Returned database title. String length may be up to <EM CLASS="code">
MAX_LINE_LENGTH</EM>
 bytes.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-917"></A><EM CLASS="code">
int* num_dim (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2289"></A>Returned <A NAME="50334051_marker-408"></A>dimensionality of the database.  This is the number of coordinates per node.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-918"></A><EM CLASS="code">
int* num_nodes (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2290"></A>Returned <A NAME="50334051_marker-409"></A>number of nodal points.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-919"></A><EM CLASS="code">
int* num_elem (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2291"></A>Returned <A NAME="50334051_marker-410"></A>number of elements.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-920"></A><EM CLASS="code">
int* num_elem_blk (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2292"></A>Returned number of <A NAME="50334051_marker-411"></A>element blocks.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-921"></A><EM CLASS="code">
int* num_node_sets (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2293"></A>Returned number of <A NAME="50334051_marker-412"></A>node sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-922"></A><EM CLASS="code">
int* num_side_sets (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2294"></A>Returned number of <A NAME="50334051_marker-413"></A>side sets.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3081"></A>The following code segment will read the initialization parameters from the open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3071"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3092"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3087"></A>int num_dim, num_nodes, num_elem, num_elem_blk,</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3088"></A>		num_node_sets, num_side_sets, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3073"></A>char title[MAX_LINE_LENGTH+1];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3090"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3082"></A>/* read database parameters */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3083"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3084"></A>error = ex_get_init (exoid, title, &amp;num_dim, &amp;num_nodes, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3086"></A>		&amp;num_elem, &amp;num_elem_blk, &amp;num_node_sets, &amp;num_side_sets);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-923"></A>EXGINI:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-924"></A><EM CLASS="code">
	SUBROUTINE EXGINI (IDEXO, TITLE, NDIM, NUMNP, NUMEL, NELBLK, NUMNPS, NUMESS, IERR)</EM>
<A NAME="50334051_marker-32"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-925"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2295"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-926"></A><EM CLASS="code">
CHARACTER*MXLNLN TITLE (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-927"></A>Returned database <A NAME="50334051_marker-414"></A>title.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-928"></A><EM CLASS="code">
INTEGER NDIM (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2296"></A>Returned <A NAME="50334051_marker-415"></A>dimensionality of the database.  This is the number of coordinates per node.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-929"></A><EM CLASS="code">
INTEGER NUMNP (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2297"></A>Returned <A NAME="50334051_marker-416"></A>number of nodal points.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-930"></A><EM CLASS="code">
INTEGER NUMEL (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2298"></A>Returned <A NAME="50334051_marker-417"></A>number of elements.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-931"></A><EM CLASS="code">
INTEGER NELBLK (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2299"></A>Returned number of <A NAME="50334051_marker-418"></A>element blocks.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-932"></A><EM CLASS="code">
INTEGER NUMNPS (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2300"></A>Returned number of <A NAME="50334051_marker-419"></A>node sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-933"></A><EM CLASS="code">
INTEGER NUMESS (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2301"></A>Returned number of <A NAME="50334051_marker-420"></A>side sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-934"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2302"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2724"></A>The following code segment will read the initialization parameters from the open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-1851"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3729"></A>	 character*(MXLNLN) titl</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3713"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3653"></A>c read database parameters</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3657"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3701"></A>	 call exgini (idexo, titl, num_dim, num_nodes, num_elem,</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3705"></A>	1 	num_elem_blk, num_node_sets, num_side_sets, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-935"></A><A NAME="50334051_15957"></A>Write <A NAME="50334051_marker-421"></A>QA Records</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-936"></A>The function <EM CLASS="code">
ex_put_qa</EM>
 (or <EM CLASS="code">
EXPQA</EM>
 for Fortran) writes the QA records to the database.  Each QA record contains four <EM CLASS="code">
MAX_STR_LENGTH</EM>
-byte character strings.  The character strings are:</P>
<DIV>
<H6 CLASS="Enum1">
<A NAME="50334051_pgfId-937"></A>the analysis code name</H6>
<P CLASS="Enum">
<A NAME="50334051_pgfId-938"></A>the analysis code QA descriptor</P>
<P CLASS="Enum">
<A NAME="50334051_pgfId-939"></A>the analysis date</P>
<P CLASS="Enum">
<A NAME="50334051_pgfId-940"></A>the analysis time</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-941"></A>In case of an error, <EM CLASS="code">
ex_put_qa</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPQA</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-942"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-943"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2927"></A>QA records already exist in file.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-944"></A>ex_put_qa:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-945"></A><EM CLASS="code">
	int ex_put_qa (exoid, num_qa_records, qa_record[][4]);</EM>
<A NAME="50334051_marker-33"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-946"></A><EM CLASS="code">
int exoid (R)	</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2303"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-947"></A><EM CLASS="code">
int num_qa_records (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2304"></A>The number of QA records.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-948"></A><EM CLASS="code">
char* qa_record (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2305"></A>Array containing the QA records.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3093"></A>The following code segment will write out two QA records:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3074"></A>int num_qa_rec, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3110"></A>char *qa_record[2][4];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3109"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3098"></A>/* write QA records */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3095"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3096"></A>num_qa_rec = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3097"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3099"></A>qa_record[0][0] = &quot;TESTWT1&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3100"></A>qa_record[0][1] = &quot;testwt1&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3101"></A>qa_record[0][2] = &quot;07/07/93&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3102"></A>qa_record[0][3] = &quot;15:41:33&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3103"></A>qa_record[1][0] = &quot;FASTQ&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3104"></A>qa_record[1][1] = &quot;fastq&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3105"></A>qa_record[1][2] = &quot;07/07/93&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3106"></A>qa_record[1][3] = &quot;16:41:33&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3107"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3108"></A>error = ex_put_qa (exoid, num_qa_rec, qa_record);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-949"></A>EXPQA:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-950"></A><EM CLASS="code">
	SUBROUTINE EXPQA (IDEXO, NQAREC, QAREC, IERR)</EM>
<A NAME="50334051_marker-34"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-951"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2306"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-952"></A><EM CLASS="code">
INTEGER NQAREC (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2307"></A>The number of QA records.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-953"></A><EM CLASS="code">
CHARACTER*MXSTLN QAREC (4,*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-954"></A>		</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2308"></A>Array containing the QA records.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-955"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2309"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3714"></A>The following code segment will write out two QA records:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3700"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3079"></A>c NOTE:		MAXQA is the maximum number of QA records</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3085"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3076"></A>	 include'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3842"></A>	 character*(MXSTLN) qa_record(4,MAXQA)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3841"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3730"></A>c write QA records</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3736"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3745"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3753"></A>	 num_qa_rec = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3755"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3777"></A>	 qa_record(1,1) = &quot;TESTWT2&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3778"></A>	 qa_record(2,1) = &quot;testwt2&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3782"></A>	 qa_record(3,1) = &quot;07/07/93&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3789"></A>	 qa_record(4,1) = &quot;15:41:33&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3802"></A>	 qa_record(1,2) = &quot;FASTQ&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3804"></A>	 qa_record(2,2) = &quot;fastq&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3809"></A>	 qa_record(3,2) = &quot;07/07/93&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3829"></A>	 qa_record(4,2) = &quot;16:41:33&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3830"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3831"></A>	 call expqa (idexo, num_qa_rec, qa_record, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-956"></A><A NAME="50334051_16581"></A>Read <A NAME="50334051_marker-422"></A>QA Records</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-957"></A>The function <EM CLASS="code">
ex_get_qa</EM>
 (or <EM CLASS="code">
EXGQA</EM>
 for Fortran) reads the QA records from the database.  Each QA record contains four <EM CLASS="code">
MAX_STR_LENGTH</EM>
-byte character strings.  The character strings are:</P>
<DIV>
<H6 CLASS="Enum1">
<A NAME="50334051_pgfId-958"></A>the analysis code name</H6>
<P CLASS="Enum">
<A NAME="50334051_pgfId-959"></A>the analysis code QA descriptor</P>
<P CLASS="Enum">
<A NAME="50334051_pgfId-960"></A>the analysis date</P>
<P CLASS="Enum">
<A NAME="50334051_pgfId-961"></A>the analysis time</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-962"></A>Memory must be allocated for the QA records before this call is made.  The number of QA records can be determined by invoking <EM CLASS="code">
ex_inquire</EM>
 (or <EM CLASS="code">
EXINQ</EM>
 in Fortran). See <A HREF="exodusII.book.html#50334051_23612" CLASS="XRef">See Inquire EXODUS Parameters</A>.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-963"></A>In case of an error, <EM CLASS="code">
ex_get_qa</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGQA</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-964"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2945"></A>a warning value is returned if no QA records were stored.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-965"></A>ex_get_qa:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-966"></A><EM CLASS="code">
	int ex_get_qa (exoid, qa_record[][4]);</EM>
<A NAME="50334051_marker-35"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-967"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2310"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-968"></A><EM CLASS="code">
char* qa_record (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2311"></A>Returned array containing the QA records.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3111"></A>The following will determine the number of QA records and read them from the open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3119"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4578"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3121"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3122"></A>int num_qa_rec, error, exoid</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3125"></A>char *qa_record[MAX_QA_REC][4];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3126"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3112"></A>/* read QA records */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3113"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3114"></A>ex_inquire (exoid, EX_INQ_QA, &amp;num_qa_rec, &amp;fdum, cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3115"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3116"></A>for (i=0; i&lt;num_qa_rec; i++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3118"></A>	for (j=0; j&lt;4; j++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3120"></A>		qa_record[i][j] = </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3117"></A>			(char *) calloc ((MAX_STR_LENGTH+1), sizeof(char));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3123"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3124"></A>error = ex_get_qa (exoid, qa_record);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-969"></A>EXGQA:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-970"></A><EM CLASS="code">
	SUBROUTINE EXGQA (IDEXO, QAREC, IERR)</EM>
<A NAME="50334051_marker-36"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-971"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2312"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-972"></A><EM CLASS="code">
CHARACTER*MXSTLN QAREC(4,*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-973"></A>Returned array containing the QA records.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-974"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2313"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3869"></A>The following will determine the number of QA records and read them from the open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3856"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4580"></A>C NOTE:		MAXQA is the maximum number of QA records</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4581"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4579"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3897"></A>	 character*(MXSTLN) qa_record(4,MAXQA)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3951"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3882"></A>c read QA records</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3883"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3896"></A>	 call exinq (idexo, EXQA, num_qa_rec, fdum, cdum, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3924"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3950"></A>	 call exgqa (idexo, qa_record, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-975"></A><A NAME="50334051_29061"></A>Write Information Records</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-976"></A>The function <EM CLASS="code">
ex_put_info</EM>
 (or <EM CLASS="code">
EXPINF</EM>
 for Fortran) writes <A NAME="50334051_marker-423"></A>information records to the database.  The records are MAX_LINE_LENGTH-character strings.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-977"></A>In case of an error, <EM CLASS="code">
ex_put_info</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPINF</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-978"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-979"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-863"></A>information records already exist in file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-980"></A>ex_put_info:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-981"></A><EM CLASS="code">
	int ex_put_info (exoid, num_info, info);</EM>
<A NAME="50334051_marker-37"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-982"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2314"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-983"></A><EM CLASS="code">
int num_info (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2315"></A>The number of information records.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-984"></A><EM CLASS="code">
char** info (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2316"></A>Array containing the information records.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3127"></A>The following code will write out three information records to an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3128"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4582"></A>int error, exoid, num_info;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3140"></A>char *info[3];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3141"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3139"></A>/* write information records */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3129"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3130"></A>num_info = 3;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3131"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3132"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3133"></A>info[0] = &quot;This is the first information record.&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3134"></A>info[1] = &quot;This is the second information record.&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3135"></A>info[2] = &quot;This is the third information record.&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3136"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3137"></A>error = ex_put_info (exoid, num_info, info);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-985"></A>EXPINF:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-986"></A><EM CLASS="code">
	SUBROUTINE EXPINF (IDEXO, NINFO, INFO, IERR)</EM>
<A NAME="50334051_marker-38"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-987"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2317"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-988"></A><EM CLASS="code">
INTEGER NINFO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2318"></A>The number of information records.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-989"></A><EM CLASS="code">
CHARACTER*MXLNLN INFO(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-990"></A>Array containing the information records.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-991"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2319"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3954"></A>The following code will write out three information records to an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3953"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4583"></A>c NOTE: 		MAXINF is the maximum number of information records</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4585"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4584"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3965"></A>	 character*(MXLNLN) inform(MAXINF)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3966"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3955"></A>c write information records</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3956"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3957"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3958"></A>	 num_info = 3</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3959"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3960"></A>	 inform(1) = &quot;This is the first information record.&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3961"></A>	 inform(2) = &quot;This is the second information record.&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3962"></A>	 inform(3) = &quot;This is the third information record.&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3963"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3964"></A>	 call expinf (idexo, num_info, inform, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-992"></A><A NAME="50334051_16434"></A>Read Information Records</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-993"></A>The function <EM CLASS="code">
ex_get_info</EM>
 (or <EM CLASS="code">
EXGINF</EM>
 for Fortran) reads<A NAME="50334051_marker-424"></A> information records from the database.  The records are MAX_LINE_LENGTH-character strings.  Memory must be allocated for the information records before this call is made.  The number of records can be determined by invoking <EM CLASS="code">
ex_inquire</EM>
 (or <EM CLASS="code">
EXINQ</EM>
 in Fortram). See <A HREF="exodusII.book.html#50334051_23612" CLASS="XRef">See Inquire EXODUS Parameters</A>.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-994"></A>In case of an error, <EM CLASS="code">
ex_get_info</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGINF</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-995"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2921"></A>a warning value is returned if no information records were stored.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-996"></A>ex_get_info:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-997"></A><EM CLASS="code">
	int ex_get_info (exoid, info);</EM>
<A NAME="50334051_marker-39"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-998"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2320"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-999"></A><EM CLASS="code">
char** info (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2321"></A>Returned array containing the information records.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3138"></A>The following code segment will determine the number of information records and read them from an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3150"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4586"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3142"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3153"></A>int error, exoid, num_info;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3154"></A>char *info[MAXINFO];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3155"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3148"></A>/* read information records */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3143"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3144"></A>error = ex_inquire (exoid,EX_INQ_INFO,&amp;num_info,&amp;fdum,cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3146"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3147"></A>for (i=0; i&lt;num_info; i++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3149"></A>	info[i] = (char *) calloc ((MAX_LINE_LENGTH+1), sizeof(char));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3151"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3152"></A>error = ex_get_info (exoid, info);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1000"></A>EXGINF:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1001"></A><EM CLASS="code">
	SUBROUTINE EXGINF (IDEXO, INFO, IERR)</EM>
<A NAME="50334051_marker-40"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1002"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2322"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1003"></A><EM CLASS="code">
CHARACTER*MXLNLN INFO(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-7266"></A>Returned array containing the information records.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1005"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2323"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3968"></A>The following code segment will determine the number of information records and read them from an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3967"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4588"></A>c NOTE:		MAXINF is the maximum number of information records</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4589"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4587"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3972"></A>	 character*(MXLNLN) inform(MAXINF)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3975"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3969"></A>c read information records</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3970"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3971"></A>	 call exinq (idexo, EXINFO, num_info, fdum, cdum, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3973"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-640"></A>	 call exginf (idexo, inform, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1033"></A><A NAME="50334051_23612"></A>Inquire EXODUS Parameters</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1067"></A>The function <EM CLASS="code">
ex_inquire</EM>
 (or <EM CLASS="code">
EXINQ</EM>
 in Fortran) is used to <A NAME="50334051_marker-425"></A>inquire values of certain data entities in an EXODUS II file.  Memory must be allocated for the returned values before this function is invoked.<A NAME="50334051_marker-426"></A></P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1203"></A>In case of an error, <EM CLASS="code">
ex_inquire</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXINQ</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1419"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1505"></A>requested information not stored in the file.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1658"></A>invalid request flag.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1663"></A>ex_inquire:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1857"></A><EM CLASS="code">
	int ex_inquire (exoid, req_info, ret_int, ret_float, ret_char);</EM>
<A NAME="50334051_marker-154"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1872"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1873"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1874"></A><EM CLASS="code">
int req_info (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1875"></A>A flag which designates what information is requested.  It must be one of the following constants (predefined in the file <EM CLASS="code">
exodusII.h</EM>
):</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-1876"></A><EM CLASS="code">
EX_INQ_API_VERS</EM>
	The EXODUS II API version number is returned in <EM CLASS="code">
ret_float</EM>
. The API version number reflects the release of the function library (i.e., function names, argument list, etc.). The current API version is 2.03.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-1877"></A><EM CLASS="code">
EX_INQ_DB_VERS</EM>
	The EXODUS II database version number is returned in <EM CLASS="code">
ret_float</EM>
. The database version number reflects the format of the data in the EXODUS II file. The current database version is 2.02.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-1878"></A><EM CLASS="code">
EX_INQ_TITLE</EM>
	The title stored in the database is returned in <EM CLASS="code">
ret_char</EM>
.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-1879"></A><EM CLASS="code">
EX_INQ_DIM</EM>
 	The dimensionality, or number of coordinates per node (1, 2 or 3), of the database is returned in <EM CLASS="code">
ret_int</EM>
.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-1880"></A><EM CLASS="code">
EX_INQ_NODES</EM>
 	The number of nodal points is returned in <EM CLASS="code">
ret_int</EM>
.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-1881"></A><EM CLASS="code">
EX_INQ_ELEM</EM>
 	The number of elements is returned in <EM CLASS="code">
ret_int</EM>
.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2101"></A><EM CLASS="code">
EX_INQ_ELEM_BLK</EM>
 	The number of element blocks in returned in <EM CLASS="code">
ret_int</EM>
.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2116"></A><EM CLASS="code">
EX_INQ_NODE_SETS</EM>
 	The number of node sets is returned in <EM CLASS="code">
ret_int</EM>
.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2117"></A><EM CLASS="code">
EX_INQ_NS_NODE_LEN</EM>
	The length of the concatenated node sets node list is returned in <EM CLASS="code">
ret_int</EM>
.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2118"></A><EM CLASS="code">
EX_INQ_NS_DF_LEN</EM>
	The length of the concatenated node sets distribution list is returned in <EM CLASS="code">
ret_int</EM>
.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2119"></A><EM CLASS="code">
EX_INQ_SIDE_SETS</EM>
 	The number of side sets is returned in <EM CLASS="code">
ret_int</EM>
.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2120"></A><EM CLASS="code">
EX_INQ_SS_ELEM_LEN</EM>
 	The length of the concatenated side sets element list is returned in <EM CLASS="code">
ret_int</EM>
.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2121"></A><EM CLASS="code">
EX_INQ_SS_DF_LEN</EM>
 	The length of the concatenated side sets distribution factor list is returned in <EM CLASS="code">
ret_int</EM>
.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-3029"></A><EM CLASS="code">
EX_INQ_SS_NODE_LEN</EM>
 	The aggregate length of all of the side sets node lists is returned in <EM CLASS="code">
ret_int</EM>
.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2122"></A><EM CLASS="code">
EX_INQ_EB_PROP</EM>
 	The number of integer properties stored for each element block is returned in <EM CLASS="code">
ret_int</EM>
; this number includes the property named &quot;ID&quot;.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2123"></A><EM CLASS="code">
EX_INQ_NS_PROP</EM>
 	The number of integer properties stored for each node set is returned in <EM CLASS="code">
ret_int</EM>
; this number includes the property named &quot;ID&quot;.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2125"></A><EM CLASS="code">
EX_INQ_SS_PROP</EM>
 	The number of integer properties stored for each side set is returned in <EM CLASS="code">
ret_int</EM>
; this number includes the property named &quot;ID&quot;.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2126"></A><EM CLASS="code">
EX_INQ_QA</EM>
 	The number of QA records is returned in <EM CLASS="code">
ret_int</EM>
.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2127"></A><EM CLASS="code">
EX_INQ_INFO</EM>
 	The number of information records is returned in <EM CLASS="code">
ret_int</EM>
.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2128"></A><EM CLASS="code">
EX_INQ_TIME</EM>
 	The number of time steps stored in the database is returned in <EM CLASS="code">
ret_int</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2129"></A><EM CLASS="code">
int* ret_int (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2130"></A>Returned integer, if an integer value is requested (according to <EM CLASS="code">
req_info</EM>
); otherwise, supply a dummy argument.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2131"></A><EM CLASS="code">
float* ret_float (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2132"></A>Returned float, if a float value is requested (according to <EM CLASS="code">
req_info</EM>
); otherwise, supply a dummy argument.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2133"></A><EM CLASS="code">
char* ret_char (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2135"></A>Returned single character, if a character value is requested (according to <EM CLASS="code">
req_info</EM>
); otherwise, supply a dummy argument.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2136"></A>As an example, the following will return the number of element block properties stored in the EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-2137"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-2138"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-2139"></A>int error, exoid, num_props;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-2141"></A>float fdum;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-2146"></A>char *cdum;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-2150"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-2151"></A>/* determine the number of element block properties */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-2152"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-2153"></A>error = ex_inquire (exoid, EX_INQ_EB_PROP, &amp;num_props, &amp;fdum, cdum);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2156"></A>EXINQ:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2157"></A><EM CLASS="code">
	SUBROUTINE EXINQ (IDEXO, INFREQ, INTRET, RELRET, CHRRET, IERR)</EM>
<A NAME="50334051_marker-155"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2158"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2161"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2162"></A><EM CLASS="code">
INTEGER INFREQ (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2163"></A>A flag which designates what information is requested.  It must be one of the following constants (predefined in the file <EM CLASS="code">
exodusII.inc</EM>
):</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2164"></A><EM CLASS="code">
EXVERS</EM>
 	The EXODUS II API version number is returned in <EM CLASS="code">
RELRET</EM>
. The API version number reflects the release of the function library (i.e., function names, argument list, etc.). The current API version is 2.03.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2165"></A><EM CLASS="code">
EXDBVR</EM>
 	The EXODUS II database version number is returned in <EM CLASS="code">
RELRET</EM>
. The database version number reflects the format of the data in the EXODUS II file. The current database version is 2.02.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2166"></A><EM CLASS="code">
EXTITL</EM>
 	The title stored in the database is returned in <EM CLASS="code">
CHRRET</EM>
.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2167"></A><EM CLASS="code">
EXDIM</EM>
 	The dimensionality, or number of coordinates per node (1, 2 or 3), of the database is returned in <EM CLASS="code">
INTRET</EM>
.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2168"></A><EM CLASS="code">
EXNODE</EM>
 	The number of nodal points is returned in <EM CLASS="code">
INTRET</EM>
.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2169"></A><EM CLASS="code">
EXELEM</EM>
 	The number of elements is returned in <EM CLASS="code">
INTRET</EM>
.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2170"></A><EM CLASS="code">
EXELBL</EM>
	The number of element blocks in returned in <EM CLASS="code">
INTRET</EM>
.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2171"></A><EM CLASS="code">
EXNODS</EM>
 	The number of node sets is returned in <EM CLASS="code">
INTRET</EM>
.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2172"></A><EM CLASS="code">
EXNSNL</EM>
 	The length of the concatenated node sets node list is returned in <EM CLASS="code">
INTRET</EM>
.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2173"></A><EM CLASS="code">
EXNSDF</EM>
 	The length of the concatenated node sets distribution factors list is returned in <EM CLASS="code">
INTRET</EM>
.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2174"></A><EM CLASS="code">
EXSIDS</EM>
 	The number of side sets is returned in <EM CLASS="code">
INTRET</EM>
.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2175"></A><EM CLASS="code">
EXSSEL</EM>
 	The length of the concatenated side sets element list is returned in <EM CLASS="code">
INTRET</EM>
.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2176"></A><EM CLASS="code">
EXSSDF</EM>
 	The length of the concatenated side sets distribution factors list is returned in <EM CLASS="code">
INTRET</EM>
.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-4820"></A><EM CLASS="code">
EXSSNL</EM>
 	The aggregate length of all of the side sets node lists is returned in <EM CLASS="code">
INTRET</EM>
.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2177"></A><EM CLASS="code">
EXNEBP</EM>
 	The number of integer properties stored for each element block is returned in <EM CLASS="code">
INTRET</EM>
; this number includes the property named &quot;ID&quot;.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2178"></A><EM CLASS="code">
EXNNSP</EM>
 	The number of integer properties stored for each node set is returned in <EM CLASS="code">
INTRET</EM>
; this number includes the property named &quot;ID&quot;.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2179"></A><EM CLASS="code">
EXNSSP</EM>
 	The number of integer properties stored for each side set is returned in <EM CLASS="code">
INTRET</EM>
; this number includes the property named &quot;ID&quot;.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2182"></A><EM CLASS="code">
EXQA</EM>
 	The number of QA records is returned in <EM CLASS="code">
INTRET</EM>
.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2183"></A><EM CLASS="code">
EXINFO</EM>
 	The number of information records is returned in <EM CLASS="code">
INTRET</EM>
.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2184"></A><EM CLASS="code">
EXTIMS</EM>
	The number of time steps stored in the database is returned in <EM CLASS="code">
INTRET</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2185"></A><EM CLASS="code">
INTEGER INTRET (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2186"></A>Returned integer, if an integer value is requested (according to <EM CLASS="code">
INFREQ</EM>
); otherwise, supply a dummy argument.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2189"></A><EM CLASS="code">
REAL RELRET (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2190"></A>Returned float, if a float value is requested (according to <EM CLASS="code">
INFREQ</EM>
); otherwise, supply a dummy argument.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2191"></A><EM CLASS="code">
CHARACTER*(*) CHRRET (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2192"></A>Returned single character, if a character value is requested (according to <EM CLASS="code">
INFREQ</EM>
); otherwise, supply a dummy argument.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2193"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2194"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2195"></A>As an example, the following will return the number of element block properties stored in the EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-2196"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-2198"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-2199"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-2201"></A>	 real fdum</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-2202"></A>	 character*1 cdum</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-2203"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-2204"></A>c read element block properties</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-2205"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-2206"></A>	 call exinq (idexo, EXNEBP, num_props, fdum, cdum, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-2836"></A><A NAME="50334051_22311"></A>Error Reporting</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-2837"></A>The function <EM CLASS="code">
ex_err</EM>
 or (<EM CLASS="code">
EXERR</EM>
 for Fortran) logs an <A NAME="50334051_marker-427"></A>error to <EM CLASS="code">
stderr</EM>
. It is intended to provide explanatory messages for error codes returned from other EXODUS II routines.This function does not return an error code.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2838"></A>The passed in error codes and corresponding messages are listed in <A HREF="exodusII.book.html#50334054_12865" CLASS="XRef"></A>. The programmer may supplement the error message printed for standard errors by providing an error message. If the error code is provided with no error message, the predefined message will be used. The error code  <EM CLASS="code">
EX_MSG</EM>
 is available to log application specific messages.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2839"></A>ex_err:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2840"></A><EM CLASS="code">
	void ex_err (module_name, message, err_num);</EM>
<A NAME="50334051_marker-156"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2841"></A><EM CLASS="code">
char* module_name (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2842"></A>This is a string containing the name of the calling function. </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2843"></A><EM CLASS="code">
char* message (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2844"></A>This is a string containing a message explaining the error or problem. If <EM CLASS="code">
EX_VERBOSE</EM>
 (see <EM CLASS="code">
ex_opts</EM>
) is true, this message will be printed to <EM CLASS="code">
stderr</EM>
. Otherwise, nothing will be printed.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2845"></A><EM CLASS="code">
int err_num (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2846"></A>This is an integer code identifying the error. EXODUS II C functions place an error code value in <EM CLASS="code">
exerrval</EM>
, an <EM CLASS="code">
external</EM>
 <EM CLASS="code">
int</EM>
. Negative values are considered fatal errors while positive values are warnings. There is a set of predefined values defined in <EM CLASS="code">
exodusII.h</EM>
.  The predefined constant <EM CLASS="code">
EX_PRTLASTMSG </EM>
will cause the last error message to be output, regardless of the setting of the error reporting level (see <EM CLASS="code">
ex_opts</EM>
).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2847"></A>The following is an example of the use of this function:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-2848"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-2849"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-2850"></A>int exoid, CPU_word_size, IO_word_size, errval;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-2851"></A>float version;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-2944"></A>char errmsg[MAX_ERR_LENGTH];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3027"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3545"></A>CPU_word_size = sizeof(float); </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3549"></A>IO_word_size = 0; </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3550"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3851"></A>/* open EXODUS II file */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3873"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3884"></A>if (exoid = ex_open (&quot;test.exo&quot;, EX_READ, &amp;CPU_word_size, &amp;IO_word_size, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3885"></A>		&amp;version)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3886"></A>{</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3887"></A>	errval = 999;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3888"></A>	sprintf(errmsg,&quot;Error: cannot open file test.exo&quot;);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3889"></A>	ex_err(&quot;prog_name&quot;, errmsg, errval);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3890"></A>}</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-3891"></A>EXERR:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-3892"></A><EM CLASS="code">
	SUBROUTINE EXERR (MODNAM, MSG, ERRNUM)</EM>
<A NAME="50334051_marker-157"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-3893"></A><EM CLASS="code">
CHARACTER*MXSTLN MODNAM (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-3894"></A>This is a string containing  the name of the calling function.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-3895"></A><EM CLASS="code">
CHARACTER*MXLNLN MSG (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-3898"></A>This is a string containing a message explaining the error or problem. If <EM CLASS="code">
EXVRBS</EM>
 (see <EM CLASS="code">
EXOPTS</EM>
) is true, this message will be printed to <EM CLASS="code">
stderr</EM>
. Otherwise, nothing will be printed.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-3899"></A><EM CLASS="code">
INTEGER ERRNUM (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-3900"></A>This is an integer code identifying the error. EXODUS II Fortran functions place an error code value in <EM CLASS="code">
ierr</EM>
, a returned value. Negative values are considered fatal errors while positive values are warnings. There is a set of predefined values defined in <EM CLASS="code">
exodusII.inc</EM>
.  The predefined constant<EM CLASS="code">
 PRTMSG</EM>
 will cause the last error message to be output, regardless of the setting of the error reporting level (see <EM CLASS="code">
EXOPTS</EM>
)</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3901"></A>The following is an example of the use of this function:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3902"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3903"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3904"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3905"></A>	 integer cpu_ws</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3906"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3907"></A>c open EXODUS II files</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3908"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3909"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3910"></A>	 cpu_ws = 0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3911"></A>	 io_ws = 0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3912"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3913"></A>	 idexo = exopen (&quot;test.exo&quot;, EXREAD, cpu_ws, io_ws, vers, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3974"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4518"></A>	 if (ierr .lt. 0) then</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4544"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4546"></A>c		error was fatal, so print it out; override setting of exopts</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4547"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4548"></A>		call exerr (&quot;progname&quot;, &quot;&quot;, PRTMSG)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4549"></A>	 endif</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-4550"></A><A NAME="50334051_42529"></A>Set Error Reporting Level </H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-4551"></A>The function <A NAME="50334051_marker-158"></A><EM CLASS="code">
ex_opts</EM>
 (or <EM CLASS="code">
EXOPTS</EM>
 for Fortran) is used to set message reporting options. </P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4552"></A>In case of an <A NAME="50334051_marker-428"></A>error, <EM CLASS="code">
ex_opts</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXOPTS</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
. </P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-4553"></A>ex_opts:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-4554"></A><EM CLASS="code">
	int ex_opts (option_val);</EM>
<A NAME="50334051_marker-302"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-4555"></A><EM CLASS="code">
int option_val (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-4556"></A>Integer option value. Current options are:</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-4557"></A><EM CLASS="code">
EX_ABORT</EM>
 	Causes fatal errors to force program exit. (Default is false.)</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-4558"></A><EM CLASS="code">
EX_DEBUG</EM>
 	Causes certain messages to print for debug use. (Default is false.)</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-4559"></A><EM CLASS="code">
EX_VERBOSE</EM>
 	Causes all error messages to print when true, otherwise no error messages will print. (Default is false.).</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-4560"></A>NOTE: Values may be OR'ed together to provide any combination of these capabilities.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4561"></A>For example, the following will cause all messages to print and will cause the program to exit upon receipt of fatal error:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4562"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4563"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4564"></A>ex_opts (EX_ABORT | EX_VERBOSE);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-4565"></A>EXOPTS:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-4566"></A><EM CLASS="code">
	SUBROUTINE EXOPTS (OPTVAL, IERR)</EM>
<A NAME="50334051_marker-159"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-4567"></A><EM CLASS="code">
INTEGER OPTVAL (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-4568"></A>Integer option value. Current options are:</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-4569"></A><EM CLASS="code">
EXABRT</EM>
 	Causes fatal errors to force program exit. (Default is false.)</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-4570"></A><EM CLASS="code">
EXDEBG</EM>
 	Causes certain messages to print for debug use. (Default is false.)</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-4571"></A><EM CLASS="code">
EXVRBS</EM>
 	Causes all error messages to print when true, otherwise no error messages will print. (Default is false.)</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-4572"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-4573"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-4574"></A>NOTE: Values may be OR'ed together to provide any combination of capabilities.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4576"></A>For example, the following will cause all messages to print:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4577"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4620"></A>	 call exopts (EXVRBS, IERR)</P>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-4779"></A><A NAME="50334051_marker-388"></A>Model Description</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1007"></A>The routines in this section read and write information which describe an EXODUS II finite element model.  This includes nodal coordinates, element order map, element connectivity arrays, element attributes, node sets, side sets, and object properties.</P>
</DIV>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1008"></A><A NAME="50334051_10305"></A>Write Nodal Coordinates</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1009"></A>The function  <EM CLASS="code">
ex_put_coord</EM>
 (or <EM CLASS="code">
EXPCOR</EM>
 for Fortran) writes the <A NAME="50334051_marker-429"></A>coordinates of the nodes in the model.  The function <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran) must be invoked before this call is made.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1010"></A>Because the coordinates are floating point values, the application code must declare the arrays passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1011"></A>In case of an error, <EM CLASS="code">
ex_put_coord</EM>
 returns a negative number; a warning will return a positive number. <EM CLASS="code">
EXPCOR</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1012"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1013"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2924"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1015"></A>ex_put_coord:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1016"></A><EM CLASS="code">
	int ex_put_coord (exoid, x_coor, y_coor, z_coor);</EM>
<A NAME="50334051_marker-41"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1017"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2324"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1018"></A><EM CLASS="code">
void* x_coor (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2325"></A>The X coordinates of the nodes.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1019"></A><EM CLASS="code">
void* y_coor (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2326"></A>The Y coordinates of the nodes. These are stored only if <EM CLASS="code">
num_dim</EM>
 &gt; 1; otherwise, pass in dummy address.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1020"></A><EM CLASS="code">
void* z_coor (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2327"></A>The Z coordinates of the nodes.  These are stored only if <EM CLASS="code">
num_dim</EM>
 &gt; 2; otherwise, pass in dummy address.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3156"></A>The following will write the nodal coordinates to an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3157"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4590"></A>int error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3162"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3165"></A>/* if file opened with compute word size of sizeof(float) */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3160"></A>float x[8], y[8], z[8]; </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3163"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3159"></A>/* write nodal coordinates values to database */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3158"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3172"></A>x[0] = 0.0; y[0] = 0.0; z[0] = 0.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3173"></A>x[1] = 0.0; y[1] = 0.0; z[1] = 1.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3174"></A>x[2] = 1.0; y[2] = 0.0; z[2] = 1.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3175"></A>x[3] = 1.0; y[3] = 0.0; z[3] = 0.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3176"></A>x[4] = 0.0; y[4] = 1.0; z[4] = 0.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3177"></A>x[5] = 0.0; y[5] = 1.0; z[5] = 1.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3178"></A>x[6] = 1.0; y[6] = 1.0; z[6] = 1.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3179"></A>x[7] = 1.0; y[7] = 1.0; z[7] = 0.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3180"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3196"></A>error = ex_put_coord (exoid, x, y, z);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1021"></A>EXPCOR:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1022"></A><EM CLASS="code">
	 SUBROUTINE EXPCOR (IDEXO, XN, YN, ZN, IERR)</EM>
<A NAME="50334051_marker-42"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1023"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2328"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1024"></A><EM CLASS="code">
REAL XN(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2329"></A>The X coordinates of the nodes.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1025"></A><EM CLASS="code">
REAL YN(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2330"></A>The Y coordinates of the nodes. These are stored only if <EM CLASS="code">
NDIM</EM>
 &gt; 1; otherwise, pass in a dummy address.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1026"></A><EM CLASS="code">
REAL ZN(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2331"></A>The Z coordinates of the nodes.  These are stored only if <EM CLASS="code">
NDIM</EM>
 &gt; 2; otherwise, pass in a dummy address.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1027"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2332"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3977"></A>The following will write the nodal coordinates to an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3976"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4000"></A>	 real x(8), y(8), dummy(1)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3999"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3978"></A>c write nodal coordinates values for a 2-d model to the database</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3979"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3980"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3981"></A>	 x(1) = 0.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3982"></A>	 x(2) = 1.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3983"></A>	 x(3) = 1.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3984"></A>	 x(4) = 0.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3985"></A>	 x(5) = 1.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3986"></A>	 x(6) = 2.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3987"></A>	 x(7) = 2.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3988"></A>	 x(8) = 1.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3989"></A>	 y(1) = 0.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3990"></A>	 y(2) = 0.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3991"></A>	 y(3) = 1.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3992"></A>	 y(4) = 1.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3993"></A>	 y(5) = 0.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3994"></A>	 y(6) = 0.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3995"></A>	 y(7) = 1.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3996"></A>	 y(8) = 1.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3997"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3998"></A>	 call expcor (idexo, x, y, dummy, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1028"></A><A NAME="50334051_36174"></A>Read Nodal Coordinates</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1029"></A>The function  <EM CLASS="code">
ex_get_coord</EM>
 or (<EM CLASS="code">
EXGCOR</EM>
 for Fortran) reads the <A NAME="50334051_marker-430"></A>coordinates of the nodes.  Memory must be allocated for the coordinate arrays (<EM CLASS="code">
x_coor</EM>
, <EM CLASS="code">
y_coor</EM>
, and <EM CLASS="code">
z_coor</EM>
) before this call is made. The length of each of these arrays is the number of nodes in the mesh.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1030"></A>Because the coordinates are floating point values, the application code must declare the arrays passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1031"></A>In case of an error, <EM CLASS="code">
ex_get_coord</EM>
 returns a negative number; a warning will return a positive number. <EM CLASS="code">
EXGCOR</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1032"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2946"></A>a warning value is returned if nodal coordinates were not stored.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1034"></A>ex_get_coord:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1035"></A><EM CLASS="code">
	int ex_get_coord (exoid, x_coor, y_coor, z_coor);</EM>
<A NAME="50334051_marker-43"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1036"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2333"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1037"></A><EM CLASS="code">
void* x_coor (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2334"></A>Returned X coordinates of the nodes.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1038"></A><EM CLASS="code">
void* y_coor (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2335"></A>Returned Y coordinates of the nodes. These are returned only if <EM CLASS="code">
num_dim</EM>
 &gt; 1; otherwise, pass in a dummy address.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1039"></A><EM CLASS="code">
void* z_coor (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2336"></A>Returned Z coordinates of the nodes.  These are returned only if <EM CLASS="code">
num_dim</EM>
 &gt; 2; otherwise, pass in a dummy address.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3167"></A>The following code segment will read the nodal coordinates from an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3168"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4593"></A>int error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3166"></A>float *x, *y, *z;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3164"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3161"></A>/* read nodal coordinates values from database */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3169"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3170"></A>x = (float *) calloc(num_nodes, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3171"></A>y = (float *) calloc(num_nodes, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3181"></A>if (num_dim &gt;= 3)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3182"></A>	z = (float *) calloc(num_nodes, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3183"></A>else</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3184"></A>	z = 0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3186"></A>error = ex_get_coord (exoid, x, y, z);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1040"></A>EXGCOR:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1041"></A><EM CLASS="code">
	 SUBROUTINE EXGCOR (IDEXO, XN, YN, ZN, IERR)</EM>
<A NAME="50334051_marker-44"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1042"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2337"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1043"></A><EM CLASS="code">
REAL XN(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2338"></A>Returned X coordinates of the nodes.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1044"></A><EM CLASS="code">
REAL YN(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2339"></A>Returned Y coordinates of the nodes. These are returned only if <EM CLASS="code">
NDIM</EM>
 &gt; 1; otherwise, pass in a dummy address.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1045"></A><EM CLASS="code">
REAL ZN(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2340"></A>Returned Z coordinates of the nodes.  These are returned only if <EM CLASS="code">
NDIM</EM>
 &gt; 2; otherwise, pass in a dummy address.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1046"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2341"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4002"></A>The following code segment will read the nodal coordinates from an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4001"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4595"></A>c NOTE:		MAXNOD is the maximum number of nodes</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4596"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4008"></A>	 real x(MAXNOD), y(MAXNOD), z(MAXNOD)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4007"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4003"></A>c read nodal coordinates values from database</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4004"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4005"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4006"></A>	 call exgcor (idexo, x, y, z, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1047"></A><A NAME="50334051_32573"></A>Write <A NAME="50334051_marker-431"></A>Coordinate Names</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1048"></A>The function  <EM CLASS="code">
ex_put_coord_names</EM>
 or (<EM CLASS="code">
EXPCON</EM>
 for Fortran) writes the names of the coordinate arrays to the database.  The function <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran) must be invoked before this call is made.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1049"></A>In case of an error, <EM CLASS="code">
ex_put_coord_names</EM>
 returns a negative number; a warning will return a positive number. <EM CLASS="code">
EXPCON</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1050"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1051"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1014"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1053"></A>ex_put_coord_names:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1054"></A><EM CLASS="code">
	int ex_put_coord_names (exoid, coord_names);</EM>
<A NAME="50334051_marker-45"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1055"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2342"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1056"></A><EM CLASS="code">
char** coord_names (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2343"></A>Array containing <EM CLASS="code">
num_dim</EM>
 names (of length <EM CLASS="code">
MAX_STR_LENGTH)</EM>
 of the nodal coordinate arrays.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3190"></A>The following coding will write the coordinate names to an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3191"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3188"></A>int error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3198"></A>char *coord_names[3];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3199"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3197"></A>coord_names[0] = &quot;xcoor&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3192"></A>coord_names[1] = &quot;ycoor&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3193"></A>coord_names[2] = &quot;zcoor&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3194"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3195"></A>error = ex_put_coord_names (exoid, coord_names);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1057"></A>EXPCON:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1058"></A><EM CLASS="code">
	 SUBROUTINE EXPCON (IDEXO, NAMECO, IERR)</EM>
<A NAME="50334051_marker-46"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1059"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2344"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1060"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMECO(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1061"></A>Array containing <EM CLASS="code">
NDIM</EM>
 names for the nodal coordinate arrays.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1062"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2345"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3185"></A>The following coding will write the coordinate names to an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4014"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4013"></A>	 character*(MXSTLN)coord_names(3)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4012"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4015"></A>	 coord_names(1) = &quot;xcoor&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4009"></A>	 coord_names(2) = &quot;ycoor&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4016"></A>	 coord_names(3) = &quot;zcoor&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4010"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4011"></A>	 call expcon (idexo, coord_names, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1063"></A><A NAME="50334051_31901"></A>Read <A NAME="50334051_marker-432"></A>Coordinate Names</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1064"></A>The function  <EM CLASS="code">
ex_get_coord_names</EM>
 or (<EM CLASS="code">
EXGCON</EM>
 for Fortran) reads the names (<EM CLASS="code">
MAX_STR_LENGTH</EM>
-characters in length) of the coordinate arrays from the database.  Memory must be allocated for the character strings before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1065"></A>In case of an error, <EM CLASS="code">
ex_get_coord_names</EM>
 returns a negative number; a warning will return a positive number. <EM CLASS="code">
EXGCON</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1066"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2947"></A>a warning value is returned if coordinate names were not stored.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1068"></A>ex_get_coord_names:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1069"></A><EM CLASS="code">
	int ex_get_coord_names (exoid, coord_names);</EM>
<A NAME="50334051_marker-47"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1070"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2346"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1071"></A><EM CLASS="code">
char** coord_names (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2347"></A>Returned pointer to a vector containing <EM CLASS="code">
num_dim</EM>
 names of the nodal coordinate arrays.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3200"></A>The following code segment will read the coordinate names from an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3201"></A>int error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3207"></A>char *coord_names[3];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3208"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3204"></A>for (i=0; i&lt;num_dim; i++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3203"></A>	coord_names[i] = (char *) calloc ((MAX_STR_LENGTH+1), sizeof(char));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3205"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3206"></A>error = ex_get_coord_names (exoid, coord_names);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1072"></A>EXGCON:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1073"></A><EM CLASS="code">
	 SUBROUTINE EXGCON (IDEXO, NAMECO, IERR)</EM>
<A NAME="50334051_marker-48"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1074"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2348"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1075"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMECO(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1076"></A>Returned array containing <EM CLASS="code">
NDIM</EM>
 names for the nodal coordinate arrays.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1077"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2349"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4018"></A>The following code segment will read the coordinate names from an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4017"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4021"></A>	 character*(MXSTLN) coord_names(3)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4020"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4019"></A>	 call exgcon (idexo, coord_names, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-6141"></A><A NAME="50334051_29827"></A>Write Node Number Map</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-6143"></A>The function <EM CLASS="code">
ex_put_node_num_map</EM>
 (or <EM CLASS="code">
EXPNNM</EM>
 for Fortran) writes out the optional <A NAME="50334051_marker-6280"></A>node number map to the database.  The function <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran) must be invoked before this call is made.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-6144"></A>In case of an error, <EM CLASS="code">
ex_put_node_num_map</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPNNM</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-6145"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-6146"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-6147"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-6148"></A>a node number map already exists in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-6149"></A>ex_put_node_num_map:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-6151"></A><EM CLASS="code">
	int ex_put_node_num_map (exoid, node_map);</EM>
<A NAME="50334051_marker-6150"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6152"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6153"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6154"></A><EM CLASS="code">
int* node_map (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6155"></A>The node number map.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-6156"></A>The following code generates a default node number map and outputs it to an open EXODUS II file. This is a trivial case and included just for illustration. Since this map is optional, it should be written out only if it contains something other than the default map.</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6157"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6158"></A>int *node_map, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6159"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6160"></A>node_map = (int *) calloc(num_nodes, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6161"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6162"></A>for (i=1; i&lt;=num_nodes; i++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6163"></A>	node_map[i-1] = i;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6164"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6165"></A>error = ex_put_node_num_map (exoid, node_map);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-6166"></A>EXPNNM:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-6168"></A><EM CLASS="code">
	SUBROUTINE EXPNNM (IDEXO, MAPNOD, IERR)</EM>
<A NAME="50334051_marker-6167"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6169"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6170"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6171"></A><EM CLASS="code">
INTEGER MAPNOD(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6172"></A>The node number map.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6173"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6174"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-6175"></A>The following code generates a default node number map and outputs it to an open EXODUS II file. This is a trivial case and included just for illustration. Since this map is optional, it should be written out only if it contains something other than the default map.</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6176"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6177"></A>c NOTE:		MAXNOD is the maximum number of nodes</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6178"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6179"></A>	 integer node_map(MAXNOD)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6180"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6181"></A>c write node order map</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6182"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6183"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6184"></A>	 do 10 i = 1, num_nodes</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6185"></A>		 node_map(i) = i</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6186"></A>10 	 continue</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6187"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6188"></A>	 call expnnm (idexo, node_map, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-6189"></A><A NAME="50334051_35467"></A>Read Node Number Map</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-6191"></A>The function <EM CLASS="code">
ex_get_node_num_map</EM>
 (or <EM CLASS="code">
EXGNNM</EM>
 for Fortran) reads the optional <A NAME="50334051_marker-6281"></A>node number map from the database. If a node number map is not stored in the data file, a default array (1,2,3, . . . <EM CLASS="code">
num_nodes</EM>
) is returned. Memory must be allocated for the node number map array (<EM CLASS="code">
num_nodes</EM>
 in length) before this call is made.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-6192"></A>In case of an error, <EM CLASS="code">
ex_get_node_num_map </EM>
returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGNNM</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-6193"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-6194"></A>if a node number map is not stored, a default map and a warning value are returned.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-6195"></A>ex_get_node_num_map:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-6197"></A><EM CLASS="code">
	int ex_get_node_num_map (exoid, node_map);</EM>
<A NAME="50334051_marker-6196"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6198"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6199"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6200"></A><EM CLASS="code">
int* node_map (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6201"></A>Returned node number map.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-6202"></A>The following code will read a node number map from an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6203"></A>int *node_map, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6204"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6205"></A>/* read node number map */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6206"></A>node_map = (int *) calloc(num_nodes, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6207"></A>error = ex_get_node_num_map (exoid, node_map);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-6208"></A>EXGNNM:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-6210"></A><EM CLASS="code">
	SUBROUTINE EXGNNM (IDEXO, MAPNOD, IERR)</EM>
<A NAME="50334051_marker-6209"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6211"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6212"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6213"></A><EM CLASS="code">
INTEGER MAPNOD(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6214"></A>Returned node number map.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6215"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6216"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-6217"></A>The following code will read a node number map from an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6218"></A>	 integer node_map(MAXNODES)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6219"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6220"></A>c read node number map</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6221"></A>	 call exgnnm (idexo, node_map, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-6306"></A><A NAME="50334051_35671"></A>Write Element Number Map</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-6307"></A>The function <EM CLASS="code">
ex_put_elem_num_map</EM>
 (or <EM CLASS="code">
EXPENM</EM>
 for Fortran) writes out the optional <A NAME="50334051_marker-6466"></A>element number map to the database.  The function <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran) must be invoked before this call is made.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-6309"></A>In case of an error, <EM CLASS="code">
ex_put_elem_num_map</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPENM</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-6310"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-6311"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-6312"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-6313"></A>an element number map already exists in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-6314"></A>ex_put_elem_num_map:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-6316"></A><EM CLASS="code">
	int ex_put_elem_num_map (exoid, elem_map);</EM>
<A NAME="50334051_marker-6315"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6317"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6318"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6319"></A><EM CLASS="code">
int* elem_map (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6320"></A>The element number map.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-6321"></A>The following code generates a default element number map and outputs it to an open EXODUS II file. This is a trivial case and included just for illustration. Since this map is optional, it should be written out only if it contains something other than the default map.</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6322"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6323"></A>int *elem_map, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6324"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6325"></A>elem_map = (int *) calloc(num_elem, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6326"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6327"></A>for (i=1; i&lt;=num_elem; i++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6328"></A>	elem_map[i-1] = i;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6329"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6330"></A>error = ex_put_elem_num_map (exoid, elem_map);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-6331"></A>EXPENM:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-6333"></A><EM CLASS="code">
	SUBROUTINE EXPENM (IDEXO, MAPEL, IERR)</EM>
<A NAME="50334051_marker-6332"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6334"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6335"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6336"></A><EM CLASS="code">
INTEGER MAPEL(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6337"></A>The element number map.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6338"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6339"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-6340"></A>The following code generates a default element number map and outputs it to an open EXODUS II file. This is a trivial case and included just for illustration. Since this map is optional, it should be written out only if it contains something other than the default map.</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6341"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6342"></A>c NOTE:		MAXELEM is the maximum number of elements</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6343"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6344"></A>	 integer elem_map(MAXELEM)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6345"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6346"></A>c write element number map</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6347"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6348"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6349"></A>	 do 10 i = 1, num_elem</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6350"></A>		 elem_map(i) = i</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6351"></A>10 	 continue</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6352"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6353"></A>	 call expenm (idexo, elem_map, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-6354"></A><A NAME="50334051_22184"></A>Read Element Number Map</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-6356"></A>The function <EM CLASS="code">
ex_get_elem_num_map</EM>
 (or <EM CLASS="code">
EXGENM</EM>
 for Fortran) reads the optional <A NAME="50334051_marker-6467"></A>element number map from the database. If an element number map is not stored in the data file, a default array (1,2,3, . . . <EM CLASS="code">
num_elem</EM>
) is returned. Memory must be allocated for the element number map array (<EM CLASS="code">
num_elem</EM>
 in length) before this call is made.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-6357"></A>In case of an error, <EM CLASS="code">
ex_get_elem_num_map </EM>
returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGENM</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-6358"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-6359"></A>if an element number map is not stored, a default map and a warning value are returned.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-6360"></A>ex_get_elem_num_map:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-6362"></A><EM CLASS="code">
	int ex_get_elem_num_map (exoid, elem_map);</EM>
<A NAME="50334051_marker-6361"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6363"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6364"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6365"></A><EM CLASS="code">
int* elem_map (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6366"></A>Returned element number map.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-6367"></A>The following code will read an element number map from an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6368"></A>int *elem_map, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6369"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6370"></A>/* read element number map */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6371"></A>elem_map = (int *) calloc(num_elem, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-6372"></A>error = ex_get_elem_num_map (exoid, elem_map);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-6373"></A>EXGENM:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-6375"></A><EM CLASS="code">
	SUBROUTINE EXGENM (IDEXO, MAPEL, IERR)</EM>
<A NAME="50334051_marker-6374"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6376"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6377"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6378"></A><EM CLASS="code">
INTEGER MAPEL(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6379"></A>Returned element number map.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-6380"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-6381"></A>Returned error code.  If no errors occurredoccurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-6382"></A>The following code will read an element number map from an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6383"></A>	 integer elem_map(MAXELEM)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6384"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6385"></A>c read element number map</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-6386"></A>	 call exgenm (idexo, elem_map, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1078"></A><A NAME="50334051_41386"></A>Write Element Order Map</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1079"></A>The function <EM CLASS="code">
ex_put_map</EM>
 (or <EM CLASS="code">
EXPMAP</EM>
 for Fortran) writes out the optional <A NAME="50334051_marker-433"></A>element order map to the database.  The function <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran) must be invoked before this call is made.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1080"></A>In case of an error, <EM CLASS="code">
ex_put_map</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPMAP</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1081"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1082"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1052"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2948"></A>an element map already exists in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1084"></A>ex_put_map:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1085"></A><EM CLASS="code">
	int ex_put_map (exoid, elem_map);</EM>
<A NAME="50334051_marker-49"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1086"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2350"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1087"></A><EM CLASS="code">
int* elem_map (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2351"></A>The element order map.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3209"></A>The following code generates a default element order map and outputs it to an open EXODUS II file. This is a trivial case and included just for illustration. Since this map is optional, it should be written out only if it contains something other than the default map.</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3210"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3187"></A>int *elem_map, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3215"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3213"></A>elem_map = (int *) calloc(num_elem, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3211"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3212"></A>for (i=1; i&lt;=num_elem; i++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3214"></A>	elem_map[i-1] = i;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3216"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3217"></A>error = ex_put_map (exoid, elem_map);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1088"></A>EXPMAP:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1089"></A><EM CLASS="code">
	SUBROUTINE EXPMAP (IDEXO, MAPEL, IERR)</EM>
<A NAME="50334051_marker-50"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1090"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2352"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1091"></A><EM CLASS="code">
INTEGER MAPEL(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2353"></A>The element order map.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1092"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2354"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4023"></A>The following code generates a default element order map and outputs it to an open EXODUS II file. This is a trivial case and included just for illustration. Since this map is optional, it should be written out only if it contains something other than the default map.</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4022"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3189"></A>c NOTE:		MAXELEM is the maximum number of elements</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4597"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4033"></A>	 integer elem_map(MAXELEM)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4032"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4024"></A>c write element order map</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4025"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4026"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4027"></A>	 do 10 i = 1, num_elem</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4028"></A>		 elem_map(i) = i</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4029"></A>10 	 continue</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4030"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4031"></A>	 call expmap (idexo, elem_map, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1093"></A><A NAME="50334051_22279"></A>Read Element Order Map</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1094"></A>The function <EM CLASS="code">
ex_get_map</EM>
 (or <EM CLASS="code">
EXGMAP</EM>
 for Fortran) reads the <A NAME="50334051_marker-434"></A>element order map from the database. If an element order map is not stored in the data file, a default array (1,2,3, . . . <EM CLASS="code">
num_elem</EM>
) is returned. Memory must be allocated for the element map array (<EM CLASS="code">
num_elem</EM>
 in length) before this call is made.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1095"></A>In case of an error, <EM CLASS="code">
ex_get_map</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGMAP</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1096"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2949"></A>if an element order map is not stored, a default map and a warning value are returned.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1097"></A>ex_get_map:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1098"></A><EM CLASS="code">
	int ex_get_map (exoid, elem_map);</EM>
<A NAME="50334051_marker-51"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1099"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2355"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1100"></A><EM CLASS="code">
int* elem_map (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2356"></A>Returned element order map.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3218"></A>The following code will read an element order map from an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3219"></A>int *elem_map, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3220"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3222"></A>/* read element order map */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3221"></A>elem_map = (int *) calloc(num_elem, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3223"></A>error = ex_get_map (exoid, elem_map);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1101"></A>EXGMAP:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1102"></A><EM CLASS="code">
	SUBROUTINE EXGMAP (IDEXO, MAPEL, IERR)</EM>
<A NAME="50334051_marker-52"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1103"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2357"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1104"></A><EM CLASS="code">
INTEGER MAPEL(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2358"></A>Returned element order map.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1105"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1106"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4035"></A>The following code will read an element order map from an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4040"></A>	 integer elem_map(MAXELEM)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4041"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4036"></A>c read element order map</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4039"></A>	 call exgmap (idexo, elem_map, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-2359"></A><A NAME="50334051_14923"></A>Write Element Block Parameters</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1107"></A>The function <EM CLASS="code">
ex_put_elem_block</EM>
 (or <EM CLASS="code">
EXPELB</EM>
 for Fortran) writes the parameters used to describe an <A NAME="50334051_marker-435"></A>element block.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1108"></A>In case of an error, <EM CLASS="code">
ex_put_elem_block</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPELB</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1109"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1110"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2925"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2950"></A>an element block with the same ID has already been specified.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2951"></A>the number of element blocks specified in the call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran) has been exceeded.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1111"></A>ex_put_elem_block:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1112"></A><EM CLASS="code">
	int ex_put_elem_block (exoid, elem_blk_id, elem_type, num_elem_this_blk, num_nodes_per_elem, num_attr);</EM>
<A NAME="50334051_marker-53"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1113"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2360"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1114"></A><EM CLASS="code">
int elem_blk_id (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2361"></A>The <A NAME="50334051_marker-436"></A>element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1115"></A><EM CLASS="code">
char* elem_type (R)		</EM>
<A NAME="50334051_marker-437"></A></P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2362"></A>The type of elements in the element block. The maximum length of this string is <EM CLASS="code">
MAX_STR_LENGTH.</EM>
 For historical reasons, this string should be all upper case.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1116"></A><EM CLASS="code">
int num_elem_this_blk (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2363"></A>The number of elements in the element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1117"></A><EM CLASS="code">
int num_nodes_per_elem (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2364"></A>The number of nodes per element in the element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1118"></A><EM CLASS="code">
int num_attr (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2365"></A>The number of <A NAME="50334051_marker-438"></A>attributes per element in the element block.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3226"></A>For example, the following code segment will initialize an element block with an ID of 10, write out the connectivity array, and write out the element attributes array:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4598"></A>int id, error, exoid, num_elem_in_blk, num_nodes_per_elem,</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3233"></A>	*connect, num_attr;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3260"></A>float *attrib;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3231"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3230"></A>/* write element block parameters */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3228"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3229"></A>id = 10;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3369"></A>num_elem_in_blk = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3235"></A>num_nodes_per_elem = 4; 				/* elements are 4-node shells */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3234"></A>num_attr = 1; 				/* one attribute per element */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3240"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3247"></A>error = ex_put_elem_block (exoid, id, &quot;SHEL&quot;, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3232"></A>		num_elem_in_blk, num_nodes_per_elem, num_attr);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3252"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3265"></A>/* write element connectivity */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3266"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3253"></A>connect = (int *) </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3145"></A>		calloc (num_elem_in_blk*num_nodes_per_elem, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-8417"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-8420"></A>/* fill connect with node numbers; nodes for first element*/</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-8408"></A>connect[0] = 1; connect[1] = 2; connect[2] = 3; connect[3] = 4;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-8425"></A>/* nodes for second element */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-8411"></A>connect[4] = 5; connect[5] = 6; connect[6] = 7; connect[7] = 8;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-8409"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3270"></A>error = ex_put_elem_conn (exoid, id, connect);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-1119"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3308"></A>/* write element block attributes */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3309"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3310"></A>attrib = (float *) calloc (num_attr * num_elem_in_blk, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3312"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3313"></A>for (i=0, cnt=0; i&lt;num_elem_in_blk; i++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3314"></A>	for (j=0; j&lt;num_attr; j++, cnt++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3315"></A>		attrib[cnt] = 1.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3367"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3368"></A>error = ex_put_elem_attr (exoid, id, attrib);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-3293"></A>EXPELB:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1120"></A><EM CLASS="code">
	SUBROUTINE EXPELB (IDEXO, IDELB, NAMELB, NUMELB, NUMLNK, NUMATR, IERR)</EM>
<A NAME="50334051_marker-54"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1121"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2366"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1122"></A><EM CLASS="code">
INTEGER IDELB (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2367"></A>The <A NAME="50334051_marker-439"></A>element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1123"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMELB (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1124"></A>The <A NAME="50334051_marker-440"></A>type of elements in the element block. For historical reasons, this string should be all upper case.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1125"></A><EM CLASS="code">
INTEGER NUMELB (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2368"></A>The number of elements in the element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1126"></A><EM CLASS="code">
INTEGER NUMLNK (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2369"></A>The number of nodes per element in the element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1127"></A><EM CLASS="code">
INTEGER NUMATR (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2370"></A>The number of <A NAME="50334051_marker-441"></A>attributes per element in the element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1128"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2371"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4599"></A>For example, the following code segment will initialize an element block with an ID of 10, write out the connectivity array, and write out the element attributes array:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3224"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4600"></A>c NOTE: 		MAXLNK is the maximum number of nodes per element</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4603"></A>c		MAXELB is the maximum number of elements per element block</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4602"></A>c		MAXATR is the maximum number of attributes per element</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4604"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4605"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4606"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4601"></A>	 integer ebid, connect(MAXLNK * MAXELB)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4055"></A>	 real attrib(MAXATR * MAXELB)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4069"></A>	 character*(MXSTLN) cname</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4068"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4034"></A>c write element block parameters</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4037"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4045"></A>	 ebid = 10</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4048"></A>	 cname = &quot;SHEL&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4038"></A>	 numelb = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4049"></A>	 numlnk = 4</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4042"></A>	 numatr = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4043"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4050"></A>	 call expelb (idexo, ebid, cname, numelb, numlnk, numatr, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4052"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4053"></A>c fill element connectivity and write it out;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4054"></A>c nodes for first element</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4056"></A>	 connect(1) = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4057"></A>	 connect(2) = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4058"></A>	 connect(3) = 3</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4059"></A>	 connect(4) = 4</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-8427"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-8434"></A>c nodes for second element</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-8428"></A>	 connect(5) = 5</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-8429"></A>	 connect(6) = 6</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-8430"></A>	 connect(7) = 7</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-8431"></A>	 connect(8) = 8</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4060"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4061"></A>	 call expelc (idexo, ebid, connect, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4062"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4063"></A>c write element block attributes</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4064"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3094"></A>	 icnt = 0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4065"></A>	 do 20 i=1,numelb</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4044"></A>		do 10 j=1,numatr</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4903"></A>			 icnt = icnt + 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4066"></A>			 attrib(icnt) = 1.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4046"></A>10		continue</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4047"></A>20	 continue</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4051"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4067"></A>	 call expeat (idexo, ebid, attrib, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1129"></A><A NAME="50334051_28882"></A>Read Element Block Parameters</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1130"></A>The function <EM CLASS="code">
ex_get_elem_block</EM>
 (or <EM CLASS="code">
EXGELB</EM>
 for Fortran) reads the parameters used to describe an <A NAME="50334051_marker-442"></A>element block. IDs of all element blocks stored can be determined by calling <EM CLASS="code">
ex_get_elem_blk_ids</EM>
 (<EM CLASS="code">
EXGEBI</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1131"></A>In case of an error, <EM CLASS="code">
ex_get_elem_block</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGELB</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1132"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2952"></A>element block with specified ID is not stored in the data file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2953"></A>ex_get_elem_block:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1134"></A><EM CLASS="code">
	int ex_get_elem_block (exoid, elem_blk_id, elem_type, num_elem_this_blk, num_nodes_per_elem, num_attr);</EM>
<A NAME="50334051_marker-55"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1135"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2372"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1136"></A><EM CLASS="code">
int elem_blk_id (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2373"></A>The <A NAME="50334051_marker-443"></A>element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1137"></A><EM CLASS="code">
char* elem_type (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2374"></A>Returned <A NAME="50334051_marker-444"></A>type of elements in the element block. The maximum length of this string is <EM CLASS="code">
MAX_STR_LENGTH</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1138"></A><EM CLASS="code">
int* num_elem_this_blk (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2375"></A>Returned number of elements in the element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1139"></A><EM CLASS="code">
int* num_nodes_per_elem (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2376"></A>Returned number of nodes per element in the element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1140"></A><EM CLASS="code">
int* num_attr (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2377"></A>Returned number of <A NAME="50334051_marker-445"></A>attributes per element in the element block.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3236"></A>As an example, the following code segment will read the parameters for the element block with an ID of 10 and read the connectivity and element attributes arrays from an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4607"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3319"></A>int id, error, exoid, num_el_in_blk, num_nod_per_el, num_attr, *connect;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3262"></A>float *attrib;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3243"></A>char elem_type[MAX_STR_LENGTH+1];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3244"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3268"></A>/* read element block parameters */ </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3269"></A>id = 10;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3320"></A>error = ex_get_elem_block (exoid, id, elem_type,</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3238"></A>	&amp;num_el_in_blk, &amp;num_nod_per_elem, &amp;num_attr);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3261"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3281"></A>/* read element connectivity */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3283"></A>connect = (int *) calloc(num_nod_per_el*num_el_in_blk, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3286"></A>error = ex_get_elem_conn (exoid, id, connect);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3306"></A>/* read element block attributes */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3316"></A>attrib = (float *) calloc (num_attr * num_el_in_blk, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3318"></A>error = ex_get_elem_attr (exoid, id, attrib);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1141"></A>EXGELB:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1142"></A><EM CLASS="code">
	SUBROUTINE EXGELB (IDEXO, IDELB, NAMELB, NUMELB, NUMLNK, NUMATR, IERR)</EM>
<A NAME="50334051_marker-56"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1143"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2378"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1144"></A><EM CLASS="code">
INTEGER IDELB (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2379"></A>The <A NAME="50334051_marker-446"></A>element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1145"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMELB (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1146"></A>The <A NAME="50334051_marker-447"></A>type of elements in the element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1147"></A><EM CLASS="code">
INTEGER NUMELB (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2380"></A>Returned number of elements in the element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1148"></A><EM CLASS="code">
INTEGER NUMLNK (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2381"></A>Returned number of nodes per element in the element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1149"></A><EM CLASS="code">
INTEGER NUMATR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2382"></A>Returned number of <A NAME="50334051_marker-448"></A>attributes per element in the element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1150"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2383"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4071"></A>As an example, the following code segment will read the parameters for the element block with an ID of 10 and the connectivity and element attributes arrays associated with that element block:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3241"></A>c NOTE: 		MAXLNK is the maximum number of nodes per element</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4608"></A>c		MAXELB is the maximum number of elements per element block</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4609"></A>c		MAXATR is the maximum number of attributes per element</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4085"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3237"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4084"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4083"></A>	 integer connect(MAXLNK * MAXELB)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4072"></A>	 real attrib(MAXATR * MAXELB)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4081"></A>	 character*(MXSTLN) typ</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4082"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3202"></A>c read element block parameters</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4087"></A>	 id = 10</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4080"></A>	 call exgelb (idexo, id, typ, numelb, numlnk, numatt, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4073"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4074"></A>c read element connectivity</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4075"></A>	 call exgelc (idexo, id, connect, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4076"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4077"></A>c read element block attributes</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4078"></A>	 call exgeat (idexo, id, attrib, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1151"></A><A NAME="50334051_15251"></A>Read Element Blocks IDs </H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1152"></A>The function <EM CLASS="code">
ex_get_elem_blk_ids</EM>
  (or <EM CLASS="code">
EXGEBI</EM>
 for Fortran) reads the IDs of all of the element blocks. Memory must be allocated for the returned array of  (<EM CLASS="code">
num_elem_blk</EM>
) IDs before this function is invoked. The required size (<EM CLASS="code">
num_elem_blk</EM>
) can be determined via a call to <EM CLASS="code">
ex_inquire</EM>
 (or <EM CLASS="code">
EXINQ</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1153"></A>In case of an error, <EM CLASS="code">
ex_get_elem_blk_ids</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGEBI</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1154"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1155"></A>ex_get_elem_blk_ids:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1156"></A><EM CLASS="code">
	int ex_get_elem_blk_ids (exoid, elem_blk_ids);</EM>
<A NAME="50334051_marker-57"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1157"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2384"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1158"></A><EM CLASS="code">
int* elem_blk_ids (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2385"></A>Returned array of the <A NAME="50334051_marker-449"></A>element blocks IDs. The order of the IDs in this array reflects the sequence that the element blocks were introduced into the file.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3239"></A>The following code segment reads all the element block IDs:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3245"></A>int error, exoid, *idelbs, num_elem_blk;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3251"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3250"></A>idelbs = (int *) calloc(num_elem_blk, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3246"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3248"></A>error = ex_get_elem_blk_ids (exoid, idelbs);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1159"></A>EXGEBI:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1160"></A><EM CLASS="code">
	SUBROUTINE EXGEBI (IDEXO, IDELBS, IERR)</EM>
<A NAME="50334051_marker-58"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1161"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2386"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1162"></A><EM CLASS="code">
INTEGER IDELBS(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2387"></A>Returned array of element blocks IDs. The order of the IDs in this array reflects the sequence that the element blocks were introduced into the file.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1163"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2388"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4090"></A>The following code segment reads all the element block IDs:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4611"></A>c NOTE: 		MAXEBL is the maximum number of element blocks</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4612"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4092"></A>	 integer idelbs(MAXEBL)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4091"></A>	 call exgebi (idexo, idelbs, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1164"></A><A NAME="50334051_34365"></A>Write Element Block Connectivity</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1165"></A>The function <EM CLASS="code">
ex_put_elem_conn</EM>
 (or <EM CLASS="code">
EXPELC</EM>
 for Fortran) writes the <A NAME="50334051_marker-451"></A>connectivity array for an element block.  The function <EM CLASS="code">
ex_put_elem_block</EM>
 (<EM CLASS="code">
EXPELB</EM>
 for Fortran) must be invoked before this call is made.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1166"></A>In case of an error, <EM CLASS="code">
ex_put_elem_conn</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPELC</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1168"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1083"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1169"></A><EM CLASS="code">
ex_put_elem_block</EM>
 was not called previously.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1170"></A>ex_put_elem_conn:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1171"></A><EM CLASS="code">
	int ex_put_elem_conn (exoid, elem_blk_id, connect);</EM>
<A NAME="50334051_marker-59"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1172"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2389"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1173"></A><EM CLASS="code">
int elem_blk_id (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2390"></A>The element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1174"></A><EM CLASS="code">
int connect[num_elem_this_blk,num_nodes_per_elem] (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2391"></A>The connectivity array;  a list of nodes (internal node IDs; see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>) that define each element in the element block. The node index cycles faster than the element index.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3366"></A>Refer to the description of <EM CLASS="code">
ex_put_elem_block</EM>
 <EM CLASS="code">
(EXPELB </EM>
for Fortran<EM CLASS="code">
) </EM>
for an example of a code segment that writes out the connectivity array for an element block.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1175"></A>EXPELC:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1176"></A><EM CLASS="code">
	SUBROUTINE EXPELC (IDEXO, IDELB, LINK, IERR)</EM>
<A NAME="50334051_marker-60"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1177"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2392"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1178"></A><EM CLASS="code">
INTEGER IDELB (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2393"></A>The element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1179"></A><EM CLASS="code">
INTEGER LINK(NUMLNK,NUMELB) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2394"></A>The connectivity array;  a list of nodes (internal node IDs; see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>) that define each element. The node index cycles faster than the element index.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1180"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2395"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1184"></A>Refer to the description of <EM CLASS="code">
ex_put_elem_block</EM>
 <EM CLASS="code">
(EXPELB </EM>
for Fortran<EM CLASS="code">
) </EM>
for an example of a code segment that writes out the connectivity array for an element block.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1181"></A><A NAME="50334051_17436"></A>Read Element Block Connectivity</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1182"></A>The function <EM CLASS="code">
ex_get_elem_conn</EM>
 (or <EM CLASS="code">
EXGELC</EM>
 for Fortran) reads the <A NAME="50334051_marker-452"></A>connectivity array for an element block.  Memory must be allocated for the connectivity array (<EM CLASS="code">
num_elem_this_blk</EM>
 * <EM CLASS="code">
num_nodes_per_elem</EM>
 in length) before this routine is called.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1183"></A>In case of an error, <EM CLASS="code">
ex_get_elem_conn</EM>
 returns a negative number; a warning will return a positive number.  EXGELC returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1133"></A>an element block with the specified ID is not stored in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1185"></A>ex_get_elem_conn:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1186"></A><EM CLASS="code">
	int ex_get_elem_conn (exoid, elem_blk_id, connect);</EM>
<A NAME="50334051_marker-61"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1187"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2396"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1188"></A><EM CLASS="code">
int elem_blk_id (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2397"></A>The element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1189"></A><EM CLASS="code">
int connect[num_elem_this_blk,num_nodes_per_elem] (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2398"></A>Returned connectivity array;  a list of nodes (internal node IDs; see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>) that define each element. The node index cycles faster than the element index.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3271"></A>For an example of a code segment that reads the connectivity for an element block, refer to the description of <EM CLASS="code">
ex_get_elem_block.</EM>
</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1190"></A>EXGELC:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1191"></A><EM CLASS="code">
	SUBROUTINE EXGELC (IDEXO, IDELB, LINK, IERR)</EM>
<A NAME="50334051_marker-62"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1192"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2399"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1193"></A><EM CLASS="code">
INTEGER IDELB (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2400"></A>The element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1194"></A><EM CLASS="code">
INTEGER LINK(NUMLNK,NUMELB) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2401"></A>Returned connectivity array;  a list of nodes (internal node IDs; see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>) that define each element. The node index cycles faster than the element index.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1195"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2402"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1318"></A>For an example of a code segment that reads the connectivity for an element block, refer to the description of<EM CLASS="code">
 EXGELB.</EM>
</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1196"></A><A NAME="50334051_42312"></A>Write Element Block Attributes</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1197"></A>The function <EM CLASS="code">
ex_put_elem_attr</EM>
 (or <EM CLASS="code">
EXPEAT</EM>
 for Fortran) writes the <A NAME="50334051_marker-453"></A>attributes for an element block. Each element in the element block must have the same number of attributes, so there are (<EM CLASS="code">
num_attr</EM>
 * <EM CLASS="code">
num_elem_this_blk</EM>
) attributes for each element block. The function <EM CLASS="code">
ex_put_elem_block</EM>
 (<EM CLASS="code">
EXPELB</EM>
 for Fortran) must be invoked before this call is made.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1198"></A>Because the attributes are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1199"></A>In case of an error, <EM CLASS="code">
ex_put_elem_attr</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPEAT</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1200"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1201"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2926"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1202"></A><EM CLASS="code">
ex_put_elem_block</EM>
 was not called previously for specified element block ID.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2955"></A><EM CLASS="code">
ex_put_elem_block</EM>
 was called with 0 attributes specified.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1204"></A>ex_put_elem_attr:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1205"></A><EM CLASS="code">
	int ex_put_elem_attr (exoid, elem_blk_id, attrib);</EM>
<A NAME="50334051_marker-63"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1206"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2403"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1207"></A><EM CLASS="code">
int elem_blk_id (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2404"></A>The element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1208"></A><EM CLASS="code">
void attrib</EM>
[ <EM CLASS="code">
num_elem_this_blk,num_attr</EM>
]<EM CLASS="code">
 (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2405"></A>The list of attributes for the element block. The <EM CLASS="code">
num_attr</EM>
 index cycles faster.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3249"></A>Refer to the description of <EM CLASS="code">
ex_put_elem_block</EM>
 for an example of a code segment that writes out the attributes array for an element block.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1209"></A>EXPEAT:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1210"></A><EM CLASS="code">
	SUBROUTINE EXPEAT (IDEXO, IDELB, ATRIB, IERR)</EM>
<A NAME="50334051_marker-64"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1211"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2406"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1212"></A><EM CLASS="code">
INTEGER IDELB (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2407"></A>The element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1213"></A><EM CLASS="code">
REAL ATRIB</EM>
(<EM CLASS="code">
NUMATR</EM>
,<EM CLASS="code">
NUMELB</EM>
)<EM CLASS="code">
 (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2408"></A>The list of attributes for the element block. The <EM CLASS="code">
NUMATR</EM>
 index cycles faster.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1214"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2409"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4095"></A>Refer to the description of <EM CLASS="code">
EXPELB</EM>
 for an example of a code segment that writes out the attributes array for an element block.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1215"></A><A NAME="50334051_16035"></A>Read Element Block Attributes</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1216"></A>The function <EM CLASS="code">
ex_get_elem_attr</EM>
 (or <EM CLASS="code">
EXGEAT</EM>
 for Fortran) reads the <A NAME="50334051_marker-454"></A>attributes for an element block.  Memory must be allocated for (<EM CLASS="code">
num_attr</EM>
 * <EM CLASS="code">
num_elem_this_blk</EM>
) attributes before this routine is called.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1217"></A>Because the attributes are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1218"></A>In case of an error, <EM CLASS="code">
ex_get_elem_attr</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGEAT</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1219"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2954"></A>invalid element block ID.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2956"></A>a warning value is returned if no attributes are stored in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1220"></A>ex_get_elem_attr:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1221"></A><EM CLASS="code">
	int ex_get_elem_attr (exoid, elem_blk_id, attrib);</EM>
<A NAME="50334051_marker-65"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1222"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2410"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1223"></A><EM CLASS="code">
int elem_blk_id (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2411"></A>The element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1224"></A><EM CLASS="code">
void attrib</EM>
[ <EM CLASS="code">
num_elem_this_blk,num_attr</EM>
]<EM CLASS="code">
 (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2412"></A>Returned list of (<EM CLASS="code">
num_attr</EM>
 * <EM CLASS="code">
num_elem_this_blk</EM>
) attributes for the element block, with the <EM CLASS="code">
num_attr</EM>
 index cycling faster.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3287"></A>For an example of a code segment that reads the element attributes for an element block, refer to the description of <EM CLASS="code">
ex_get_elem_block.</EM>
</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1225"></A>EXGEAT:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1226"></A><EM CLASS="code">
	SUBROUTINE EXGEAT (IDEXO, IDELB, ATRIB, IERR)</EM>
<A NAME="50334051_marker-66"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1227"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2413"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1228"></A><EM CLASS="code">
INTEGER IDELB (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2414"></A>The element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1229"></A><EM CLASS="code">
REAL ATRIB</EM>
(<EM CLASS="code">
NUMATR</EM>
,<EM CLASS="code">
NUMELB</EM>
)<EM CLASS="code">
 (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2415"></A>Returned list of (<EM CLASS="code">
NUMATR</EM>
*<EM CLASS="code">
NUMELB</EM>
) attributes for the element block, with the <EM CLASS="code">
NUMATR</EM>
 index cycling faster.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1230"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2416"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4096"></A>For an example of a code segment that reads the element attributes for an element block, refer to the description of <EM CLASS="code">
EXGELB.</EM>
</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1231"></A><A NAME="50334051_17372"></A>Write Node Set Parameters</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1232"></A>The function <EM CLASS="code">
ex_put_node_set_param</EM>
 (or <EM CLASS="code">
EXPNP</EM>
 for Fortran) writes the <A NAME="50334051_marker-455"></A>node set ID, the number of nodes which describe a single node set, and the number of <A NAME="50334051_marker-456"></A>distribution factors for the node set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1233"></A>In case of an error, <EM CLASS="code">
ex_put_node_set_param</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPNP</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1234"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1235"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2928"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2959"></A>the number of node sets specified in the call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran) was zero or has been exceeded.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2958"></A>a node set with the same ID has already been stored.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2957"></A>the specified number of distribution factors is not zero and is not equal to the number of nodes.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1236"></A>ex_put_node_set_param:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1237"></A><EM CLASS="code">
	int ex_put_node_set_param (exoid, node_set_id, num_nodes_in_set, num_dist_in_set);</EM>
<A NAME="50334051_marker-67"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1238"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2417"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1239"></A><EM CLASS="code">
int node_set_id (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2418"></A>The node set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1240"></A><EM CLASS="code">
int num_nodes_in_set (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2419"></A>The number of nodes in the node set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1241"></A><EM CLASS="code">
int num_dist_in_set (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2420"></A>The number of distribution factors in the node set. This should be either 0 (zero) for no factors, or should equal <EM CLASS="code">
num_nodes_in_set</EM>
.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3322"></A>The following code segment will write out a node set to an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3323"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4613"></A>int id, num_nodes_in_set, num_dist_in_set, error, exoid, *node_list;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3361"></A>float *dist_fact;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3362"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3359"></A>/* write node set parameters */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3338"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3348"></A>id = 20; num_nodes_in_set = 5; num_dist_in_set = 5; </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3352"></A>error = ex_put_node_set_param (exoid, id, num_nodes_in_set, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3255"></A>		num_dist_in_set);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3346"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-9793"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3349"></A>/* write node set node list */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3350"></A>node_list = (int *) calloc (num_nodes_in_set, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3356"></A>node_list[0] = 100; node_list[1] = 101; node_list[2] = 102;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3340"></A>node_list[3] = 103; node_list[4] = 104;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3344"></A>error = ex_put_node_set (exoid, id, node_list);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3347"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3351"></A>/* write node set distribution factors */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3341"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3357"></A>dist_fact = (float *) calloc (num_dist_in_set, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3342"></A>dist_fact[0] = 1.0; dist_fact[1] = 2.0; dist_fact[2] = 3.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3343"></A>dist_fact[3] = 4.0; dist_fact[4] = 5.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3345"></A>error = ex_put_node_set_dist_fact (exoid, id, dist_fact);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1242"></A>EXPNP:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1243"></A><EM CLASS="code">
	SUBROUTINE EXPNP (IDEXO, IDNPS, NNNPS, NDNPS, IERR)</EM>
<A NAME="50334051_marker-68"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1244"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2421"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1245"></A><EM CLASS="code">
INTEGER IDNPS (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2422"></A>The node set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1246"></A><EM CLASS="code">
INTEGER NNNPS (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2423"></A>The number of nodes in the node set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1247"></A><EM CLASS="code">
INTEGER NDNPS (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2424"></A>The number of distribution factors in the node set. This should be either 0 (zero) for no factors, or should equal <EM CLASS="code">
NNNPS</EM>
. </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1248"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2425"></A>Returned error code.  If no errors occurred, 0 is returned. </P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4097"></A>The following code segment will write out a node set to an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4094"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3339"></A>	 integer node_list(5)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3354"></A>	 real dist_fact(5)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3353"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4098"></A>c write a single node set</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4099"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4101"></A>	 call expnp (idexo, 20, 4, 4, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4102"></A>	 node_list(1) = 100</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4103"></A>	 node_list(2) = 101</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4104"></A>	 node_list(3) = 102</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4105"></A>	 node_list(4) = 103</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4107"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4108"></A>	 dist_fact(1) = 1.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4109"></A>	 dist_fact(2) = 2.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4110"></A>	 dist_fact(3) = 3.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4111"></A>	 dist_fact(4) = 4.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4113"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4114"></A>	 call expns (idexo, 20, node_list, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4116"></A>	 call expnsd (idexo, 20, dist_fact, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1249"></A><A NAME="50334051_25184"></A>Read Node Set Parameters</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1250"></A>The function <EM CLASS="code">
ex_get_node_set_param</EM>
 (or <EM CLASS="code">
EXGNP</EM>
 for Fortran) reads the number of nodes which describe a single <A NAME="50334051_marker-457"></A>node set and the number of <A NAME="50334051_marker-458"></A>distribution factors for the node set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1251"></A>In case of an error, <EM CLASS="code">
ex_get_node_set_param</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGNP</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1252"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2960"></A>a warning value is returned if no node sets are stored in the file.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2961"></A>incorrect node set ID.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1253"></A>ex_get_node_set_param:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1254"></A><EM CLASS="code">
	int ex_get_node_set_param (exoid, node_set_id, num_nodes_in_set, num_dist_in_set);</EM>
<A NAME="50334051_marker-69"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1255"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2426"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1256"></A><EM CLASS="code">
int node_set_id (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2427"></A>The node set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1257"></A><EM CLASS="code">
int* num_nodes_in_set (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2428"></A>Returned number of nodes in the node set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1258"></A><EM CLASS="code">
int* num_dist_in_set (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2429"></A>Returned number of distribution factors in the node set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3273"></A>The following code segment will read a node set from an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3274"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4614"></A>int error, exoid, id, num_nodes_in_set, num_df_in_set, *node_list;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3303"></A>float *dist_fact;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3304"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3301"></A>/* read node set parameters */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3275"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3305"></A>id = 100;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3294"></A>error = ex_get_node_set_param (exoid, id, &amp;num_nodes_in_set, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3277"></A>		&amp;num_df_in_set);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3300"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3291"></A>/* read node set node list */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3289"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3295"></A>node_list = (int *) calloc(num_nodes_in_set, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3280"></A>error = ex_get_node_set (exoid, id, node_list);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3292"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3299"></A>/* read node set distribution factors */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3288"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3298"></A>if (num_df_in_set &gt; 0) {</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3296"></A>	dist_fact = (float *) 		calloc(num_nodes_in_set, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3290"></A>	error = ex_get_node_set_dist_fact (exoid, id, dist_fact); }</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1259"></A>EXGNP:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1260"></A><EM CLASS="code">
	SUBROUTINE EXGNP (IDEXO, IDNPS, NNNPS, NDNPS, IERR)</EM>
<A NAME="50334051_marker-70"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1261"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2430"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1262"></A><EM CLASS="code">
INTEGER IDNPS (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2431"></A>The node set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1263"></A><EM CLASS="code">
INTEGER NNNPS (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2432"></A>Returned number of nodes in the node set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1264"></A><EM CLASS="code">
INTEGER NDNPS (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2433"></A>Returned number of distribution factors in the node set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1265"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2434"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4106"></A>The following code segment will read all node sets from an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4100"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3278"></A>c NOTE:		MAXNS is the maximum number of node sets</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3279"></A>c		MAXNOD is the maximum number of nodes in a node set</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3297"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4126"></A>	 integer ids(MAXNS), node_list(MAXNOD)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4123"></A>	 real dist_fact(MAXNOD)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4128"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4112"></A>c read individual node sets</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4115"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4117"></A>	 if (num_node_sets .gt. 0) then</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4118"></A>		call exgnsi (idexo, ids, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4120"></A>	 endif</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4121"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4122"></A>	 do 100 i = 1, num_node_sets</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4124"></A>		call exgnp (idexo, ids(i), nnnps, numdf, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4131"></A>		call exgns (idexo, ids(i), node_list, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4133"></A>		call exgnsd (idexo, ids(i), dist_fact, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4119"></A>100	 continue</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1266"></A><A NAME="50334051_10725"></A>Write Node Set</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1267"></A>The function <EM CLASS="code">
ex_put_node_set</EM>
 (or <EM CLASS="code">
EXPNS</EM>
 for Fortran) writes the node list for a single <A NAME="50334051_marker-459"></A>node set.  The function <EM CLASS="code">
ex_put_node_set_param</EM>
 (or <EM CLASS="code">
EXPNP</EM>
 for Fortran) must be called before this routine is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1268"></A>In case of an error, <EM CLASS="code">
ex_put_node_set</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPNS</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1269"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1270"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2929"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2962"></A><EM CLASS="code">
ex_put_node_set_param</EM>
 (or <EM CLASS="code">
EXPNP</EM>
 for Fortran) not called previously.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1271"></A>ex_put_node_set:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1272"></A><EM CLASS="code">
	int ex_put_node_set (exoid, node_set_id, node_set_node_list);</EM>
<A NAME="50334051_marker-71"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1273"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2435"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1274"></A><EM CLASS="code">
int node_set_id (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2436"></A>The node set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1275"></A><EM CLASS="code">
int* node_set_node_list (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2437"></A>Array containing the node list for the node set. Internal node IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3267"></A>Refer to the description of <EM CLASS="code">
ex_put_node_set_param</EM>
 for a sample code segment to write out a node set.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1276"></A>EXPNS:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1277"></A><EM CLASS="code">
	SUBROUTINE EXPNS (IDEXO, IDNPS, LTNNPS, IERR)</EM>
<A NAME="50334051_marker-72"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1278"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2438"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1279"></A><EM CLASS="code">
INTEGER IDNPS (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2439"></A>The node set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1280"></A><EM CLASS="code">
INTEGER LTNNPS(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2440"></A>Array containing the node list for the node set. Internal node IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1281"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2441"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4127"></A>Refer to the description of <EM CLASS="code">
EXPNP</EM>
 for a sample code segment to write out a node set.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1282"></A><A NAME="50334051_33368"></A>Read Node Set</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1283"></A>The function <EM CLASS="code">
ex_get_node_set</EM>
 (or <EM CLASS="code">
EXGNS</EM>
 for Fortran) reads the node list for a single <A NAME="50334051_marker-460"></A>node set.  Memory must be allocated for the node list (<EM CLASS="code">
num_nodes_in_set</EM>
 in length) before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1284"></A>In case of an error, <EM CLASS="code">
ex_get_node_set</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGNS</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1285"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2963"></A>a warning value is returned if no node sets are stored in the file.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2964"></A>incorrect node set ID.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1286"></A>ex_get_node_set:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1287"></A><EM CLASS="code">
	int ex_get_node_set (exoid, node_set_id, node_set_node_list);</EM>
<A NAME="50334051_marker-73"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1288"></A><EM CLASS="code">
int exoid (R)	</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2442"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1289"></A><EM CLASS="code">
int node_set_id (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2443"></A>The node set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1290"></A><EM CLASS="code">
int* node_set_node_list (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2444"></A>Returned array containing the node list for the node set. Internal node IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3324"></A>Refer to the description of <EM CLASS="code">
ex_get_node_set_param</EM>
 for a sample code segment to read a node set.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1291"></A>EXGNS:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1292"></A><EM CLASS="code">
	SUBROUTINE EXGNS (IDEXO, IDNPS, LTNNPS, IERR)</EM>
<A NAME="50334051_marker-74"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1293"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1294"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1295"></A><EM CLASS="code">
INTEGER IDNPS (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1296"></A>The node set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2445"></A><EM CLASS="code">
INTEGER LTNNPS(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2446"></A>Returned array containing the node list for the node set. Internal node IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2447"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2448"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4129"></A>Refer to the description of <EM CLASS="code">
EXGNP</EM>
 for a sample code segment to read a node set.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1297"></A><A NAME="50334051_30340"></A>Write Node Set Distribution Factors</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1298"></A>The function <EM CLASS="code">
ex_put_node_set_dist_fact</EM>
 (or <EM CLASS="code">
EXPNSD</EM>
 for Fortran) writes <A NAME="50334051_marker-461"></A>distribution factors for a single node set. The function <EM CLASS="code">
ex_put_node_set_param</EM>
 (or <EM CLASS="code">
EXPNP</EM>
 for Fortran) must be called before this routine is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1299"></A>Because the distribution factors are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1300"></A>In case of an error, <EM CLASS="code">
ex_put_node_set_dist_fact</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPNSD</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1301"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1302"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2930"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2966"></A><EM CLASS="code">
ex_put_node_set_param</EM>
 (or <EM CLASS="code">
EXPNP</EM>
 for Fortran) not called previously.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2965"></A>a call to <EM CLASS="code">
ex_put_node_set_param</EM>
 (or <EM CLASS="code">
EXPNP</EM>
 for Fortran) specified zero distribution factors.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1303"></A>ex_put_node_set_dist_fact:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1304"></A><EM CLASS="code">
	int ex_put_node_set_dist_fact (exoid, node_set_id, node_set_dist_fact);</EM>
<A NAME="50334051_marker-75"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1305"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2449"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1306"></A><EM CLASS="code">
int node_set_id (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2450"></A>The node set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1307"></A><EM CLASS="code">
void* node_set_dist_fact (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2451"></A>Array containing the distribution factors in the node set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3272"></A>Refer to the description of <EM CLASS="code">
ex_put_node_set_param</EM>
 for a sample code segment to write out the distribution factors for a node set.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1308"></A>EXPNSD:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1309"></A><EM CLASS="code">
	SUBROUTINE EXPNSD (IDEXO, IDNPS, FACNPS, IERR)</EM>
<A NAME="50334051_marker-76"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1310"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2452"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1311"></A><EM CLASS="code">
INTEGER IDNPS (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2453"></A>The node set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1312"></A><EM CLASS="code">
REAL FACNPS(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2454"></A>Array containing the distribution factors in the node set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1313"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2455"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4130"></A>Refer to the description of <EM CLASS="code">
EXPNP</EM>
 for a sample code segment to write out the distribution factors for a node set.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1314"></A><A NAME="50334051_37354"></A>Read Node Set Distribution Factors</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1315"></A>The function <EM CLASS="code">
ex_get_node_set_dist_fact</EM>
 (or <EM CLASS="code">
EXGNSD</EM>
 for Fortran) returns the <A NAME="50334051_marker-462"></A>distribution factors for a single node set. Memory must be allocated for the list of distribution factors (<EM CLASS="code">
num_dist_in_set</EM>
 in length) before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1316"></A>Because the distribution factors are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1317"></A>In case of an error, <EM CLASS="code">
ex_get_node_set_dist_fact</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGNSD</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2967"></A>a warning value is returned if no distribution factors were stored.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1319"></A>ex_get_node_set_dist_fact:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1320"></A><EM CLASS="code">
	int ex_get_node_set_dist_fact (exoid, node_set_id, node_set_dist_fact);</EM>
<A NAME="50334051_marker-77"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1321"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2456"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1322"></A><EM CLASS="code">
int node_set_id (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2457"></A>The node set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1323"></A><EM CLASS="code">
void* node_set_dist_fact (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2459"></A>Returned array containing the distribution factors in the node set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3325"></A>Refer to the description of <EM CLASS="code">
ex_get_node_set_param</EM>
 for a sample code segment to read a node set's distribution factors.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1324"></A>EXGNSD:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1325"></A><EM CLASS="code">
	SUBROUTINE EXGNSD (IDEXO, IDNPS, FACNPS, IERR)</EM>
<A NAME="50334051_marker-78"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1326"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2458"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1327"></A><EM CLASS="code">
INTEGER IDNPS (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2460"></A>The node set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1328"></A><EM CLASS="code">
REAL FACNPS(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2461"></A>Returned array containing the distribution factors in the node set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1329"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2462"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4132"></A>Refer to the description of <EM CLASS="code">
EXGNP</EM>
 for a sample code segment to read a node set's distribution factors.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1330"></A><A NAME="50334051_34277"></A>Read Node Sets IDs </H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1331"></A>The function <EM CLASS="code">
ex_get_node_set_ids</EM>
  (or <EM CLASS="code">
EXGNSI</EM>
 for Fortran) reads the IDs of all of the node sets. Memory must be allocated for the returned array of  (<EM CLASS="code">
num_node_sets</EM>
) IDs before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1332"></A>In case of an error, <EM CLASS="code">
ex_get_node_set_ids</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGNSI</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1333"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2968"></A>a warning value is returned if no node sets are stored in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1334"></A>ex_get_node_set_ids:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1335"></A><EM CLASS="code">
	int ex_get_node_set_ids (exoid, node_set_ids);</EM>
<A NAME="50334051_marker-79"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1336"></A><EM CLASS="code">
int exoid (R)	</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2463"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1337"></A><EM CLASS="code">
int</EM>
<EM CLASS="Bold">
* node_set_ids (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2464"></A>Returned array of the <A NAME="50334051_marker-463"></A>node sets IDs. The order of the IDs in this array reflects the sequence the node sets were introduced into the file.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3326"></A>As an example, the following code will read all of the node set IDs from an open data file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3333"></A>int *ids, num_node_sets, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3332"></A>/* read node sets IDs */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3329"></A>ids = (int *) calloc(num_node_sets, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3331"></A>error = ex_get_node_set_ids (exoid, ids);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1338"></A>EXGNSI:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1339"></A><EM CLASS="code">
	SUBROUTINE EXGNSI (IDEXO, IDNPSS, IERR)</EM>
<A NAME="50334051_marker-80"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1340"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2465"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1341"></A><EM CLASS="code">
INTEGER IDNPSS(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2466"></A>Returned array of node sets IDs. The order of the IDs in this array reflects the sequence the node sets were introduced into the file.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1342"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2467"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4125"></A>As an example, the following code will read all of the node set IDs from an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4134"></A>	 integer ids(MAXNS)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-1167"></A>	 if (num_node_sets .gt. 0) then</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4135"></A>		call exgnsi (idexo, ids, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4137"></A>	 endif</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1343"></A><A NAME="50334051_39090"></A>Write <A NAME="50334051_marker-464"></A>Concatenated Node Sets</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1344"></A>The function <EM CLASS="code">
ex_put_concat_node_sets</EM>
 (or <EM CLASS="code">
EXPCNS</EM>
 for Fortran) writes the node set ID's, node sets node count array, node sets distribution factor count array, node sets node list pointers array, node sets distribution factor pointer, node set node list, and node set distribution factors for all of the node sets.  &quot;Concatenated node sets&quot; refers to the arrays required to define all of the node sets (ID array, counts arrays, pointers arrays, node list array, and distribution factors array) as described in <A HREF="exodusII.book.html#50334051_17183" CLASS="XRef">See Concatenated Node Sets</A>. Writing concatenated node sets is more efficient than writing individual node sets. See Appendix A for a discussion of efficiency issues.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1345"></A>Because the distribution factors are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1346"></A>In case of an error, <EM CLASS="code">
ex_put_concat_node_sets</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPCNS</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1347"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1348"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2931"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2969"></A>the number of node sets specified in a call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran) was zero or has been exceeded.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2970"></A>a node set with the same ID has already been stored.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2971"></A>the number of distribution factors specified for one of the node sets is not zero and is not equal to the number of nodes in the same node set.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1349"></A>ex_put_concat_node_sets:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1350"></A><EM CLASS="code">
	int ex_put_concat_node_sets (exoid, node_set_ids, num_nodes_per_set, num_dist_per_set, node_sets_node_index, node_sets_dist_index, node_sets_node_list, node_sets_dist_fact);</EM>
<A NAME="50334051_marker-81"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1351"></A><EM CLASS="code">
int exoid (R)	</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2468"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1352"></A><EM CLASS="code">
int* node_set_ids (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2469"></A>Array containing the node set ID for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1353"></A><EM CLASS="code">
int* num_nodes_per_set (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2470"></A>Array containing the number of nodes for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1354"></A><EM CLASS="code">
int* num_dist_per_set (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2471"></A>Array containing the number of distribution factors for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1355"></A><EM CLASS="code">
int* node_sets_node_index (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2472"></A>Array containing the indices into the <EM CLASS="code">
node_set_node_list</EM>
 which are the locations of the first node for each set. These indices are 0-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1356"></A><EM CLASS="code">
int* node_sets_dist_index (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2473"></A>Array containing the indices into the <EM CLASS="code">
node_set_dist_list</EM>
 which are the locations of the first distribution factor for each set. These indices are 0-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1357"></A><EM CLASS="code">
int* node_sets_node_list (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2474"></A>Array containing the nodes for all sets. Internal node IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1358"></A><EM CLASS="code">
void* node_sets_dist_fact (R)	</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2475"></A>Array containing the distribution factors for all sets.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3334"></A>For example, the following code will write out two node sets in a concatenated format:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3335"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3337"></A>int ids[2], num_nodes_per_set[2], node_ind[2], node_list[8],</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3389"></A>		num_df_per_set[2], df_ind[2], error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3390"></A>float dist_fact[8];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3391"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3336"></A>ids[0] = 20; ids[1] = 21;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3364"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3365"></A>num_nodes_per_set[0] = 5; num_nodes_per_set[1] = 3;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3370"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3371"></A>node_ind[0] = 0; node_ind[1] = 5;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3372"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3373"></A>node_list[0] = 100; node_list[1] = 101; node_list[2] = 102;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3374"></A>node_list[3] = 103; node_list[4] = 104;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3375"></A>node_list[5] = 200; node_list[6] = 201; node_list[7] = 202;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3376"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3377"></A>num_df_per_set[0] = 5; num_df_per_set[1] = 3;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3378"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3379"></A>df_ind[0] = 0; df_ind[1] = 5;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3380"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3381"></A>dist_fact[0] = 1.0; dist_fact[1] = 2.0; dist_fact[2] = 3.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3382"></A>dist_fact[3] = 4.0; dist_fact[4] = 5.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3383"></A>dist_fact[5] = 1.1; dist_fact[6] = 2.1; dist_fact[7] = 3.1;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3384"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3385"></A>error = ex_put_concat_node_sets (exoid, ids, num_nodes_per_set, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3284"></A>		num_df_per_set, node_ind, df_ind, node_list, dist_fact);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1359"></A>EXPCNS:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1360"></A><EM CLASS="code">
	SUBROUTINE EXPCNS (IDEXO, IDNPSS, NNNPS, NDNPS, IXNNPS, IXDNPS, LTNNPS, FACNPS, IERR)</EM>
<A NAME="50334051_marker-82"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1361"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2476"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1362"></A><EM CLASS="code">
INTEGER IDNPSS(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2477"></A>Array containing the node set ID for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1363"></A><EM CLASS="code">
INTEGER NNNPS(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2478"></A>Array containing the number of nodes for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1364"></A><EM CLASS="code">
INTEGER NDNPS(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2479"></A>Array containing the number of distribution factors for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1365"></A><EM CLASS="code">
INTEGER IXNNPS(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2480"></A>Array containing the indices into the <EM CLASS="code">
LTNNPS</EM>
 array which are the locations of the first node for each set. These indices are 1-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1366"></A><EM CLASS="code">
INTEGER IXDNPS(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2481"></A>Array containing the indices into the <EM CLASS="code">
FACNPS</EM>
 array which are the locations of the first distribution factor for each set. These indices are 1-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1367"></A><EM CLASS="code">
INTEGER LTNNPS(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2482"></A>Array containing the nodes for all sets. Internal node IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1368"></A><EM CLASS="code">
REAL FACNPS(*) (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2483"></A>Array containing the distribution factors for all sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1369"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2484"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3330"></A>For example, the following code writes out two node sets in a concatenated format:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3328"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4136"></A>	 integer ids(2), nnnps(2), ndnps(2), nodeind(2), factind(2)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-9467"></A>	 integer nodelist(8), distfact(8)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4140"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4141"></A>	 ids(1) = 20</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4142"></A>	 ids(2) = 21</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4143"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4144"></A>	 nnnps(1) = 5</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4145"></A>	 nnnps(2) = 3</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4146"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-9469"></A>	 ndnps(1) = 5</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-9470"></A>	 ndnps(2) = 3</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-9471"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4147"></A>	 nodeind(1) = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4148"></A>	 nodeind(2) = 6</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-9472"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-9473"></A>	 factind(1) = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-9474"></A>	 factind(2) = 6</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4149"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4150"></A>	 nodelist(1) = 100</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4151"></A>	 nodelist(2) = 101</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4152"></A>	 nodelist(3) = 102</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4153"></A>	 nodelist(4) = 103</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4154"></A>	 nodelist(5) = 104</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4155"></A>	 nodelist(6) = 200</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4156"></A>	 nodelist(7) = 201</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4157"></A>	 nodelist(8) = 202</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4158"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-9475"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4159"></A>	 distfact(1) = 1.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4160"></A>	 distfact(2) = 2.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4161"></A>	 distfact(3) = 3.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4162"></A>	 distfact(4) = 4.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4163"></A>	 distfact(5) = 5.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4164"></A>	 distfact(6) = 1.1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4165"></A>	 distfact(7) = 2.1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4166"></A>	 distfact(8) = 3.1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4167"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4168"></A>	 call expcns (idexo, ids, nnnps, ndnps, nodeind, factind, nodelist,</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-9476"></A>	1 distfact, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1370"></A><A NAME="50334051_31865"></A>Read <A NAME="50334051_marker-465"></A>Concatenated Node Sets</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1371"></A>The function <EM CLASS="code">
ex_get_concat_node_sets</EM>
 (or <EM CLASS="code">
EXGCNS</EM>
 for Fortran) reads the node set ID's, node set node count array, node set distribution factors count array, node set node pointers array, node set distribution factors pointer array, node set node list, and node set distribution factors for all of the node sets.  &quot;Concatenated node sets&quot; refers to the arrays required to define all of the node sets (ID array, counts arrays, pointers arrays, node list array, and distribution factors array) as described in <A HREF="exodusII.book.html#50334051_17183" CLASS="XRef">See Concatenated Node Sets</A>.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1372"></A>Because the distribution factors are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1373"></A>The length of each of the returned arrays can be determined by invoking <EM CLASS="code">
ex_inquire</EM>
 (or <EM CLASS="code">
EXINQ</EM>
 for Fortran). See <A HREF="exodusII.book.html#50334051_23612" CLASS="XRef">See Inquire EXODUS Parameters</A>.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1374"></A>In case of an error, <EM CLASS="code">
ex_get_concat_node_sets</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGCNS</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1375"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2972"></A>a warning value is returned if no node sets are stored in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1376"></A>ex_get_concat_node_sets:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1377"></A><EM CLASS="code">
	int ex_get_concat_node_sets (exoid,  node_set_ids, num_nodes_per_set, num_dist_per_set, node_sets_node_index, node_sets_dist_index, node_sets_node_list, node_sets_dist_fact);</EM>
<A NAME="50334051_marker-83"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1378"></A><EM CLASS="code">
int exoid (R)	</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2485"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1379"></A><EM CLASS="code">
int* node_set_ids (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2486"></A>Returned array containing the node set ID for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1380"></A><EM CLASS="code">
int* num_nodes_per_set (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2487"></A>Returned array containing the number of nodes for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1381"></A><EM CLASS="code">
int* num_dist_per_set (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2488"></A>Returned array containing the number of distribution factors for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1382"></A><EM CLASS="code">
int* node_sets_node index (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2489"></A>Returned array containing the indices into the <EM CLASS="code">
node_set_node_list</EM>
 which are the locations of the first node for each set. These indices are 0-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1383"></A><EM CLASS="code">
int* node_sets_dist_index (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2490"></A>Returned array containing the indices into the <EM CLASS="code">
node_set_dist_fact</EM>
 which are the locations of the first distribution factor for each set. These indices are 0-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1384"></A><EM CLASS="code">
int* node_sets_node_list (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2491"></A>Returned array containing the nodes for all sets. Internal node IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1385"></A><EM CLASS="code">
void* node_sets_dist_fact (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2492"></A>Returned array containing the distribution factors for all sets.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3386"></A>As an example, the following code segment will read concatenated node sets:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3392"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3363"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3394"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3397"></A>int error, exoid, num_node_sets, list_len, *ids, *num_nodes_per_set, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3302"></A>	*num_df_per_set, *node_ind, *df_ind, *node_list;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3406"></A>float *dist_fact</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3407"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3393"></A>/* read concatenated node sets */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3395"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3396"></A>error = ex_inquire (exoid, EX_INQ_NODE_SETS, &amp;num_node_sets, &amp;fdum, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3311"></A>		cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3398"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3399"></A>ids = (int *) calloc(num_node_sets, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3419"></A>num_nodes_per_set = (int *) calloc(num_node_sets, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3420"></A>num_df_per_set = (int *) calloc(num_node_sets, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3402"></A>node_ind = (int *) calloc(num_node_sets, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3403"></A>df_ind = (int *) calloc(num_node_sets, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3404"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3317"></A>error = ex_inquire (exoid, EX_INQ_NS_NODE_LEN, &amp;list_len, &amp;fdum, cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3355"></A>node_list = (int *) calloc(list_len, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3358"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3410"></A>error = ex_inquire (exoid, EX_INQ_NS_DF_LEN, &amp;list_len, &amp;fdum, cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3413"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3400"></A>dist_fact = (float *) calloc(list_len, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3414"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3415"></A>error = ex_get_concat_node_sets (exoid, ids, num_nodes_per_set, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3321"></A>		num_df_per_set, node_ind, df_ind, node_list, dist_fact);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1386"></A>EXGCNS:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1387"></A><EM CLASS="code">
	SUBROUTINE EXGCNS (IDEXO, IDNPSS, NNNPS, NDNPS, IXNNPS, IXDNPS, LTNNPS, FACNPS, IERR)</EM>
<A NAME="50334051_marker-84"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1388"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2493"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1389"></A><EM CLASS="code">
INTEGER IDNPSS(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2494"></A>Returned array containing the node set ID for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1390"></A><EM CLASS="code">
INTEGER NNNPS(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2495"></A>Returned array containing the number of nodes for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1391"></A><EM CLASS="code">
INTEGER NDNPS(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2496"></A>Returned array containing the number of distribution factors for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1392"></A><EM CLASS="code">
INTEGER IXNNPS(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2497"></A>Returned array containing the indices into the <EM CLASS="code">
LTNNPS</EM>
 array which are the locations of the first node for each set. These indices are 1-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1393"></A><EM CLASS="code">
INTEGER IXDNPS(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2498"></A>Returned array containing the indices into the <EM CLASS="code">
FACNPS</EM>
 array which are the locations of the first distribution factor for each set. These indices are 1-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1394"></A><EM CLASS="code">
INTEGER LTNNPS(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2499"></A>Returned array containing the nodes for all sets. Internal node IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1395"></A><EM CLASS="code">
REAL FACNPS(*) (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2500"></A>Returned array containing the distribution factors for all sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1396"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2501"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4170"></A>As an example, the following code segment will read concatenated node sets:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4139"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4138"></A>c NOTE:		MAXNS is the maximum number of node sets</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4169"></A>c		MAXNOD is the maximum number of nodes in a node set</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4615"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4183"></A>	 integer ids(MAXNS), numnodes(MAXNS), num_df(MAXNS), node_ind(MAXNS),</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4184"></A>	1	df_ind(MAXNS), node_list(MAXNOD*MAXNS), dist_fact(MAXNOD*MAXNS)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4181"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4171"></A>c read concatenated node sets</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4173"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4174"></A>	 call exinq (idexo, EXNODS, num_node_sets, fdum, cdum, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4176"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4177"></A>	 if (num_node_sets .gt. 0) then</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4178"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4179"></A>c use the next calls if you can dynamically allocate arrays</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4180"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4175"></A>		call exinq (idexo, EXNSNL, list_len, fdum, cdum, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4182"></A>		call exinq (idexo, EXNSDF, list_len, fdum, cdum, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4185"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4186"></A>		call exgcns (idexo, ids, numnodes, num_df,</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4187"></A>	1 	node_ind, df_ind, node_list, dist_fact, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4172"></A>	 endif</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1397"></A><A NAME="50334051_32859"></A>Write Side Set Parameters</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1398"></A>The function <EM CLASS="code">
ex_put_side_set_param</EM>
 (or <EM CLASS="code">
EXPSP</EM>
 for Fortran) writes the <A NAME="50334051_marker-466"></A>side set ID and the number of sides (faces on 3-d element types; edges on 2-d element types) which describe a single side set, and the number of <A NAME="50334051_marker-467"></A>distribution factors on the side set. Because each side of a side set is completely defined by an element and a local side number, the number of sides is equal to the number of elements in a side set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1399"></A>In case of an error, <EM CLASS="code">
ex_put_side_set_param</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPSP</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1400"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1401"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2932"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2973"></A>the number of side sets specified in the call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran) was zero or has been exceeded.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2974"></A>a side set with the same ID has already been stored.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1402"></A>ex_put_side_set_param:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1403"></A><EM CLASS="code">
	int ex_put_side_set_param (exoid, side_set_id, num_side_in_set, num_dist_fact_in_set);</EM>
<A NAME="50334051_marker-85"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1404"></A><EM CLASS="code">
int</EM>
<EM CLASS="Bold">
 exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2502"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1405"></A><EM CLASS="code">
int side_set_id</EM>
<EM CLASS="Bold">
 (R)</EM>
<EM CLASS="code">
		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2503"></A>The side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1406"></A><EM CLASS="code">
int num_side_in_set</EM>
<EM CLASS="Bold">
 (R)</EM>
<EM CLASS="code">
		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2504"></A>The number of sides (faces or edges) in the side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1407"></A><EM CLASS="code">
int num_dist_fact_in_set</EM>
<EM CLASS="Bold">
 (R)</EM>
<EM CLASS="code">
		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2505"></A>The number of distribution factors on the side set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3424"></A>The following code segment will write a side set to an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3425"></A>int error, exoid, id, num_sides, num_df, elem_list[2], side_list[2];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3428"></A>float dist_fact[4];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3430"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3427"></A>/* write side set parameters */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3426"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3434"></A>id = 30;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3435"></A>num_sides = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3436"></A>num_df = 4;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3443"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3429"></A>error = ex_put_side_set_param (exoid, id, num_sides, num_df);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3431"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3440"></A>/* write side set element and side lists */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3447"></A>elem_list[0] = 1; elem_list[1] = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3437"></A>side_list[0] = 1; side_list[1] = 1;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3441"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3442"></A>error = ex_put_side_set (exoid, id, elem_list, side_list);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3433"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3449"></A>/* write side set distribution factors */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3439"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3450"></A>dist_fact[0] = 30.0; dist_fact[1] = 30.1; </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3438"></A>dist_fact[2] = 30.2; dist_fact[3] = 30.3;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3444"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3445"></A>error = ex_put_side_set_dist_fact (exoid, id, dist_fact);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1408"></A>EXPSP:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1409"></A><EM CLASS="code">
	SUBROUTINE EXPSP (IDEXO, IDESS, NSESS, NDESS, IERR)</EM>
<A NAME="50334051_marker-86"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1410"></A><EM CLASS="code">
INTEGER IDEXO</EM>
<EM CLASS="Bold">
 (R)</EM>
<EM CLASS="code">
		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2506"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1411"></A><EM CLASS="code">
INTEGER IDESS</EM>
<EM CLASS="Bold">
 (R)</EM>
<EM CLASS="code">
		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2507"></A>The side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1412"></A><EM CLASS="code">
INTEGER NSESS</EM>
<EM CLASS="Bold">
 (R)</EM>
<EM CLASS="code">
		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2508"></A>The number of sides (faces or edges) in the side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1413"></A><EM CLASS="code">
INTEGER NDESS</EM>
<EM CLASS="Bold">
 (R)</EM>
<EM CLASS="code">
		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2509"></A>The number of distribution factors on the side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1414"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2510"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4189"></A>The following code segment will write a side set to an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4188"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3432"></A>	 integer elem_list(2), side_list(2)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4206"></A>	 real dist_fact(4)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4191"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4190"></A>	 id = 31</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4209"></A>	 numsid = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4210"></A>	 numdf = 4</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4207"></A>	 elem_list(1) = 13</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4192"></A>	 elem_list(2) = 14</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4193"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4194"></A>	 side_list(1) = 3</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4195"></A>	 side_list(2) = 4</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4196"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4197"></A>	 dist_fact(1) = 31.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4198"></A>	 dist_fact(2) = 31.1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4199"></A>	 dist_fact(3) = 31.2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4200"></A>	 dist_fact(4) = 31.3</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4201"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4202"></A>	 call expsp (idexo, id, numsid, numdf, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4205"></A>	 call expss (idexo, id, elem_list, side_list, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4208"></A>	 call expssd (idexo, id, dist_fact, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1415"></A><A NAME="50334051_22538"></A>Read Side Set Parameters</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1416"></A>The function <EM CLASS="code">
ex_get_side_set_param</EM>
 (or <EM CLASS="code">
EXGSP</EM>
 for Fortran) reads the number of sides (faces on 3-d element types; edges on 2-d element types) which describe a single <A NAME="50334051_marker-468"></A>side set, and the number of <A NAME="50334051_marker-469"></A>distribution factors on the side set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1417"></A>In case of an error, <EM CLASS="code">
ex_get_side_set_param</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGSP</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1418"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2975"></A>a warning value is returned if no side sets are stored in the file.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2976"></A>incorrect side set ID.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1420"></A>ex_get_side_set_param:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1421"></A><EM CLASS="code">
	int ex_get_side_set_param (exoid, side_set_id, num_side_in_set, num_dist_fact_in_set);</EM>
<A NAME="50334051_marker-87"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1422"></A><EM CLASS="code">
int exoid	</EM>
<EM CLASS="Bold">
 (R)</EM>
<EM CLASS="code">
	</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2511"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1423"></A><EM CLASS="code">
int side_set_id (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2512"></A>The side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1424"></A><EM CLASS="code">
int* num_side_in_set (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2513"></A>Returned number of sides (faces or edges) in the side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1425"></A><EM CLASS="code">
int* num_dist_fact_in_set (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2514"></A>Returned number of distribution factors on the side set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3453"></A>The following coding will read all of the side sets from an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3454"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3471"></A>int num_side_sets, error, exoid, num_sides_in_set, num_df_in_set, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3360"></A>	num_elem_in_set, *ids, *elem_list, *side_list, *ctr_list, *node_list;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3467"></A>float *dist_fact;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3468"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3497"></A>error = ex_inq (exoid, EX_INQ_SIDE_SETS, &amp;num_side_sets, &amp;fdum, cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3499"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3456"></A>ids = (int *) calloc(num_side_sets, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3458"></A>error = ex_get_side_set_ids (exoid, ids);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3460"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3461"></A>for (i=0; i&lt;num_side_sets; i++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3462"></A>{</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3463"></A>	error = ex_get_side_set_param (exoid, ids[i], 	&amp;num_sides_in_set, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3388"></A>		&amp;num_df_in_set);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3466"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3473"></A>	num_elem_in_set = num_sides_in_set;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3474"></A>	elem_list = (int *) calloc(num_elem_in_set, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3475"></A>	side_list = (int *) calloc(num_sides_in_set, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3480"></A>	error = ex_get_side_set (exoid, ids[i], elem_list, side_list);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3487"></A>	if (num_df_in_set &gt; 0)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3488"></A>	{</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3476"></A>/* get side set node list to correlate to dist factors */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3502"></A>		ctr_list = (int *) calloc(num_elem_in_set, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3496"></A>		node_list = (int *) calloc(num_df_in_set, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3478"></A>		dist_fact = (float *) calloc(num_df_in_set, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3387"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3401"></A>		error = ex_get_side_set_node_list (exoid, ids[i], ctr_list, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3455"></A>			node_list);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3489"></A>		error = ex_get_side_set_dist_fact (exoid, ids[i], 	dist_fact);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3491"></A>	}</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3459"></A>}</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1426"></A>EXGSP:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1427"></A><EM CLASS="code">
	SUBROUTINE EXGSP (IDEXO, IDESS, NSESS, NDESS, IERR)</EM>
<A NAME="50334051_marker-88"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1428"></A><EM CLASS="code">
INTEGER IDEXO (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2515"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1429"></A><EM CLASS="code">
INTEGER IDESS (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2516"></A>The side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1430"></A><EM CLASS="code">
INTEGER NSESS (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2517"></A>Returned number of sides (faces or edges) in the side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1431"></A><EM CLASS="code">
INTEGER NDESS (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2518"></A>Returned number of distribution factors on the side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1432"></A><EM CLASS="code">
INTEGER IERR (W)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2519"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4204"></A>The following coding will read all of the side sets from an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4616"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3465"></A>c NOTE:		MAXSS is the maximum number of side sets</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3501"></A>c		MAXSID is the maximum number of sides in a side set</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4617"></A>c		MAXNOD is the maximum number of nodes on a side set</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4213"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3479"></A>	 integer ids(MAXSS), numsid, numdf, elemlst(MAXSID), sidelst(MAXSID),</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3472"></A>	1	incnt(MAXSID), nodelst(MAXNOD)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4212"></A>	 real distfact(MAXNOD)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4219"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4203"></A>	 if (num_side_sets .gt. 0) then</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4214"></A>		call exgssi (idexo, ids, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4216"></A>	 endif</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4217"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4218"></A>	 do 10 i = 1, num_side_sets</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4220"></A>		call exgsp (idexo, ids(i), numsid, numdf, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4229"></A>		call exgss (idexo, ids(i), elemlst, sidelst, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3457"></A>		call exgssn (idexo, ids(i), incnt, nodelst, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4232"></A>		call exgssd (idexo, ids(i), distfact, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4215"></A>10	 continue</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1433"></A><A NAME="50334051_42079"></A>Write Side Set</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1434"></A>The function <EM CLASS="code">
ex_put_side_set</EM>
 (or <EM CLASS="code">
EXPSS</EM>
 for Fortran) writes the <A NAME="50334051_marker-470"></A>side set element list and side set side (face on 3-d element types; edge on 2-d element types) list for a single side set. The routine <EM CLASS="code">
ex_put_side_set_param</EM>
 (<EM CLASS="code">
EXPSP</EM>
 for Fortran) must be called before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1435"></A>In case of an error, <EM CLASS="code">
ex_put_side_set</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPSS</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1436"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1437"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2933"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2977"></A><EM CLASS="code">
ex_put_side_set_param</EM>
 (or <EM CLASS="code">
EXPSP</EM>
 for Fortran) not called previously.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1438"></A>ex_put_side_set:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1439"></A><EM CLASS="code">
	int ex_put_side_set (exoid, side_set_id, side_set_elem_list, side_set_side_list);</EM>
<A NAME="50334051_marker-89"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1440"></A><EM CLASS="code">
int exoid (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2520"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1441"></A><EM CLASS="code">
int side_set_id (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2521"></A>The side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1442"></A><EM CLASS="code">
int* side_set_elem_list (R)		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2522"></A>Array containing the elements in the side set. Internal element IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1443"></A><EM CLASS="code">
int* side_set_side_list (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2523"></A>Array containing the sides (faces or edges) in the side set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3451"></A>For an example of a code segment to write a side set, refer to the description for <EM CLASS="code">
ex_put_side_set_param</EM>
.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1444"></A>EXPSS:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1445"></A><EM CLASS="code">
	SUBROUTINE EXPSS (IDEXO, IDESS, LTEESS, LTSESS, IERR)</EM>
<A NAME="50334051_marker-90"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1446"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2524"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1447"></A><EM CLASS="code">
INTEGER IDESS (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2525"></A>The side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1448"></A><EM CLASS="code">
INTEGER LTEESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2526"></A>Array containing the elements in the side set. Internal element IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1449"></A><EM CLASS="code">
INTEGER LTSESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2527"></A>Array containing the sides (faces or edges) in the side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1450"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2528"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4211"></A>For an example of a code segment to write a side set, refer to the description for <EM CLASS="code">
EXPSP</EM>
.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1451"></A><A NAME="50334051_34153"></A>Read Side Set</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1452"></A>The function <EM CLASS="code">
ex_get_side_set</EM>
 (or <EM CLASS="code">
EXGSS</EM>
 for Fortran) reads the <A NAME="50334051_marker-471"></A>side set element list and side set side (face for 3-d element types; edge for 2-d element types) list for a single side set. Memory must be allocated for the element list and side list (both are <EM CLASS="code">
num_side_in_set</EM>
 in length) before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1453"></A>In case of an error, <EM CLASS="code">
ex_get_side_set</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGSS</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1454"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2978"></A>a warning value is returned if no side sets are stored in the file.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2979"></A>incorrect side set ID.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1455"></A>ex_get_side_set:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1456"></A><EM CLASS="code">
	int ex_get_side_set (exoid, side_set_id, side_set_elem_list, side_set_side_list);</EM>
<A NAME="50334051_marker-91"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1457"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2529"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1458"></A><EM CLASS="code">
int side_set_id (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2532"></A>The side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1459"></A><EM CLASS="code">
int* side_set_elem_list (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2531"></A>Returned array containing the elements in the side set. Internal element IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1460"></A><EM CLASS="code">
int* side_set_side_list (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2530"></A>Returned array containing the sides (faces or edges) in the side set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3503"></A>For an example of code to read a side set from an EXODUS II file, refer to the description for <EM CLASS="code">
ex_get_side_set_param</EM>
.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1461"></A>EXGSS:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1462"></A><EM CLASS="code">
	SUBROUTINE EXGSS (IDEXO, IDESS, LTEESS, LTSESS, IERR)</EM>
<A NAME="50334051_marker-92"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1463"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2533"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1464"></A><EM CLASS="code">
INTEGER IDESS (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2534"></A>The side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1465"></A><EM CLASS="code">
INTEGER LTEESS(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2535"></A>Returned array containing the elements in the side set. Internal element IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1466"></A><EM CLASS="code">
INTEGER LTSESS(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2536"></A>Returned array containing the faces (or edges) in the side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1467"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2537"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4221"></A>For an example of code to read a side set from an EXODUS II file, refer to the description for <EM CLASS="code">
EXGSP</EM>
.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1468"></A><A NAME="50334051_13356"></A>Write Side Set Distribution Factors</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1469"></A>The function <EM CLASS="code">
ex_put_side_set_dist_fact</EM>
 (or <EM CLASS="code">
EXPSSD</EM>
 for Fortran) writes <A NAME="50334051_marker-472"></A>distribution factors for a single side set. The routine <EM CLASS="code">
ex_put_side_set_param</EM>
 (or <EM CLASS="code">
EXPSP</EM>
 for Fortran) must be called before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1470"></A>Because the distribution factors are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1471"></A>In case of an error, <EM CLASS="code">
ex_put_side_set_dist_fact</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPSSD</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1472"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1473"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2934"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2980"></A><EM CLASS="code">
ex_put_side_set_param</EM>
 (or <EM CLASS="code">
EXPSP</EM>
 for Fortran) not called previously.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2981"></A>a call to <EM CLASS="code">
ex_put_side_set_param</EM>
 (or <EM CLASS="code">
EXPSP</EM>
 for Fortran) specified zero distribution factors.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1474"></A>ex_put_side_set_dist_fact:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1475"></A><EM CLASS="code">
	int ex_put_side_set_dist_fact (exoid, side_set_id, side_set_dist_fact);</EM>
<A NAME="50334051_marker-93"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1476"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2538"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1477"></A><EM CLASS="code">
int side_set_id (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2539"></A>The side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1478"></A><EM CLASS="code">
void* side_set_dist_fact (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2540"></A>Array containing the distribution factors in the side set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3452"></A>For an example of a code segment to write side set distribution factors, refer to the description for <EM CLASS="code">
ex_put_side_set_param</EM>
.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1479"></A>EXPSSD:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1480"></A><EM CLASS="code">
	SUBROUTINE EXPSSD (IDEXO, IDESS, FACESS, IERR)</EM>
<A NAME="50334051_marker-94"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1481"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2541"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1482"></A><EM CLASS="code">
INTEGER IDESS (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2542"></A>The side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1483"></A><EM CLASS="code">
REAL FACESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2543"></A>Array containing the distribution factors in the side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1484"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2544"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4223"></A>For an example of a code segment to write side set distribution factors, refer to the description for <EM CLASS="code">
EXPSP</EM>
.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1485"></A><A NAME="50334051_42724"></A>Read Side Set Distribution Factors</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1486"></A>The function <EM CLASS="code">
ex_get_side_set_dist_fact</EM>
 (or <EM CLASS="code">
EXGSSD</EM>
 for Fortran) returns the <A NAME="50334051_marker-473"></A>distribution factors for a single side set. Memory must be allocated for the list of distribution factors (<EM CLASS="code">
num_dist_fact_in_set</EM>
 in length) before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1487"></A>Because the distribution factors are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1488"></A>In case of an error, <EM CLASS="code">
ex_get_side_set_dist_fact</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGSSD</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2982"></A>a warning value is returned if no distribution factors were stored.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1490"></A>ex_get_side_set_dist_fact:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1491"></A><EM CLASS="code">
	int ex_get_side_set_dist_fact (exoid, side_set_id, side_set_dist_fact);</EM>
<A NAME="50334051_marker-95"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1492"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2545"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1493"></A><EM CLASS="code">
int side_set_id (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2546"></A>The side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1494"></A><EM CLASS="code">
void* side_set_dist_fact (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2547"></A>Returned array containing the distribution factors in the side set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3504"></A>For an example of code to read side set distribution factors from an EXODUS II file, refer to the description for <EM CLASS="code">
ex_get_side_set_param</EM>
.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1495"></A>EXGSSD:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1496"></A><EM CLASS="code">
	SUBROUTINE EXGSSD (IDEXO, IDESS, FACESS, IERR)</EM>
<A NAME="50334051_marker-96"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1497"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-8019"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-8020"></A><EM CLASS="code">
INTEGER IDESS (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-8021"></A>The side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1499"></A><EM CLASS="code">
REAL FACESS(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2550"></A>Returned array containing the distribution factors in the side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1500"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2551"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4224"></A>For an example of code to read side set distribution factors from an EXODUS II file, refer to the description for <EM CLASS="code">
EXGSP</EM>
.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1517"></A><A NAME="50334051_19733"></A>Read Side Sets IDs </H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1518"></A>The function <EM CLASS="code">
ex_get_side_set_ids</EM>
  (or <EM CLASS="code">
EXGSSI</EM>
 for Fortran) reads the IDs of all of the side sets. Memory must be allocated for the returned array of  (<EM CLASS="code">
num_side_sets</EM>
) IDs before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1519"></A>In case of an error, <EM CLASS="code">
ex_get_side_set_ids</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGSSI</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1520"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2983"></A>a warning value is returned if no side sets are stored in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1521"></A>ex_get_side_set_ids:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1522"></A><EM CLASS="code">
	int ex_get_side_set_ids (exoid, side_set_ids);</EM>
<A NAME="50334051_marker-97"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1523"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2552"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1524"></A><EM CLASS="code">
int* side_set_ids (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2553"></A>Returned array of the <A NAME="50334051_marker-474"></A>side sets IDs. The order of the IDs in this array reflects the sequence the side sets were introduced into the file.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3505"></A>For an example of code to read side set IDs from an EXODUS II file, refer to the description for <EM CLASS="code">
ex_get_side_set_param</EM>
.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1525"></A>EXGSSI:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1526"></A><EM CLASS="code">
	SUBROUTINE EXGSSI (IDEXO, IDESSS, IERR)</EM>
<A NAME="50334051_marker-98"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1527"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2554"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1528"></A><EM CLASS="code">
INTEGER IDESSS(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2555"></A>Returned array of side sets IDs. The order of the IDs in this array reflects the sequence the side sets were introduced into the file.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1529"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2556"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4222"></A>For an example of code to read side set IDs from an EXODUS II file, refer to the description for <EM CLASS="code">
EXGSP</EM>
.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1501"></A><A NAME="50334051_16306"></A>Read <A NAME="50334051_marker-475"></A>Side Set Node List</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1502"></A>The function <EM CLASS="code">
ex_get_side_set_node_list</EM>
 (or <EM CLASS="code">
EXGSSN</EM>
 for Fortran) returns a node count array and a list of nodes on a single side set. With the 2.0 and later versions of the database, this node list isn't stored directly but can be derived from the element number in the side set element list, local side number in the side set side list, and the element connectivity array. The application program must allocate memory for the node count array and node list.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2221"></A>There is a one-to-one mapping (i.e., same order -- as shown in <A HREF="exodusII.html#50334051_10813" CLASS="XRef">See Side Set Node Ordering</A> -- and same number) between the nodes in the side set node list and the side set distribution factors. Thus, if distribution factors are stored for the side set of interest, the required size for the node list is the number of distribution factors returned by <EM CLASS="code">
ex_get_side_set_param</EM>
 (or <EM CLASS="code">
EXGSP</EM>
 for Fortran). If distribution factors are not stored for the side set, the application program must allocate a maximum size anticipated for the node list. This would be the product of the number of elements in the side set and the maximum number of nodes per side for all types of elements in the model, since side sets can span across different element types.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1503"></A>The length of the node count array is the length of the side set element list. For each entry in the side set element list, there is an entry in the side set side list, designating a local side number. The corresponding entry in the node count array is the number of nodes which define the particular side. In conjunction with the side set node list, this node count array gives an unambiguous nodal description of the side set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1506"></A>In case of an error, <EM CLASS="code">
ex_get_side_set_node_list</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGSSN</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1507"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2984"></A>a warning value is returned if no side sets are stored in the file.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2985"></A>incorrect side set ID.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1508"></A>ex_get_side_set_node_list:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1509"></A><EM CLASS="code">
	int ex_get_side_set_node_list (exoid, side_set_id, side_set_node_cnt_list, side_set_node_list);</EM>
<A NAME="50334051_marker-99"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1510"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2557"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1511"></A><EM CLASS="code">
int side_set_id (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2558"></A>The side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1512"></A><EM CLASS="code">
int* side_set_node_cnt_list (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2559"></A>Returned array containing the number of nodes for each side (face in 3-d, edge in 2-d) in the side set. </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1513"></A><EM CLASS="code">
int* side_set_node_list (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2560"></A>Returned array containing a list of nodes on the side set. Internal node IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3506"></A>For an example of code to read a side set node list from an EXODUS II file, refer to the description for <EM CLASS="code">
ex_get_side_set_param</EM>
.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1514"></A>EXGSSN:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1515"></A><EM CLASS="code">
	SUBROUTINE EXGSSN (IDEXO, IDESS, INCNT, LTNESS, IERR)</EM>
<A NAME="50334051_marker-100"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1516"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2561"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1889"></A><EM CLASS="code">
INTEGER IDESS (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2562"></A>The side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2210"></A><EM CLASS="code">
INCNT(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2563"></A>Returned array containing the number of nodes for each side (face in 3-d, edge in 2-d) in the side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2245"></A><EM CLASS="code">
INTEGER LTNESS(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2564"></A>Returned array containing a list of nodes on the side set. Internal node IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2219"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2565"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4225"></A>For an example of code to read a side set node list from an EXODUS II file, refer to the description for <EM CLASS="code">
EXGSP</EM>
.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1530"></A><A NAME="50334051_37836"></A>Write <A NAME="50334051_marker-517"></A>Concatenated Side Sets</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1531"></A>The function <EM CLASS="code">
ex_put_concat_side_sets</EM>
 (or <EM CLASS="code">
EXPCSS</EM>
 for Fortran) writes the side set IDs, side set element count array, side set distribution factor count array, side set element pointers array, side set distribution factors pointers array, side set element list, side set side list, and side set distribution factors.  &quot;Concatenated side sets&quot; refers to the arrays needed to define all of the side sets (ID array, side counts array, node counts array, element pointer array, node pointer array, element list, node list, and distribution factors array) as described in <A HREF="exodusII.book.html#50334051_26621" CLASS="XRef">See Concatenated Side Sets</A>. Writing concatenated side sets is more efficient than writing individual side sets. See Appendix A for a discussion of efficiency issues.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1532"></A>Because the distribution factors are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1533"></A>In case of an error, <EM CLASS="code">
ex_put_concat_side_sets</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPCSS</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1534"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1535"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2935"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2986"></A>the number of side sets specified in a call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran) was zero or has been exceeded.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2987"></A>a side set with the same ID has already been stored.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1536"></A>ex_put_concat_side_sets:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1537"></A><EM CLASS="code">
	int ex_put_concat_side_sets (exoid, side_sets_ids, num_side_per_set, num_dist_per_set, side_sets_elem_index, side_sets_dist_index, side_sets_elem_list, side_sets_side_list, side_sets_dist_fact);</EM>
<A NAME="50334051_marker-101"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1538"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2566"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1539"></A><EM CLASS="code">
int* side_sets_ids (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2567"></A>Array containing the side set ID for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1540"></A><EM CLASS="code">
int* num_side_per_set (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2568"></A>Array containing the number of sides for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1541"></A><EM CLASS="code">
int* num_dist_per_set (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2569"></A>Array containing the number of distribution factors for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1542"></A><EM CLASS="code">
int* side_sets_elem_index (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2570"></A>Array containing the indices into the <EM CLASS="code">
side_sets_elem_list</EM>
 which are the locations of the first element for each set. These indices are 0-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1543"></A><EM CLASS="code">
int* side_sets_dist_index (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-9682"></A>Array containing the indices into the <EM CLASS="code">
side_sets_dist_fact</EM>
 which are the locations of the first distribution factor for each set. These indices are 0-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-9683"></A><EM CLASS="code">
int* side_sets_elem_list (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2572"></A>Array containing the elements for all side sets. Internal element IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1545"></A><EM CLASS="code">
int* side_sets_side_list (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2573"></A>Array containing the sides for all side sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1546"></A><EM CLASS="code">
void* side_sets_dist_fact (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2574"></A>Array containing the distribution factors for all side sets.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3477"></A>The following coding will write out two side sets in a concatenated format:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3485"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3482"></A>int error, exoid, ids[2], num_side_per_set[2], elem_ind[2],</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3535"></A>	num_df_per_set[2], df_ind[2], elem_list[4], side_list[4];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3533"></A>float dist_fact[8];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3534"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3528"></A>/* write concatenated side sets */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3494"></A>ids[0] = 30;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3495"></A>ids[1] = 31;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3507"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3517"></A>num_side_per_set[0] = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3519"></A>num_side_per_set[1] = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3520"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3524"></A>elem_ind[0] = 0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3525"></A>elem_ind[1] = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3526"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3510"></A>num_df_per_set[0] = 4;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3512"></A>num_df_per_set[1] = 4;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3513"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3514"></A>df_ind[0] = 0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3515"></A>df_ind[1] = 4;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3516"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3529"></A>/* side set #1 */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3508"></A>elem_list[0] = 2; elem_list[1] = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3530"></A>side_list[0] = 2; side_list[1] = 1;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3518"></A>dist_fact[0] = 30.0; dist_fact[1] = 30.1;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3521"></A>dist_fact[2] = 30.2; dist_fact[3] = 30.3;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3511"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3551"></A>/* side set #2 */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3509"></A>elem_list[2] = 1; elem_list[3] = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3531"></A>side_list[2] = 4; side_list[3] = 3;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3522"></A>dist_fact[4] = 31.0; dist_fact[5] = 31.1;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3523"></A>dist_fact[6] = 31.2; dist_fact[7] = 31.3;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3532"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3547"></A>error = ex_put_concat_side_sets (exoid, ids, num_side_per_set, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3405"></A>	num_df_per_set, elem_ind, df_ind, elem_list, side_list, dist_fact);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1547"></A>EXPCSS:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1548"></A><EM CLASS="code">
	SUBROUTINE EXPCSS (IDEXO, IDESSS, NSESS, NDESS, IXEESS, IXDESS, LTEESS, LTSESS, FACESS, IERR)</EM>
<A NAME="50334051_marker-102"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1549"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2575"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1550"></A><EM CLASS="code">
INTEGER IDESSS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2576"></A>Array containing the side set ID for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1551"></A><EM CLASS="code">
INTEGER NSESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2577"></A>Array containing the number of sides for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1552"></A><EM CLASS="code">
INTEGER NDESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2578"></A>Array containing the number of distribution factors for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1553"></A><EM CLASS="code">
INTEGER IXEESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2579"></A>Array containing the indices into the <EM CLASS="code">
LTEESS</EM>
 array which are the locations of the first element for each set. These indices are 1-based. </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1554"></A><EM CLASS="code">
INTEGER IXDESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2580"></A>Array containing the indices into the <EM CLASS="code">
FACESS</EM>
 array which are the locations of the first distribution factor for each set. These indices are 1-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1555"></A><EM CLASS="code">
INTEGER LTEESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2581"></A>Array containing the elements for all side sets. Internal element IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1556"></A><EM CLASS="code">
INTEGER LTSESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2582"></A>Array containing the sides for all side sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1557"></A><EM CLASS="code">
REAL FACESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2583"></A>Array containing the distribution factors for all side sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1558"></A><EM CLASS="code">
INTEGER IERR (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2584"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4226"></A>The following coding will write out two side sets in a concatenated format:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-1489"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4269"></A>	 integer ids(2), num_side_per_set(2), num_df_per_set(2),</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4277"></A>	1	elem_ind(2), df_ind(2), elem_list(4), side_list(4)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4278"></A>	 real dist_fact(8)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4276"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4227"></A>c write concatenated side sets</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4230"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4231"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4233"></A>	 ids(1) = 30</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4234"></A>	 ids(2) = 31</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4235"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4236"></A>	 num_side_per_set(1) = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4237"></A>	 num_side_per_set(2) = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4238"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4239"></A>	 num_df_per_set(1) = 4</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4240"></A>	 num_df_per_set(2) = 4</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4241"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4242"></A>	 elem_ind(1) = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4243"></A>	 elem_ind(2) = 3</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4244"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4245"></A>	 df_ind(1) = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4246"></A>	 df_ind(2) = 5</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4247"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4272"></A>c side set #1 (ID of 30)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4273"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4248"></A>	 elem_list(1) = 11</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4249"></A>	 elem_list(2) = 12</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4250"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4253"></A>	 side_list(1) = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4254"></A>	 side_list(2) = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4255"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4258"></A>	 dist_fact(1) = 30.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4259"></A>	 dist_fact(2) = 30.1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4260"></A>	 dist_fact(3) = 30.2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4261"></A>	 dist_fact(4) = 30.3</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4262"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4274"></A>c side set #2 (ID of 31)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4275"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4228"></A>	 elem_list(3) = 13</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4251"></A>	 elem_list(4) = 14</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4252"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4270"></A>	 side_list(3) = 3</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4256"></A>	 side_list(4) = 4</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4257"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4271"></A>	 dist_fact(5) = 31.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4263"></A>	 dist_fact(6) = 31.1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4264"></A>	 dist_fact(7) = 31.2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4265"></A>	 dist_fact(8) = 31.3</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4266"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4267"></A>	 call expcss (idexo, ids, num_side_per_set, num_df_per_set,</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4268"></A>	1 	elem_ind, df_ind, elem_list, side_list, dist_fact, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1559"></A><A NAME="50334051_30116"></A>Read <A NAME="50334051_marker-518"></A>Concatenated Side Sets</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1560"></A>The function <EM CLASS="code">
ex_get_concat_side_sets</EM>
 (or <EM CLASS="code">
EXGCSS</EM>
 for Fortran) reads the side set IDs, side set element count array, side set distribution factors count array, side set element pointers array, side set distribution factors pointers array, side set element list, side set side list, and side set distribution factors.  &quot;Concatenated side sets&quot; refers to the arrays needed to define all of the side sets (ID array, side counts array, node counts array, element pointer array, node pointer array, element list, node list, and distribution factors array) as described in <A HREF="exodusII.book.html#50334051_26621" CLASS="XRef">See Concatenated Side Sets</A>.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1561"></A>Because the distribution factors are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2246"></A>The length of each of the returned arrays can be determined by invoking <EM CLASS="code">
ex_inquire</EM>
 (or <EM CLASS="code">
EXINQ</EM>
 for Fortran). See <A HREF="exodusII.book.html#50334051_23612" CLASS="XRef">See Inquire EXODUS Parameters</A>.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1562"></A>In case of an error, <EM CLASS="code">
ex_get_concat_side_sets</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGCSS</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1563"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2988"></A>a warning value is returned if no side sets are stored in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1565"></A>ex_get_concat_side_sets:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1566"></A><EM CLASS="code">
	int ex_get_concat_side_sets (exoid, side_set_ids, num_side_per_set, num_dist_per_set, side_sets_elem_index, side_sets_dist_index, side_sets_elem_list, side_sets_side_list, side_sets_dist_fact);</EM>
<A NAME="50334051_marker-103"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1567"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2585"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1568"></A><EM CLASS="code">
int* side_set_ids (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2586"></A>Returned array containing the side set ID for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1569"></A><EM CLASS="code">
int* num_side_per_set (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2587"></A>Returned array containing the number of sides for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1570"></A><EM CLASS="code">
int* num_dist_per_set (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2588"></A>Returned array containing the number of distribution factors for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1571"></A><EM CLASS="code">
int* side_sets_elem_index (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2589"></A>Returned array containing the indices into the <EM CLASS="code">
side_sets_elem_list</EM>
 which are the locations of the first element for each set. These indices are 0-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1572"></A><EM CLASS="code">
int* side_sets_dist_index (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2590"></A>Returned array containing the indices into the <EM CLASS="code">
side_sets_dist_fact</EM>
 array which are the locations of the first distribution factor for each set. These indices are 0-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1573"></A><EM CLASS="code">
int* side_sets_elem_list (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2591"></A>Returned array containing the elements for all side sets. Internal element IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1574"></A><EM CLASS="code">
int* side_sets_side_list (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2592"></A>Returned array containing the sides for all side sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1575"></A><EM CLASS="code">
void* side_sets_dist_fact (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2593"></A>Returned array containing the distribution factors for all side sets.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3536"></A>The following code segment will return in concatenated format all the side sets stored in an EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3408"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3411"></A>int error, exoid, num_ss, elem_list_len, df_list_len, *ids, *side_list,</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3492"></A>	*num_side_per_set, *num_df_per_set, *elem_ind, *df_ind, *elem_list;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3560"></A>float *dist_fact;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3571"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3559"></A>error = ex_inquire (exoid, EX_INQ_SIDE_SETS, &amp;num_ss, &amp;fdum, cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3541"></A>if (num_ss &gt; 0) {</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3543"></A>	error = ex_inquire(exoid, EX_INQ_SS_ELEM_LEN, &amp;elem_list_len, &amp;fdum, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3412"></A>		cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3546"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3548"></A>	error = ex_inquire(exoid, EX_INQ_SS_DF_LEN, &amp;df_list_len, 	&amp;fdum, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3416"></A>		cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3554"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3555"></A>/* read concatenated side sets */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3558"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3561"></A>	ids = (int *) calloc(num_ss, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3562"></A>	num_side_per_set = (int *) calloc(num_ss, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3563"></A>	num_df_per_set = (int *) calloc(num_ss, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3564"></A>	elem_ind = (int *) calloc(num_ss, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3565"></A>	df_ind = (int *) calloc(num_ss, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3566"></A>	elem_list = (int *) calloc(elem_list_len, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3567"></A>	side_list = (int *) calloc(elem_list_len, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3568"></A>	dist_fact = (float *) calloc(df_list_len, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3569"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3575"></A>	error = ex_get_concat_side_sets (exoid, ids, num_side_per_set, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3417"></A>		num_df_per_set, elem_ind, df_ind, elem_list, side_list,dist_fact);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3538"></A>}</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1576"></A>EXGCSS:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1577"></A><EM CLASS="code">
	SUBROUTINE EXGCSS (IDEXO, IDESSS, NSESS, NDESS, IXEESS, IXDESS, LTEESS, LTSESS, FACESS, IERR)</EM>
<A NAME="50334051_marker-104"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1578"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2594"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1579"></A><EM CLASS="code">
INTEGER IDESSS(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2595"></A>Returned array containing the side set ID for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1580"></A><EM CLASS="code">
INTEGER NSESS(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2596"></A>Returned array containing the number of sides for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1581"></A><EM CLASS="code">
INTEGER NDESS(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2597"></A>Returned array containing the number of distribution factors for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1582"></A><EM CLASS="code">
INTEGER IXEESS(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2598"></A>Returned array containing the indices into the <EM CLASS="code">
LTEESS</EM>
 array which are the locations of the first element for each set. These indices are 1-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1583"></A><EM CLASS="code">
INTEGER IXDESS(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2599"></A>Returned array containing the indices into the <EM CLASS="code">
FACESS</EM>
 array which are the locations of the first distribution factor for each set. These indices are 1-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1584"></A><EM CLASS="code">
INTEGER LTEESS(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2600"></A>Returned array containing the elements for all side sets. Internal element IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1585"></A><EM CLASS="code">
INTEGER LTSESS(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2601"></A>Returned array containing the sides for all side sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1586"></A><EM CLASS="code">
REAL FACESS(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2602"></A>Returned array containing the distribution factors for all side sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1587"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2603"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4280"></A>The following code segment will return in concatenated format all the side sets stored in an EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3557"></A>c NOTE:		MAXSS is the maximum number of side sets</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3409"></A>c		MAXSID is the maximum number of sides in a side set</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3537"></A>c		MAXDF is the max number of distribution factors in a side set</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4290"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3556"></A>	 integer elemlen, nodelen, dflen, ids(MAXSS), num_side(MAXSS),</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4298"></A>	1	 num_df(MAXSS), elem_ind(MAXSS), df_ind(MAXSS), </P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4300"></A>	2	 elem_list(MAXSID*MAXSS), side_list(MAXSID*MAXSS)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4294"></A>	 real dist_fact(MAXDF*MAXSS)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4295"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4288"></A>	 call exinq (idexo, EXSIDS, num_side_sets, fdum, cdum, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4283"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4284"></A>	 if (num_side_sets .gt. 0) then</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4282"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4286"></A>c use the following inquiries if dynamic allocation is available</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4285"></A>		call exinq (idexo, EXSSEL, elemlen, fdum, cdum, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4289"></A>		call exinq (idexo, EXSSNL, nodelen, fdum, cdum, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4293"></A>		call exinq (idexo, EXSSDF, dflen, fdum, cdum, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4296"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4297"></A>c read concatenated side sets</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4281"></A>		call exgcss (idexo, ids, num_side, num_df, elem_ind, df_ind,</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4291"></A>		 elem_list, side_list, dist_fact, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4292"></A>	 endif</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1882"></A><A NAME="50334051_24098"></A>Convert Side Set Nodes to Sides</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1883"></A>The function <EM CLASS="code">
ex_cvt_nodes_to_sides</EM>
 (or <EM CLASS="code">
EXCN2S</EM>
 for Fortran) is used to <A NAME="50334051_marker-480"></A>convert a side set node list to a side set side list. This routine is provided for application programs that utilize side sets defined by nodes (as was done previous to release 2.0) rather than local faces or edges. The application program must allocate memory for the returned array of sides. The length of this array is the same as the length of the concatenated side sets element list, which can be determined with a call to <EM CLASS="code">
ex_inquire</EM>
 (or <EM CLASS="code">
EXINQ</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2922"></A>In case of an error, <EM CLASS="code">
ex_cvt_nodes_to_sides</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXCN2S</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.   Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2989"></A>a warning value is returned if no side sets are stored in the file.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2256"></A>because the faces of a wedge require a different number of nodes to describe them (quadrilateral vs. triangular faces), the function will abort with a fatal return code if a wedge is encountered in the side set element list.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1885"></A>ex_cvt_nodes_to_sides:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1886"></A><EM CLASS="code">
	int ex_cvt_nodes_to_sides (exoid, num_side_per_set, num_nodes_per_set, side_sets_elem_index, side_sets_node_index,  side_sets_elem_list, side_sets_node_list, side_sets_side_list);</EM>
<A NAME="50334051_marker-105"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1888"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2604"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1890"></A><EM CLASS="code">
int* num_side_per_set (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2605"></A>Array containing the number of sides for each set. The number of sides is equal to the number of elements for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2134"></A><EM CLASS="code">
int* num_nodes_per_set (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2606"></A>Array containing the number of nodes for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2159"></A><EM CLASS="code">
int* side_sets_elem_index (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2607"></A>Array containing indices into the <EM CLASS="code">
side_sets_elem_list</EM>
 which are the locations of the first element for each set. These indices are 0-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2160"></A><EM CLASS="code">
int* side_sets_node_index (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2608"></A>Array containing indices into the <EM CLASS="code">
side_sets_node_list</EM>
 which are the locations of the first node for each set. These indices are 0-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2180"></A><EM CLASS="code">
int* side_sets_elem_list (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2609"></A>Array containing the elements for all side sets. Internal element IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2181"></A><EM CLASS="code">
int* side_sets_node_list (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2610"></A>Array containing the nodes for all side sets. Internal node IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2187"></A><EM CLASS="code">
int* side_sets_side_list (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2611"></A>Returned array containing the sides for all side sets.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3576"></A>The following code segment will convert side sets described by nodes to side sets described by local side numbers:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3570"></A>int error, exoid, ids[2], num_side_per_set[2], num_nodes_per_set[2], </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3418"></A>	elem_ind[2], node_ind[2], elem_list[4], node_list[8], el_lst_len, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3421"></A>	*side_list;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3613"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3612"></A>ids[0] = 30; ids[1] = 31;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3579"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3591"></A>num_side_per_set[0] = 2; num_side_per_set[1] = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3594"></A>num_nodes_per_set[0] = 4; num_nodes_per_set[1] = 4;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3597"></A>elem_ind[0] = 0; elem_ind[1] = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3588"></A>node_ind[0] = 0; node_ind[1] = 4;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3590"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3580"></A>/* side set #1 */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3600"></A>elem_list[0] = 2; elem_list[1] = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3581"></A>node_list[0] = 8; node_list[1] = 5; node_list[2] = 6; node_list[3] = 7;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3583"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3584"></A>/* side set #2 */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3601"></A>elem_list[2] = 1; elem_list[3] = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3585"></A>node_list[4] = 2; node_list[5] = 3; node_list[6] = 7; node_list[7] = 8;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3587"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3603"></A>error = ex_inquire (exoid, EX_INQ_SS_ELEM_LEN, &amp;el_lst_len, &amp;fdum,cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3607"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3609"></A>/* side set element list is same length as side list */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3610"></A>side_list = (int *) calloc (el_lst_len, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3606"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3602"></A>ex_cvt_nodes_to_sides(exoid, num_side_per_set, num_nodes_per_set,</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3423"></A>	elem_ind, node_ind, elem_list, node_list, side_list);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2207"></A>EXCN2S:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2208"></A><EM CLASS="code">
	SUBROUTINE EXCN2S(IDEXO, NSESS, NDESS, IXEESS, IXNESS, LTEESS, LTNESS, LTSESS, IERR)</EM>
<A NAME="50334051_marker-106"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2209"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2612"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2211"></A><EM CLASS="code">
INTEGER NSESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2613"></A>Array containing the number of sides for each set. The number of sides is equal to the number of elements for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2212"></A><EM CLASS="code">
INTEGER NDESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2614"></A>Array containing the number of nodes for each set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2213"></A><EM CLASS="code">
INTEGER IXEESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2615"></A>Array containing indices into the <EM CLASS="code">
LTEESS</EM>
 array which are the locations of the first element for each set. These indices are 1-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2214"></A><EM CLASS="code">
INTEGER IXNESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2616"></A>Array containing indices into the <EM CLASS="code">
LTNESS</EM>
 array which are the locations of the first node for each set. These indices are 1-based.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2215"></A><EM CLASS="code">
INTEGER LTEESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2617"></A>Array containing the elements for all side sets. Internal element IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2216"></A><EM CLASS="code">
INTEGER LTNESS(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2618"></A>Array containing the nodes for all side sets. Internal node IDs are used in this list (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2217"></A><EM CLASS="code">
INTEGER LTSESS(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2619"></A>Returned array containing the sides for all side sets.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2218"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2620"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4302"></A>The following code segment will convert side sets described by nodes to side sets described by local side numbers:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4839"></A>	 INCLUDE `exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-2923"></A>	 integer ids(2), num_side_per_set(2), num_nodes_per_set(2), </P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4342"></A>	1	elem_ind(2), node_ind(2), node_list(8), elem_list(4), </P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4343"></A>	2	side_list(4)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4330"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4332"></A>	 ids(1) = 30</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4303"></A>	 ids(2) = 31</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4333"></A>	 num_side_per_set(1) = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4317"></A>	 num_side_per_set(2) = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4334"></A>	 num_nodes_per_set(1) = 4</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4319"></A>	 num_nodes_per_set(2) = 4</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4335"></A>	 elem_ind(1) = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4321"></A>	 elem_ind(2) = 3</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4336"></A>	 node_ind(1) = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4323"></A>	 node_ind(2) = 5</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4304"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4337"></A>c side set #1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4338"></A>	 node_list(1) = 8</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4306"></A>	 node_list(2) = 5</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4307"></A>	 node_list(3) = 6</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4308"></A>	 node_list(4) = 7</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4324"></A>	 elem_list(1) = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4325"></A>	 elem_list(2) = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4309"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4310"></A>c side set #2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4339"></A>	 node_list(5) = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4312"></A>	 node_list(6) = 3</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4313"></A>	 node_list(7) = 7</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4314"></A>	 node_list(8) = 8</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4326"></A>	 elem_list(3) = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4327"></A>	 elem_list(4) = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4328"></A>	 call excn2s(idexo, num_side_per_set, num_nodes_per_set, elem_ind,</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4329"></A>	1	node_ind, elem_list, node_list, side_list, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1588"></A><A NAME="50334051_21505"></A>Write Property Arrays Names</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-9530"></A>The function <EM CLASS="code">
ex_put_prop_names</EM>
 (or <EM CLASS="code">
EXPPN</EM>
 for Fortran) writes <A NAME="50334051_marker-9529"></A>property names and allocates space for <A NAME="50334051_marker-9531"></A>property arrays used to assign integer properties to element blocks, node sets, or side sets. The property arrays are initialized to zero (0). Although this function is optional, since <EM CLASS="code">
ex_put_prop</EM>
 will allocate space within the data file if it hasn't been previously allocated, it is more efficient to use <EM CLASS="code">
ex_put_prop_names</EM>
 if there is more than one property to store. See Appendix A for a discussion of efficiency issues.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1590"></A>In case of an error, <EM CLASS="code">
ex_put_prop_names</EM>
 returns a negative number; a warning will return a positive number. <EM CLASS="code">
EXPPN</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1591"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1592"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2936"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2990"></A>invalid object type specified.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2991"></A>no object of the specified type is stored in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1593"></A>ex_put_prop_names:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1594"></A><EM CLASS="code">
	int ex_put_prop_names (exoid, obj_type, num_props, prop_names);</EM>
<A NAME="50334051_marker-107"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1595"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2621"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1596"></A><EM CLASS="code">
int obj_typ (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2622"></A>Type of object; use one of the following options: </P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2857"></A><EM CLASS="code">
EX_ELEM_BLOCK</EM>
 	To designate an element block.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2859"></A><EM CLASS="code">
EX_NODE_SET</EM>
 	To designate a node set.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2860"></A><EM CLASS="code">
EX_SIDE_SET</EM>
 	To designate a side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1597"></A><EM CLASS="code">
int num_props (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2623"></A>The number of integer properties to be assigned to all of the objects of the type specified (element blocks, node sets, or side sets).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1598"></A><EM CLASS="code">
char** prop_names (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2624"></A>Array containing <EM CLASS="code">
num_props</EM>
 names (of maximum length of <EM CLASS="code">
MAX_STR_LENGTH</EM>
) of properties to be stored.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4784"></A>For instance, suppose a user wanted to assign the 1st, 3rd, and 5th element blocks (those element blocks stored 1st, 3rd, and 5th, regardless of their ID) to a group (property) called &quot;TOP&quot;, and the 2nd, 3rd, and 4th element blocks to a group called &quot;LSIDE&quot;.  This could be accomplished with the following code:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4785"></A>#include &quot;exodusII.h&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4786"></A>char* prop_names[2];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4787"></A>int top_part[] = {1,0,1,0,1};</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4788"></A>int lside_part[] = {0,1,1,1,0};</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4799"></A>int id[] = {10, 20, 30, 40, 50};</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4790"></A>prop_names[0] = &quot;TOP&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4791"></A>prop_names[1] = &quot;LSIDE&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4796"></A>/* This call to ex_put_prop_names is optional, but more efficient */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4792"></A>ex_put_prop_names (exoid, EX_ELEM_BLOCK, 2, prop_names);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4805"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4793"></A>/* The property values can be output individually thus */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4798"></A>for (i=0; i&lt;5; i++){</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4801"></A>	ex_put_prop (exoid, EX_ELEM_BLOCK, id[i], prop_names[0], top_part[i]);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4800"></A>	ex_put_prop (exoid, EX_ELEM_BLOCK, id[i], prop_names[1], lside_part[i]); }</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4806"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4802"></A>/* Alternatively, the values can be output as an array thus*/</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4797"></A>ex_put_prop_array (exoid, EX_ELEM_BLOCK, prop_names[0], top_part);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4794"></A>ex_put_prop_array (exoid, EX_ELEM_BLOCK, prop_names[1], lside_part);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1599"></A>EXPPN:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1600"></A><EM CLASS="code">
	SUBROUTINE EXPPN (IDEXO, ITYPE, NPROPS, NAMEPR, IERR)</EM>
<A NAME="50334051_marker-108"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1601"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2625"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1602"></A><EM CLASS="code">
INTEGER ITYPE (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2626"></A>Type of object; use one of the following options: </P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2864"></A><EM CLASS="code">
EXEBLK</EM>
	To designate an element block.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2861"></A><EM CLASS="code">
EXNSET</EM>
	To designate a node set.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2862"></A><EM CLASS="code">
EXSSET</EM>
 	To designate a side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1603"></A><EM CLASS="code">
INTEGER NPROPS (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2627"></A>The number of integer properties to be assigned to all of the objects of the type specified (element blocks, node sets, or side sets).</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1604"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMEPR(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2628"></A>Array containing <EM CLASS="code">
NPROPS</EM>
 names of properties to be stored.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1606"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2629"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4808"></A>The following example assigns a property &quot;STEEL&quot; to the first and third element blocks with ID's 10 and 30, respectively.</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4809"></A>	include `exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4819"></A>	integer ival(3)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4818"></A>	data ival/1,0,1/</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4804"></A>C This call to EXPPN in optional, but more efficient</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4813"></A>	call exppn (idexo, exeblk, 1, &quot;STEEL&quot;, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4815"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4803"></A>C The property values can be written individually thus</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4811"></A>	call expp (idexo, EXEBLK, 10, &quot;STEEL&quot;, 1, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4812"></A>	call expp (idexo, EXEBLK, 30, &quot;STEEL&quot;, 1, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4789"></A>c Alternatively, the values can be written as an array thus</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4817"></A>	call exppa (idexo, EXEBLK, &quot;STEEL&quot;, ival, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1607"></A><A NAME="50334051_23137"></A>Read <A NAME="50334051_marker-484"></A>Property Arrays Names</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1608"></A>The function <EM CLASS="code">
ex_get_prop_names</EM>
 (or <EM CLASS="code">
EXGPN</EM>
 for Fortran) returns names of integer properties stored for an element block, node set, or side set. The number of properties (needed to allocate space for the property names) can be obtained via a call to <EM CLASS="code">
ex_inquire</EM>
 (<EM CLASS="code">
EXINQ</EM>
 for Fortran). See <A HREF="exodusII.book.html#50334051_23612" CLASS="XRef">See Inquire EXODUS Parameters</A>.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1609"></A>In case of an error, <EM CLASS="code">
ex_get_prop_names</EM>
 returns a negative number; a warning will return a positive number. <EM CLASS="code">
EXGPN</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1610"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2992"></A>invalid object type specified.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1611"></A>ex_get_prop_names:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1612"></A><EM CLASS="code">
	int ex_get_prop_names (exoid, obj_type, prop_names);</EM>
<A NAME="50334051_marker-109"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1613"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2630"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1614"></A><EM CLASS="code">
int obj_type (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2631"></A>Type of object; use one of the following options: </P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2634"></A><EM CLASS="code">
EX_ELEM_BLOCK</EM>
 	To designate an element block.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2637"></A><EM CLASS="code">
EX_NODE_SET</EM>
 	To designate a node set.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2642"></A><EM CLASS="code">
EX_SIDE_SET</EM>
 	To designate a side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1615"></A><EM CLASS="code">
char** prop_names (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2632"></A>Returned array containing <EM CLASS="code">
num_props</EM>
 (obtained from call to <EM CLASS="code">
ex_inquire</EM>
) names (of maximum length <EM CLASS="code">
MAX_STR_LENGTH</EM>
) of properties to be stored. &quot;ID&quot;, a reserved property name, will be the first name in the array.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1616"></A>As an example, the following code segment reads in properties assigned to node sets:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4821"></A>#include &quot;exodusII.h&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4824"></A>int error, exoid, num_props, *prop_values;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4826"></A>char *prop_names[MAX_PROPS];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4830"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4816"></A>/* read node set properties */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4814"></A>error = ex_inquire (exoid, EX_INQ_NS_PROP, &amp;num_props, &amp;fdum, cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4822"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4823"></A>for (i=0; i&lt;num_props; i++){</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4825"></A>	prop_names[i] = (char *) malloc ((MAX_STR_LENGTH+1), sizeof(char));}</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4827"></A>prop_values = (int *) malloc (num_node_sets, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4828"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4829"></A>error = ex_get_prop_names(exoid,EX_NODE_SET,prop_names);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4833"></A>for (i=0; i&lt;num_props; i++){</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4835"></A>	error = ex_get_prop_array(exoid, EX_NODE_SET, prop_names[i],</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4836"></A>prop_values);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-4810"></A>EXGPN:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1617"></A><EM CLASS="code">
	SUBROUTINE EXGPN (IDEXO, ITYPE, NAMEPR, IERR)</EM>
<A NAME="50334051_marker-110"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1618"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2633"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1619"></A><EM CLASS="code">
INTEGER ITYPE (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2874"></A>Type of object; use one of the following options: </P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2875"></A><EM CLASS="code">
EXEBLK</EM>
	To designate an element block.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2876"></A><EM CLASS="code">
EXNSET</EM>
	To designate a node set.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2877"></A><EM CLASS="code">
EXSSET</EM>
 	To designate a side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1620"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMEPR(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1621"></A>Returned array containing <EM CLASS="code">
NPROPS</EM>
 (obtained from call to <EM CLASS="code">
EXINQ</EM>
) names of properties to be stored. &quot;ID&quot;, a reserved property name, will be the first name in the array.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1622"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2635"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4350"></A>As an example, the following will read the side set property values from an EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4838"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3941"></A>c NOTE:		MAXSS is the maximum number of side sets</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4349"></A>c		MXSSPR is the maximum number of side set properties</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3952"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3937"></A>	include `exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4348"></A>	integer ids(MAXSS), ivals(MAXSS, MXSSPR)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3065"></A>	character*(MXSTLN) prop_names(MXSSPR)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4831"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-2200"></A>c determine number of side sets and side set properties</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4834"></A>	call exinq (idexo, EXSIDS, num_side_sets, fdum, cdum, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4837"></A>	call exinq (idexo, EXNSSP, num_props, fdum, cdum, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4843"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4840"></A>c get the side set property names</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4844"></A>	call exgpn(idexo, EXSSET, prop_names, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4846"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4842"></A>c get the side set ids </P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4850"></A>	call exgssi (idexo, ids, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4845"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4841"></A>c get the side set property values individually</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4847"></A>	do 20 i = 1, num_props</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4848"></A>		do 10 j = 1, num_side_sets</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4849"></A>			call exgp(idexo, EXSSET,ids(j),prop_names(i),ivals(j,i),ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4857"></A>10 		continue</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4858"></A>20	continue</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4353"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4387"></A>c alternatively, the property values can be read in together as follows</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4378"></A>	do 30 i = 1, num_props</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4380"></A>		call exgpa (idexo, EXSSET, prop_names(i), ivals(1,i), ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4381"></A>30 	continue</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1623"></A><A NAME="50334051_16441"></A>Write Object Property</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1624"></A>The function <EM CLASS="code">
ex_put_prop</EM>
 (or <EM CLASS="code">
EXPP</EM>
 for Fortran) stores an integer <A NAME="50334051_marker-483"></A>property value to a single element block, node set, or side set. Although it is not necessary to invoke <EM CLASS="code">
ex_put_prop_names</EM>
 (<EM CLASS="code">
EXPPN</EM>
 for Fortran), since <EM CLASS="code">
ex_put_prop</EM>
 will allocate space within the data file if it hasn't been previously allocated, it is more efficient to use <EM CLASS="code">
ex_put_prop_names</EM>
 if there is more than one property to store. See Appendix A for a discussion of efficiency issues.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1625"></A>It should be noted that the interpretation of the values of the integers stored as properties is left to the application code. In general, a zero (0) means the object does not have the specified property (or is not in the specified group); a nonzero value means the object does have the specified property. When space is allocated for the properties using <EM CLASS="code">
ex_put_prop_names</EM>
 or <EM CLASS="code">
ex_put_prop</EM>
, the properties are initialized to zero (0).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1626"></A>Because the ID of an element block, node set, or side set is just another property (named &quot;ID&quot;), this routine can be used to change the value of an ID. This feature must be used with caution, though, because changing the ID of an object to the ID of another object of the same type (element block, node set, or side set) would cause two objects to have the same ID, and thus only the first would be accessible. Therefore, <EM CLASS="code">
ex_put_prop</EM>
 issues a warning if a user attempts to give two objects the same ID.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1627"></A>In case of an error, <EM CLASS="code">
ex_put_prop</EM>
 returns a negative number; a warning will return a positive number. <EM CLASS="code">
EXPP</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1628"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1629"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2937"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2993"></A>invalid object type specified.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-9543"></A>a warning is issued if a user attempts to change the ID of an object to the ID of an existing object of the same type.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1630"></A>ex_put_prop:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1631"></A><EM CLASS="code">
	int ex_put_prop (exoid, obj_type, obj_id, prop_name, value);</EM>
<A NAME="50334051_marker-111"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1632"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2636"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1633"></A><EM CLASS="code">
int obj_type (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2647"></A>Type of object; use one of the following options: </P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2652"></A><EM CLASS="code">
EX_ELEM_BLOCK</EM>
 	To designate an element block.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2657"></A><EM CLASS="code">
EX_NODE_SET</EM>
 	To designate a node set.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2661"></A><EM CLASS="code">
EX_SIDE_SET</EM>
 	To designate a side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1634"></A><EM CLASS="code">
int obj_id (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2638"></A>The element block, node set, or side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1635"></A><EM CLASS="code">
char* prop_name (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2639"></A>The name of the property for which the value will be stored. Maximum length of this string is <EM CLASS="code">
MAX_STR_LENGTH</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1636"></A><EM CLASS="code">
int value (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2640"></A>The value of the property.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2115"></A>For an example of code to write out an object property, refer to the description for <EM CLASS="code">
ex_put_prop_names</EM>
.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1644"></A>EXPP:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1645"></A><EM CLASS="code">
	SUBROUTINE EXPP (IDEXO, ITYPE, ID, NAMEPR, IVAL, IERR)</EM>
<A NAME="50334051_marker-112"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1646"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2641"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1647"></A><EM CLASS="code">
INTEGER ITYPE (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2878"></A>Type of object; use one of the following options: </P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2879"></A><EM CLASS="code">
EXEBLK</EM>
	To designate an element block.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2880"></A><EM CLASS="code">
EXNSET</EM>
	To designate a node set.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2881"></A><EM CLASS="code">
EXSSET</EM>
 	To designate a side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1648"></A><EM CLASS="code">
INTEGER ID (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2643"></A>The element block, node set, or side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1649"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMEPR (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2644"></A>The name of the property for which a value will be stored.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1651"></A><EM CLASS="code">
INTEGER IVAL (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1650"></A>The value of the property.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1652"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2645"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3484"></A>For an example of code to write out an object property, refer to the description for <EM CLASS="code">
EXPPN</EM>
.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1659"></A><A NAME="50334051_31447"></A>Read Object Property</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1660"></A>The function <EM CLASS="code">
ex_get_prop</EM>
 (or <EM CLASS="code">
EXGP</EM>
 for Fortran) reads an integer <A NAME="50334051_marker-486"></A>property value stored for a single element block, node set, or side set.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1661"></A>In case of an error, <EM CLASS="code">
ex_get_prop</EM>
 returns a negative number; a warning will return a positive number. <EM CLASS="code">
EXGP</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1662"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2994"></A>invalid object type specified.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2995"></A>a warning value is returned if a property with the specified name is not found.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1664"></A>ex_get_prop:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1665"></A><EM CLASS="code">
	int ex_get_prop (exoid, obj_type, obj_id, prop_name, value);</EM>
<A NAME="50334051_marker-113"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1666"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2646"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1667"></A><EM CLASS="code">
int obj_type (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2665"></A>Type of object; use one of the following options: </P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2669"></A><EM CLASS="code">
EX_ELEM_BLOCK</EM>
 	To designate an element block.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2863"></A><EM CLASS="code">
EX_NODE_SET</EM>
 	To designate a node set.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2865"></A><EM CLASS="code">
EX_SIDE_SET</EM>
 	To designate a side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1668"></A><EM CLASS="code">
int obj_id (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2648"></A>The element block, node set, or side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1669"></A><EM CLASS="code">
char* prop_name (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2649"></A>The name of the property (maximum length is <EM CLASS="code">
MAX_STR_LENGTH</EM>
) for which the value is desired.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1670"></A><EM CLASS="code">
int* value (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-8109"></A>Returned value of the property.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2249"></A>For an example of code to read an object property, refer to the description for <EM CLASS="code">
ex_get_prop_names</EM>
.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1676"></A>EXGP:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1677"></A><EM CLASS="code">
	SUBROUTINE EXGP (IDEXO, ITYPE, ID, NAMEPR, IVAL, IERR)</EM>
<A NAME="50334051_marker-114"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1678"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2651"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1679"></A><EM CLASS="code">
INTEGER ITYPE (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2882"></A>Type of object; use one of the following options: </P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2883"></A><EM CLASS="code">
EXEBLK</EM>
	To designate an element block.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2884"></A><EM CLASS="code">
EXNSET</EM>
	To designate a node set.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2885"></A><EM CLASS="code">
EXSSET</EM>
 	To designate a side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1680"></A><EM CLASS="code">
INTEGER ID (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2653"></A>The element block, node set, or side set ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1681"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMEPR (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1682"></A>The name of the property for which the value is desired.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1683"></A><EM CLASS="code">
INTEGER IVAL (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2654"></A>Returned value of the property.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1684"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2655"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4493"></A>For an example of code to read an object property, refer to the description for <EM CLASS="code">
EXGPN</EM>
.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1690"></A><A NAME="50334051_38300"></A>Write Object <A NAME="50334051_marker-487"></A>Property Array</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1691"></A>The function <EM CLASS="code">
ex_put_prop_array</EM>
 (or <EM CLASS="code">
EXPPA</EM>
 for Fortran) stores an array of (<EM CLASS="code">
num_elem_blk</EM>
, <EM CLASS="code">
num_node_sets</EM>
, or <EM CLASS="code">
num_side_sets</EM>
) integer property values for all element blocks, node sets, or side sets. The order of the values in the array must correspond to the order in which the element blocks, node sets, or side sets were introduced into the file. For instance, if the parameters for element block with ID 20 were written to a file (via <EM CLASS="code">
ex_put_elem_block</EM>
; or <EM CLASS="code">
EXPELB</EM>
 for Fortran), and then parameters for element block with ID 10, followed by the parameters for element block with ID 30, the first, second, and third elements in the property array would correspond to element block 20, element block 10, and element block 30, respectively.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1692"></A>One should note that this same functionality (writing properties to multiple objects) can be accomplished with multiple calls to <EM CLASS="code">
ex_put_prop</EM>
 (or <EM CLASS="code">
EXPP</EM>
 in Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4795"></A>Although it is not necessary to invoke <EM CLASS="code">
ex_put_prop_names</EM>
 (<EM CLASS="code">
EXPPN</EM>
 for Fortran), since <EM CLASS="code">
ex_put_prop_array</EM>
 will allocate space within the data file if it hasn't been previously allocated, it is more efficient to use <EM CLASS="code">
ex_put_prop_names</EM>
 if there is more than one property to store. See Appendix A for a discussion of efficiency issues.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1693"></A>In case of an error, <EM CLASS="code">
ex_put_prop_array</EM>
 returns a negative number; a warning will return a positive number. <EM CLASS="code">
EXPPA</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1694"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1695"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2938"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2996"></A>invalid object type specified.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1696"></A>ex_put_prop_array:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1697"></A><EM CLASS="code">
	int ex_put_prop_array (exoid, obj_type, prop_name, values);</EM>
<A NAME="50334051_marker-115"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1698"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2656"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1699"></A><EM CLASS="code">
int obj_type (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2866"></A>Type of object; use one of the following options: </P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2867"></A><EM CLASS="code">
EX_ELEM_BLOCK</EM>
 	To designate an element block.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2868"></A><EM CLASS="code">
EX_NODE_SET</EM>
 	To designate a node set.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2869"></A><EM CLASS="code">
EX_SIDE_SET</EM>
 	To designate a side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1700"></A><EM CLASS="code">
char* prop_name (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2658"></A>The name of the property for which the values will be stored. Maximum length of this string is <EM CLASS="code">
MAX_STR_LENGTH</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1701"></A><EM CLASS="code">
int* values (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2659"></A>An array of property values.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4513"></A>For an example of code to write an array of object properties, refer to the description for <EM CLASS="code">
ex_put_prop_names</EM>
.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1713"></A>EXPPA:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1714"></A><EM CLASS="code">
	SUBROUTINE EXPPA (IDEXO, ITYPE, NAMEPR, IVALS, IERR)</EM>
<A NAME="50334051_marker-116"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1715"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2660"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1716"></A><EM CLASS="code">
INTEGER ITYPE (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2886"></A>Type of object; use one of the following options: </P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2887"></A><EM CLASS="code">
EXEBLK</EM>
	To designate an element block.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2888"></A><EM CLASS="code">
EXNSET</EM>
	To designate a node set.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-8127"></A><EM CLASS="code">
EXSSET</EM>
 	To designate a side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-8128"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMEPR (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-8129"></A>The name of the property for which the values will be stored.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1719"></A><EM CLASS="code">
INTEGER IVAL(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2664"></A>An array of property values.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1720"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2663"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4591"></A>For an example of code to write an array of object properties, refer to the description for <EM CLASS="code">
EXPPN</EM>
.</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1728"></A><A NAME="50334051_41253"></A>Read Object <A NAME="50334051_marker-488"></A>Property Array</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1729"></A>The function <EM CLASS="code">
ex_get_prop_array</EM>
 (or <EM CLASS="code">
EXGPA</EM>
 for Fortran) reads an array of integer property values for all element blocks, node sets, or side sets. The order of the values in the array correspond to the order in which the element blocks, node sets, or side sets were introduced into the file. Before this function is invoked, memory must be allocated for the returned array of (<EM CLASS="code">
num_elem_blk</EM>
, <EM CLASS="code">
num_node_sets</EM>
, or <EM CLASS="code">
num_side_sets</EM>
) integer values.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1730"></A>This function can be used in place of <EM CLASS="code">
ex_get_elem_blk_ids</EM>
 (<EM CLASS="code">
EXGEBI</EM>
 for Fortran), <EM CLASS="code">
ex_get_node_set_ids</EM>
 (<EM CLASS="code">
EXGNSI</EM>
 for Fortran), and <EM CLASS="code">
ex_get_side_set_ids</EM>
 (<EM CLASS="code">
EXGSSI</EM>
 for Fortran) to get <A NAME="50334051_marker-9550"></A>element block, <A NAME="50334051_marker-9551"></A>node set, and <A NAME="50334051_marker-9552"></A>side set IDs, respectively, by requesting the property name &quot;ID.&quot; One should also note that this same function can be accomplished with multiple calls to <EM CLASS="code">
ex_get_prop</EM>
 (or <EM CLASS="code">
EXGP</EM>
 in Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1731"></A>In case of an error, <EM CLASS="code">
ex_get_prop_array</EM>
 returns a negative number; a warning will return a positive number. <EM CLASS="code">
EXGPA</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1732"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2997"></A>invalid object type specified.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2998"></A>a warning value is returned if a property with the specified name is not found.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1733"></A>ex_get_prop_array:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1734"></A><EM CLASS="code">
	int ex_get_prop_array (exoid, obj_type, prop_name, values);</EM>
<A NAME="50334051_marker-117"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1735"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2662"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1736"></A><EM CLASS="code">
int obj_type		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2870"></A>Type of object; use one of the following options: </P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2871"></A><EM CLASS="code">
EX_ELEM_BLOCK</EM>
 	To designate an element block.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2872"></A><EM CLASS="code">
EX_NODE_SET</EM>
 	To designate a node set.</P>
<P CLASS="VarBullet">
<A NAME="50334051_pgfId-2873"></A><EM CLASS="code">
EX_SIDE_SET</EM>
 	To designate a side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1737"></A><EM CLASS="code">
char* prop_name (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2666"></A>The name of the property (maximum length of <EM CLASS="code">
MAX_STR_LENGTH</EM>
) for which the values are desired.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1738"></A><EM CLASS="code">
int* values (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2667"></A>Returned array of property values.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4400"></A>For an example of code to read an array of object properties, refer to the description for <EM CLASS="code">
ex_get_prop_names</EM>
.</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1746"></A>EXGPA:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1747"></A><EM CLASS="code">
	SUBROUTINE EXGPA (IDEXO, ITYPE, NAMEPR, IVALS, IERR)</EM>
<A NAME="50334051_marker-118"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1748"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2668"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1749"></A><EM CLASS="code">
INTEGER ITYPE (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2890"></A>Type of object; use one of the following options: </P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2891"></A><EM CLASS="code">
EXEBLK</EM>
	To designate an element block.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2892"></A><EM CLASS="code">
EXNSET</EM>
	To designate a node set.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-8144"></A><EM CLASS="code">
EXSSET</EM>
 	To designate a side set.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-8145"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMEPR (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-8146"></A>The name of the property for which the values are desired.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1752"></A><EM CLASS="code">
INTEGER IVAL(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2670"></A>Returned array of property values.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1753"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2671"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4780"></A>For an example of code to read an array of object properties, refer to the description for <EM CLASS="code">
EXGPN</EM>
.</P>
<DIV>
<H3 CLASS="FM2Heading">
<A NAME="50334051_pgfId-1006"></A>Results Data</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1759"></A>This section describes functions which read and write analysis results data and related entities.  These include results variables (global, elemental, and nodal), element variable truth table, and simulation times.</P>
</DIV>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1760"></A><A NAME="50334051_29220"></A>Write <A NAME="50334051_marker-489"></A>Results Variables Parameters</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1761"></A>The function <EM CLASS="code">
ex_put_var_param</EM>
 (or <EM CLASS="code">
EXPVP</EM>
 for Fortran) writes the number of global, nodal, or element variables that will be written to the database.  </P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1762"></A>In case of an error, <EM CLASS="code">
ex_put_var_param</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPVP</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1763"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1764"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3001"></A>invalid variable type specified (must be &quot;g&quot;, &quot;G&quot;, &quot;n&quot;, &quot;N&quot;, &quot;e&quot;, or &quot;E&quot;).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2939"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3000"></A>this routine has already been called with the same variable type; redefining the number of variables is not allowed.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2999"></A>a warning value is returned if the number of variables is specified as zero.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1765"></A>ex_put_var_param:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1766"></A><EM CLASS="code">
	int ex_put_var_param (exoid, var_type, num_vars);</EM>
<A NAME="50334051_marker-119"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1767"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2672"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.  </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1768"></A><EM CLASS="code">
char* var_type (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2673"></A>Character indicating the type of variable which is described. Use one of the following options:</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2894"></A>&quot;g&quot; (or &quot;G&quot;) 	For global variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2895"></A>&quot;n&quot; (or &quot;N&quot;)	For nodal variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2896"></A>&quot;e&quot; (or &quot;E&quot;) 	For element variables.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1769"></A><EM CLASS="code">
int num_vars (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2674"></A>The number of <EM CLASS="code">
var_type</EM>
 variables that will be written to the database.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3616"></A>For example, the following code segment initializes the data file to store global variables:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3617"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3422"></A>int num_glo_vars, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3622"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3621"></A>/* write results variables parameters */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3620"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3618"></A>num_glo_vars = 3;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3619"></A>error = ex_put_var_param (exoid, &quot;g&quot;, num_glo_vars);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1770"></A>EXPVP:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1771"></A><EM CLASS="code">
	SUBROUTINE EXPVP (IDEXO, VARTYP, NVAR, IERR)</EM>
<A NAME="50334051_marker-120"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1772"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2675"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1773"></A><EM CLASS="code">
CHARACTER*1 VARTYP (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1774"></A>Character indicating the type of variable which is described. Use one of the following options:  </P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2897"></A>&quot;g&quot; (or &quot;G&quot;) 	For global variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2898"></A>&quot;n&quot; (or &quot;N&quot;) 	For nodal variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2899"></A>&quot;e&quot; (or &quot;E&quot;) 	For element variables.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1775"></A><EM CLASS="code">
INTEGER NVAR (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2676"></A>The number of <EM CLASS="code">
VARTYP</EM>
 variables that will be written to the database.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1776"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2677"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4345"></A>For example, the following code segment initializes the data file to store global variables:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4344"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4347"></A>	 num_glo_vars = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4346"></A>	 call expvp (idexo, &quot;g&quot;, num_glo_vars, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1777"></A><A NAME="50334051_13500"></A>Read <A NAME="50334051_marker-490"></A>Results Variables Parameters</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1778"></A>The function <EM CLASS="code">
ex_get_var_param</EM>
 (or <EM CLASS="code">
EXGVP</EM>
 for Fortran) reads the number of global, nodal, or element variables stored in the database.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1779"></A>In case of an error, <EM CLASS="code">
ex_get_var_param</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGVP</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1780"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1887"></A>invalid variable type specified (must be &quot;g&quot;, &quot;G&quot;, &quot;n&quot;, &quot;N&quot;, &quot;e&quot;, or &quot;E&quot;).</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1781"></A>ex_get_var_param:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1782"></A><EM CLASS="code">
	int ex_get_var_param (exoid, var_type, num_vars);</EM>
<A NAME="50334051_marker-121"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1783"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2678"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
. </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1784"></A><EM CLASS="code">
char* var_type (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1790"></A>Character indicating the type of variable which is described. Use one of the following options:</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-1807"></A>&quot;g&quot; (or &quot;G&quot;) 	For global variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-1826"></A>&quot;n&quot; (or &quot;N&quot;)	For nodal variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2679"></A>&quot;e&quot; (or &quot;E&quot;) 	For element variables.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1785"></A><EM CLASS="code">
int* num_vars (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2680"></A>Returned number of <EM CLASS="code">
var_type</EM>
 variables that are stored in the database.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3623"></A>As an example, the following coding will determine the number of global variables stored in the data file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3624"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3577"></A>int num_glo_vars, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3625"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3626"></A>/* read global variables parameters */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3627"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3628"></A> error = ex_get_var_param (exoid, &quot;g&quot;, &amp;num_glo_vars);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1786"></A>EXGVP:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1787"></A><EM CLASS="code">
	SUBROUTINE EXGVP (IDEXO, VARTYP, NVAR, IERR)</EM>
<A NAME="50334051_marker-122"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1788"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2681"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
. </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1789"></A><EM CLASS="code">
CHARACTER*1 VARTYP (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2906"></A>Character indicating the type of variable which is described. Use one of the following options:  </P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2907"></A>&quot;g&quot; (or &quot;G&quot;) 	For global variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2908"></A>&quot;n&quot; (or &quot;N&quot;) 	For nodal variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2909"></A>&quot;e&quot; (or &quot;E&quot;) 	For element variables.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1791"></A><EM CLASS="code">
INTEGER NVAR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2682"></A>Returned number of <EM CLASS="code">
VARTYP</EM>
 variables that are stored in the database.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1792"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2683"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4351"></A>As an example, the following coding will determine the number of global variables stored in the data file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4354"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4352"></A>	 call exgvp (idexo, &quot;g&quot;, num_glo_vars, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1793"></A><A NAME="50334051_26126"></A>Write <A NAME="50334051_marker-491"></A>Results Variables Names</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1794"></A>The function  <EM CLASS="code">
ex_put_var_names</EM>
 or (<EM CLASS="code">
EXPVAN</EM>
 for Fortran) writes the names of the results variables to the database.  The names are <EM CLASS="code">
MAX_STR_LENGTH</EM>
-characters in length. The function <EM CLASS="code">
ex_put_var_param</EM>
 (<EM CLASS="code">
EXPVP</EM>
 for Fortran) must be called before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1795"></A>In case of an error, <EM CLASS="code">
ex_put_var_names</EM>
 returns a negative number; a warning will return a positive number. <EM CLASS="code">
EXPVAN</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1796"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2940"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3002"></A>invalid variable type specified (must be &quot;g&quot;, &quot;G&quot;, &quot;n&quot;, &quot;N&quot;, &quot;e&quot;, or &quot;E&quot;).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3003"></A><EM CLASS="code">
ex_put_var_param</EM>
 (<EM CLASS="code">
EXPVP</EM>
 for Fortran) was not called previously or was called with zero variables of the specified type.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3004"></A><EM CLASS="code">
ex_put_var_names</EM>
 or (<EM CLASS="code">
EXPVAN</EM>
 for Fortran) has been called previously for the specified variable type.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1797"></A>ex_put_var_names:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1798"></A><EM CLASS="code">
	int ex_put_var_names (exoid, var_type, num_vars, var_names[]);</EM>
<A NAME="50334051_marker-123"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1799"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2684"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.  </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1800"></A><EM CLASS="code">
char* var_type (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2685"></A>Character indicating the type of variable which is described. Use one of the following options:</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2692"></A>&quot;g&quot; (or &quot;G&quot;) 	For global variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2900"></A>&quot;n&quot; (or &quot;N&quot;)	For nodal variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2901"></A>&quot;e&quot; (or &quot;E&quot;) 	For element variables.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1801"></A><EM CLASS="code">
int num_vars (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2686"></A>The number of <EM CLASS="code">
var_type</EM>
 variables that will be written to the database.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1802"></A><EM CLASS="code">
char** var_names (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2687"></A>Array of pointers to <EM CLASS="code">
num_vars</EM>
 variable names.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3629"></A>The following coding will write out the names associated with the nodal variables:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3630"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3578"></A>int num_nod_vars, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3641"></A>char *var_names[2];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3640"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3639"></A>/* write results variables parameters and names */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3637"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3631"></A>num_nod_vars = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3638"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3632"></A>var_names[0] = &quot;disx&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3633"></A>var_names[1] = &quot;disy&quot;;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3634"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3635"></A>error = ex_put_var_param (exoid, &quot;n&quot;, num_nod_vars);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3636"></A>error = ex_put_var_names (exoid, &quot;n&quot;, num_nod_vars, var_names);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1803"></A>EXPVAN:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1804"></A><EM CLASS="code">
	 SUBROUTINE EXPVAN (IDEXO, VARTYP, NVAR,  NAMES, IERR)</EM>
<A NAME="50334051_marker-124"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1805"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-8168"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.  </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-8169"></A><EM CLASS="code">
CHARACTER*1 VARTYP (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-8170"></A>Character indicating the type of variable which is described. Use one of the following options:  </P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2911"></A>&quot;g&quot; (or &quot;G&quot;) 	For global variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2912"></A>&quot;n&quot; (or &quot;N&quot;) 	For nodal variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2913"></A>&quot;e&quot; (or &quot;E&quot;) 	For element variables.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1808"></A><EM CLASS="code">
INTEGER NVAR (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2689"></A>The number of <EM CLASS="code">
VARTYP</EM>
 variables that will be written to the database.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1809"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMES(*)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1810"></A>Array containing <EM CLASS="code">
NVAR</EM>
 variable names.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1811"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2690"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4356"></A>The following coding will write out the names associated with the nodal variables:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4355"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4358"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4360"></A>	 character*(MXSTLN)var_names(1)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4359"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4361"></A>	 var_names(1) = &quot;glo_vars&quot;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4357"></A>	 call expvan (idexo, &quot;g&quot;, num_glo_vars, var_names, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1812"></A><A NAME="50334051_24360"></A>Read <A NAME="50334051_marker-492"></A>Results Variables Names</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1813"></A>The function  <EM CLASS="code">
ex_get_var_names</EM>
 or (<EM CLASS="code">
EXGVAN</EM>
 for Fortran) reads the names of the results variables from the database.  Memory must be allocated for the name array before this function is invoked.  The names are <EM CLASS="code">
MAX_STR_LENGTH</EM>
-characters in length.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1814"></A>In case of an error, <EM CLASS="code">
ex_get_var_names</EM>
 returns a negative number; a warning will return a positive number. <EM CLASS="code">
EXGVAN</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1815"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3005"></A>invalid variable type specified (must be &quot;g&quot;, &quot;G&quot;, &quot;n&quot;, &quot;N&quot;, &quot;e&quot;, or &quot;E&quot;).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3006"></A>a warning value is returned if no variables of the specified type are stored in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1816"></A>ex_get_var_names:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1817"></A><EM CLASS="code">
	int ex_get_var_names (exoid, var_type, num_vars, var_names[]);</EM>
<A NAME="50334051_marker-125"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1818"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2691"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.  </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1819"></A><EM CLASS="code">
char* var_type		</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2902"></A>Character indicating the type of variable which is described. Use one of the following options:</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2903"></A>&quot;g&quot; (or &quot;G&quot;) 	For global variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2904"></A>&quot;n&quot; (or &quot;N&quot;)	For nodal variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2905"></A>&quot;e&quot; (or &quot;E&quot;) 	For element variables.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1820"></A><EM CLASS="code">
int num_vars (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2693"></A>The number of <EM CLASS="code">
var_type</EM>
 variables that will be read from the database.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1821"></A><EM CLASS="code">
char** var_names (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2694"></A>Returned array of pointers to <EM CLASS="code">
num_vars</EM>
 variable names.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3643"></A>As an example, the following code segment will read the names of the nodal variables stored in the data file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3644"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3582"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3654"></A>int error, exoid, num_nod_vars;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3655"></A>char *var_names[10];</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3656"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3652"></A>/* read nodal variables parameters and names */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3649"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3645"></A>error = ex_get_var_param (exoid, &quot;n&quot;, &amp;num_nod_vars);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3650"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3646"></A>for (i=0; i&lt;num_nod_vars; i++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3647"></A>	var_names[i] = (char *) calloc ((MAX_STR_LENGTH+1), sizeof(char));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3446"></A>error = ex_get_var_names (exoid, &quot;n&quot;, num_nod_vars, var_names);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1822"></A>EXGVAN:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1823"></A><EM CLASS="code">
	 SUBROUTINE EXGVAN (IDEXO, VARTYP, NVAR, NAMES, IERR)</EM>
<A NAME="50334051_marker-126"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1824"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2695"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
. </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1825"></A><EM CLASS="code">
CHARACTER*1 VARTYP (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2914"></A>Character indicating the type of variable which is described. Use one of the following options:  </P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2915"></A>&quot;g&quot; (or &quot;G&quot;) 	For global variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2916"></A>&quot;n&quot; (or &quot;N&quot;) 	For nodal variables.</P>
<P CLASS="VarBulletsh">
<A NAME="50334051_pgfId-2917"></A>&quot;e&quot; (or &quot;E&quot;) 	For element variables.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1827"></A><EM CLASS="code">
INTEGER NVAR (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2696"></A>The number of <EM CLASS="code">
VARTYP</EM>
 variables that will be read from the database.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1828"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMES(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1829"></A>Returned array containing <EM CLASS="code">
NVAR</EM>
 (returned from a call to <EM CLASS="code">
EXGVP</EM>
) variable names.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1830"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2697"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4363"></A>As an example, the following code segment will read the names of the global variables stored in the data file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4364"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3586"></A>c NOTE: 		MAXVARS is the maximum number of global variables</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3589"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4371"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4368"></A>	 character*(MXSTLN) var_names(MAXVARS)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4362"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4365"></A>c read global variables parameters and names</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4366"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4367"></A>	 call exgvp (idexo, &quot;g&quot;, num_glo_vars, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4369"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4370"></A>	 call exgvan (idexo, &quot;g&quot;, num_glo_vars, var_names, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-2066"></A><A NAME="50334051_33640"></A>Write Time Value for a Time Step</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-2067"></A>The function <EM CLASS="code">
ex_put_time</EM>
 (or <EM CLASS="code">
EXPTIM</EM>
 for Fortran) writes the <A NAME="50334051_marker-493"></A>time value for a specified time step.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2068"></A>Because time values are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2069"></A>In case of an error, <EM CLASS="code">
ex_put_time</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPTIM</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2070"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2071"></A>data file opened for read only.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2072"></A>ex_put_time:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2073"></A><EM CLASS="code">
	int ex_put_time (exoid, time_step, time_value);</EM>
<A NAME="50334051_marker-127"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2074"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2698"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.  </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2075"></A><EM CLASS="code">
int time_step (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2699"></A>The time step number.  This is essentially a counter that is incremented only when results variables are output to the data file. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2076"></A><EM CLASS="code">
void* time_value (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2700"></A>The time at the specified time step.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3658"></A>The following code segment will write out the simulation time value at simulation time step n:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3659"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3592"></A>int error, exoid, n;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3663"></A>float time_value;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3664"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3662"></A>/* write time value */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3661"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3660"></A>error = ex_put_time (exoid, n, &amp;time_value);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2077"></A>EXPTIM:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2078"></A><EM CLASS="code">
	SUBROUTINE EXPTIM (IDEXO, NSTEP, TIME, IERR)</EM>
<A NAME="50334051_marker-128"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2079"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2701"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
. </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2080"></A><EM CLASS="code">
INTEGER NSTEP	 (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2702"></A>The time step number.  This essentially a counter that is incremented only when results variables are output to the data file. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2081"></A><EM CLASS="code">
REAL TIME (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2703"></A>The time at the specified time step.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2082"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2704"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4373"></A>The following code segment will write out the simulation time value at simulation time step n:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4372"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4379"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4374"></A>c write time value to file</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4375"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4376"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4377"></A>	 call exptim (idexo, n, time_value, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-2083"></A><A NAME="50334051_15529"></A>Read Time Value for a Time Step</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-2084"></A>The function <EM CLASS="code">
ex_get_time</EM>
 (or <EM CLASS="code">
EXGTIM</EM>
 for Fortran) reads the <A NAME="50334051_marker-494"></A>time value for a specified time step.  </P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2085"></A>Because time values are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2086"></A>In case of an error, <EM CLASS="code">
ex_get_time</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGTIM</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2087"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2941"></A>no time steps have been stored in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2088"></A>ex_get_time:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2089"></A><EM CLASS="code">
	int ex_get_time (exoid, time_step, time_value);</EM>
<A NAME="50334051_marker-129"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2090"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2705"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.  </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2091"></A><EM CLASS="code">
int time_step (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2706"></A>The time step number.  This is essentially an index (in the time dimension) into the global, nodal, and element variables arrays stored in the database. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2092"></A><EM CLASS="code">
void* time_value (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2707"></A>Returned time at the specified time step.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3665"></A>As an example, the following coding will read the time value stored in the data file for time step <EM CLASS="code">
n</EM>
:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3666"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3595"></A>int n, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3671"></A>float time_value;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3672"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3670"></A>/* read time value at time step 3 */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3669"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3667"></A>n = 3;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3668"></A>error = ex_get_time (exoid, n, &amp;time_value);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2093"></A>EXGTIM:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2094"></A><EM CLASS="code">
	SUBROUTINE EXGTIM (IDEXO, NSTEP, TIME, IERR)</EM>
<A NAME="50334051_marker-10046"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2095"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2708"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.  </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2096"></A><EM CLASS="code">
INTEGER NSTEP (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2709"></A>The time step number.  This is essentially an index (in the time dimension) into the global, nodal, and element variables arrays stored in the database. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2097"></A><EM CLASS="code">
REAL TIME (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2710"></A>Returned time at the specified time step.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2098"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2711"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4382"></A>As an example, the following coding will read the time value stored in the data file for time step <EM CLASS="code">
n</EM>
:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4388"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4383"></A>c read time value at time step 3</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4384"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4385"></A>	 n = 3</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4386"></A>	 call exgtim (idexo, n, time_value, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-2099"></A><A NAME="50334051_34299"></A>Read All Time Values</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-2100"></A>The function <EM CLASS="code">
ex_get_all_times</EM>
 (or <EM CLASS="code">
EXGATM</EM>
 for Fortran) reads the <A NAME="50334051_marker-495"></A>time values for all time steps.  Memory must be allocated for the time values array before this function is invoked.  The storage requirements (equal to the number of time steps) can be determined by using the <EM CLASS="code">
ex_inquire</EM>
 (or <EM CLASS="code">
EXINQ</EM>
 in Fortran) routine. See <A HREF="exodusII.book.html#50334051_23612" CLASS="XRef">See Inquire EXODUS Parameters</A>.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2102"></A>Because time values are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2103"></A>In case of an error, <EM CLASS="code">
ex_get_all_times</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGATM</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2104"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3008"></A>no time steps have been stored in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2105"></A>ex_get_all_times:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2106"></A><EM CLASS="code">
	int ex_get_all_times (exoid, time_values);</EM>
<A NAME="50334051_marker-130"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2107"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2712"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.  </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2108"></A><EM CLASS="code">
void* time_values (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2713"></A>Returned array of times.  These are the time values at all time steps.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3673"></A>The following code segment will read the time values for all time steps stored in the data file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3674"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3598"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3685"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3448"></A>int error, exoid, num_time_steps;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3686"></A>float *time_values;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3687"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3683"></A>/* determine how many time steps are stored */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3680"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3682"></A>error = ex_inquire (exoid, EX_INQ_TIME, &amp;num_time_steps,</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3688"></A>		&amp;fdum, cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3681"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3679"></A>/* read time values at all time steps */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3677"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3675"></A>time_values = (float *) calloc (num_time_steps, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3678"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3676"></A>error = ex_get_all_times (exoid, time_values);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2109"></A>EXGATM:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2110"></A><EM CLASS="code">
	SUBROUTINE EXGATM (IDEXO, TIME, IERR)</EM>
<A NAME="50334051_marker-131"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2111"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2714"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
. </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2112"></A><EM CLASS="code">
REAL TIME(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2715"></A>Returned array of times.  These are the time values at all time steps.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2113"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2716"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4390"></A>The following code segment will read the time values for all time steps stored in the data file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4389"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3611"></A>c NOTE:		MAXTIM is the maximum number of time steps</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3648"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4398"></A>	 include 'exodusII.inc'</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4399"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4402"></A>	 real time_values(MAXTIM)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4401"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4391"></A>c determine how many time steps are stored; this can be used if dynamic</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4404"></A>c memory allocation is available</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4392"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4403"></A>	 call exinq (idexo, EXTIMS, num_time_steps, fdum, cdum, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4394"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4395"></A>c read time values at all time steps</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4396"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4397"></A>	 call exgatm (idexo, time_values, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1831"></A><A NAME="50334051_31128"></A>Write Element Variable Truth Table</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1832"></A>The function <EM CLASS="code">
ex_put_elem_var_tab</EM>
 (or <EM CLASS="code">
EXPVTT</EM>
 for Fortran) writes the EXODUS II <A NAME="50334051_marker-496"></A>element variable truth table to the database.  The element variable truth table indicates whether a particular element result is written for the elements in a particular element block.  A 0 (zero) entry indicates that no results will be output for that element variable for that element block.  A non-zero entry indicates that the appropriate results will be output.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1833"></A>Although writing the element variable truth table is optional, it is encouraged because it creates at one time all the necessary netCDF variables in which to hold the EXODUS element variable values.  This results in significant time savings. See Appendix A for a discussion of efficiency issues.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1834"></A>The function <EM CLASS="code">
ex_put_var_param</EM>
 (or <EM CLASS="code">
EXPVP</EM>
 for Fortran) must be called before this routine in order to define the number of element variables.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1835"></A>In case of an error, <EM CLASS="code">
ex_put_elem_var_tab</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPVTT</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1836"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1837"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1838"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3010"></A>the specified number of element blocks is different than the number specified in a call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3011"></A><EM CLASS="code">
ex_put_elem_block</EM>
 (or <EM CLASS="code">
EXPELB</EM>
 for Fortran) not called previously to specify element block parameters. </P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3009"></A><EM CLASS="code">
ex_put_var_param</EM>
 (or <EM CLASS="code">
EXPVP</EM>
 for Fortran) not called previously to specify the number of element variables or was called but with a different number of element variables.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3007"></A><EM CLASS="code">
ex_put_elem_var</EM>
 previously called.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-776"></A>ex_put_elem_var_tab:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1839"></A><EM CLASS="code">
	int ex_put_elem_var_tab (exoid, num_elem_blk, num_elem_var, elem_var_tab);</EM>
<A NAME="50334051_marker-132"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1840"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1841"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1842"></A><EM CLASS="code">
int num_elem_blk (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1843"></A>The number of element blocks.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2717"></A><EM CLASS="code">
int num_elem_var (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2718"></A>The number of element variables.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2719"></A><EM CLASS="code">
int elem_var_tab[num_elem_blk,num_elem_var] (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2720"></A>A 2-dimensional array (with the <EM CLASS="code">
num_elem_var</EM>
 index cycling faster) containing the element variable truth table.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3690"></A>The following coding will create, populate, and write an element variable truth table to an opened EXODUS II file (NOTE: all element variables are valid for all element blocks in this example.):</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3691"></A>int *truth_tab, num_elem_blk, num_ele_vars, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3698"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3696"></A>/* write element variable truth table */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3694"></A>truth_tab = (int *) calloc ((num_elem_blk*num_ele_vars), sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3693"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3695"></A>for (i=0, k=0; i&lt;num_elem_blk; i++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3697"></A>	for (j=0; j&lt;num_ele_vars; j++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3699"></A>		truth_tab[k++] = 1;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3702"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3703"></A>error = ex_put_elem_var_tab (exoid, num_elem_blk, num_ele_vars, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3464"></A>		truth_tab);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1844"></A>EXPVTT:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1845"></A><EM CLASS="code">
	SUBROUTINE EXPVTT (IDEXO, NELBLK, NVAREL, ISEVOK, IERR)</EM>
<A NAME="50334051_marker-133"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1846"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2721"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1847"></A><EM CLASS="code">
INTEGER NELBLK (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2722"></A>The number of element blocks.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1848"></A><EM CLASS="code">
INTEGER NVAREL (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2723"></A>The number of element variables.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1849"></A><EM CLASS="code">
INTEGER ISEVOK(NVAREL,NELBLK) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1850"></A>A 2-dimensional array (with the <EM CLASS="code">
NVAREL</EM>
 index cycling faster) containing the element variable truth table.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1852"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2725"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4405"></A>The following coding will create, populate, and write an element variable truth table to an opened EXODUS II file. (NOTE: all element variables are valid for all element blocks in this example.):</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-8595"></A>	 integer truth_tab(num_ele_vars,num_elem_blk)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4408"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4406"></A>c write element variable truth table</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4907"></A>	 icnt = 0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4411"></A>	 do 30 i = 1,num_elem_blk</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4412"></A>		 do 20 j = 1,num_ele_vars</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4413"></A>			 truth_tab(j,i) = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4414"></A>20 		 continue</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4415"></A>30 	 continue</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4421"></A>	 call expvtt (idexo, num_elem_blk, num_ele_vars, truth_tab, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1853"></A><A NAME="50334051_22499"></A>Read Element Variable Truth Table</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1854"></A>The function <EM CLASS="code">
ex_get_elem_var_tab</EM>
 (or <EM CLASS="code">
EXGVTT</EM>
 for Fortran) reads the EXODUS II <A NAME="50334051_marker-497"></A>element variable truth table from the database.  For a description of the truth table, see the usage of the function <EM CLASS="code">
ex_put_elem_var_tab</EM>
.  Memory must be allocated for the truth table (<EM CLASS="code">
num_elem_blk</EM>
 * <EM CLASS="code">
num_elem_var</EM>
 in length) before this function is invoked. If the truth table is not stored in the file, it will be created based on information in the file and then returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1855"></A>In case of an error, <EM CLASS="code">
ex_get_elem_var_tab</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGVTT</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1856"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3012"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3013"></A>the specified number of element blocks is different than the number specified in a call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3015"></A>there are no element variables stored in the file or the specified number of element variables doesn't match the number specified in a call to <EM CLASS="code">
ex_put_var_param</EM>
 (or <EM CLASS="code">
EXPVP</EM>
 for Fortran).</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1858"></A>ex_get_elem_var_tab:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1859"></A><EM CLASS="code">
	int ex_get_elem_var_tab (exoid, num_elem_blk, num_elem_var, elem_var_tab);</EM>
<A NAME="50334051_marker-134"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1860"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2726"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1861"></A><EM CLASS="code">
int num_elem_blk (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2727"></A>The number of element blocks.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1862"></A><EM CLASS="code">
int num_elem_var (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2728"></A>The number of element variables.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1863"></A><EM CLASS="code">
int elem_var_tab[num_elem_blk,num_elem_var]</EM>
 (W)</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2729"></A>Returned 2-dimensional array (with the <EM CLASS="code">
num_elem_var</EM>
 index cycling faster) containing the element variable truth table.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3704"></A>As an example, the following coding will read the element variable truth table from an opened EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3712"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3706"></A>int *truth_tab, num_elem_blk, num_ele_vars, error, exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3711"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3707"></A>truth_tab = (int *) calloc ((num_elem_blk*num_ele_vars), sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3708"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3709"></A>error = ex_get_elem_var_tab (exoid, num_elem_blk, num_ele_vars, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3469"></A>		truth_tab);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1864"></A>EXGVTT:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1865"></A><EM CLASS="code">
	SUBROUTINE EXGVTT (IDEXO, NELBLK, NVAREL, ISEVOK, IERR)</EM>
<A NAME="50334051_marker-135"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1866"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2730"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1867"></A><EM CLASS="code">
INTEGER NELBLK (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2731"></A>The number of element blocks.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1868"></A><EM CLASS="code">
INTEGER NVAREL (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2732"></A>The number of element variables.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1869"></A><EM CLASS="code">
INTEGER ISEVOK(NVAREL, NELBLK) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-1870"></A>Returned 2-dimensional array (with the <EM CLASS="code">
NVAREL</EM>
 index cycling faster) containing the element variable truth table.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1871"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2733"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4417"></A>As an example, the following coding will read the element variable truth table from an opened EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3710"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4410"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4422"></A>	 integer truth_tab(num_ele_vars,num_elem_blk)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4423"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4418"></A>c read element variable truth table</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4419"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4420"></A>	 call exgvtt (idexo, num_elem_blk, num_ele_vars, truth_tab, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1996"></A><A NAME="50334051_38391"></A>Write <A NAME="50334051_marker-498"></A>Element Variable Values at a Time Step</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1997"></A>The function <EM CLASS="code">
ex_put_elem_var</EM>
 (or <EM CLASS="code">
EXPEV</EM>
 for Fortran) writes the values of a single element variable for one element block at one time step. It is recommended, but not required, to write the element variable truth table (with <EM CLASS="code">
ex_put_elem_var_tab</EM>
 for C; <EM CLASS="code">
EXPVTT</EM>
 for Fortran) before this function is invoked for better efficiency. See Appendix A for a discussion of efficiency issues.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1998"></A>Because element variables are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1999"></A>In case of an error, <EM CLASS="code">
ex_put_elem_var</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPEV</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2000"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2001"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2942"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3014"></A>invalid element block ID.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3016"></A><EM CLASS="code">
ex_put_elem_block</EM>
 (or <EM CLASS="code">
EXPELB</EM>
 for Fortran) not called previously to specify parameters for this element block. </P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2003"></A><EM CLASS="code">
ex_put_var_param</EM>
 (or <EM CLASS="code">
EXPVP</EM>
 for Fortran) not called previously specifying the number of element variables.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-8621"></A>an element variable truth table was stored in the file but contains a zero (indicating no valid element variable) for the specified element block and element variable.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2002"></A>ex_put_elem_var:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-3017"></A><EM CLASS="code">
	int ex_put_elem_var (exoid, time_step, elem_var_index, elem_blk_id, num_elem_this_blk, elem_var_vals);</EM>
<A NAME="50334051_marker-136"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2004"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2734"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2005"></A><EM CLASS="code">
int time_step (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2735"></A>The time step number, as described under <EM CLASS="code">
ex_put_time</EM>
.  This is essentially a counter that is incremented only when results variables are output. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2006"></A><EM CLASS="code">
int elem_var_index (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2736"></A>The index of the element variable. The first variable has an index of 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2007"></A><EM CLASS="code">
int elem_blk_id (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2737"></A>The element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2008"></A><EM CLASS="code">
int num_elem_this_blk (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2738"></A>The number of elements in the given element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2009"></A><EM CLASS="code">
void* elem_var_vals (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2739"></A>Array of <EM CLASS="code">
num_elem_this_blk</EM>
 values of the <EM CLASS="code">
elem_var_index</EM>
th element variable for the element block with ID of <EM CLASS="code">
elem_blk_id</EM>
 at the <EM CLASS="code">
time_step</EM>
th time step.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3715"></A>The following coding will write out all of the element variables for a single time step <EM CLASS="code">
n</EM>
 to an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3716"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4341"></A>int num_ele_vars, num_elem_blk, *num_elem_in_block,error, exoid, n, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3470"></A>	*ebids;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3733"></A>float *elem_var_vals;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3734"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3726"></A>/* write element variables */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3717"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3718"></A>for (k=1; k&lt;=num_ele_vars; k++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3719"></A>{</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3720"></A>	for (j=0; j&lt;num_elem_blk; j++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3721"></A>	{</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3735"></A>		elem_var_vals = (float *) </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3481"></A>			calloc (num_elem_in_block[j], sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3737"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3722"></A>		for (m=0; m&lt;num_elem_in_block[j]; m++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3723"></A>		{</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3725"></A>			/* simulation code fills this in */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3724"></A>			elem_var_vals[m] = 10.0; </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3727"></A>		}</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3728"></A>		error = ex_put_elem_var (exoid, n, k, ebids[j],</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3483"></A>			num_elem_in_block[j], elem_var_vals);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3738"></A>		free (elem_var_vals);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3731"></A>	}</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3732"></A>}</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2010"></A>EXPEV:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2011"></A><EM CLASS="code">
	SUBROUTINE EXPEV (IDEXO, ISTEP, IXELEV, IDELB, NUMELB, VALEV, IERR)</EM>
<A NAME="50334051_marker-137"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2012"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2740"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2013"></A><EM CLASS="code">
INTEGER ISTEP (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2741"></A>The time step number, as described under <EM CLASS="code">
EXPTIM</EM>
.  This is essentially a counter that is incremented only when results variables are output. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2014"></A><EM CLASS="code">
INTEGER IXELEV (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2742"></A>The index of the element variable. The first variable has an index of 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2015"></A><EM CLASS="code">
INTEGER IDELB (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2743"></A>The element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2016"></A><EM CLASS="code">
INTEGER NUMELB (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2744"></A>The number of elements in the given element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2017"></A><EM CLASS="code">
REAL VALEV(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2745"></A>Array of <EM CLASS="code">
NUMELB</EM>
 values of the <EM CLASS="code">
IXELEV</EM>
th element variable for the element block with ID of <EM CLASS="code">
IDELB</EM>
 at the <EM CLASS="code">
ISTEP</EM>
th time step.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2018"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2746"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4425"></A>The following coding will write out all of the element variables for a single time step <EM CLASS="code">
n</EM>
 to an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4424"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4448"></A>c NOTE: 		MAXEBK is maximum number of element blocks</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4449"></A>c		MAXELB is maximum number of elements per block</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4450"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4441"></A>	 integer num_elem_in_block(MAXEBK)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4443"></A>	 real elem_var_vals(MAXELB)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4442"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4426"></A>c write element variables</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4427"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4428"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4429"></A>	 do 100 k = 1, num_ele_vars</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4430"></A>		do 90 j = 1, num_elem_blk</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4431"></A>			do 80 m = 1, num_elem_in_block(j)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4432"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4434"></A>c analysis code fills this array</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4440"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4433"></A>				elem_var_vals(m) = 10.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4435"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4436"></A>80 			continue</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4437"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4438"></A>			call expev (idexo, n, k, num_elem_in_block(j), </P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4439"></A>	1 			elem_var_vals, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4444"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4445"></A>90 		continue</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4446"></A>100	 continue</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-2019"></A><A NAME="50334051_29752"></A>Read <A NAME="50334051_marker-499"></A>Element Variable Values at a Time Step</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-2020"></A>The function <EM CLASS="code">
ex_get_elem_var</EM>
 (or <EM CLASS="code">
EXGEV</EM>
 for Fortran) reads the values of a single element variable for one element block at one time step.  Memory must be allocated for the element variable values array before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2021"></A>Because element variables are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2022"></A>In case of an error, <EM CLASS="code">
ex_get_elem_var</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGEV</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2023"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2024"></A>variable does not exist for the desired element block.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3018"></A>invalid element block.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2025"></A>ex_get_elem_var:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2026"></A><EM CLASS="code">
	int ex_get_elem_var  (exoid, time_step, elem_var_index, elem_blk_id, num_elem_this_blk, elem_var_vals);</EM>
<A NAME="50334051_marker-138"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2027"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2747"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2028"></A><EM CLASS="code">
int time_step (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2748"></A>The time step number, as described under <EM CLASS="code">
ex_put_time</EM>
, at which the element variable values are desired.  This is essentially an index (in the time dimension) into the element variable values array stored in the database. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2029"></A><EM CLASS="code">
int elem_var_index (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2749"></A>The index of the desired element variable. The first variable has an index of 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2030"></A><EM CLASS="code">
int elem_blk_id (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2750"></A>The desired element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2031"></A><EM CLASS="code">
int num_elem_this_blk (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2751"></A>The number of elements in this element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2032"></A><EM CLASS="code">
void* elem_var_vals (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2752"></A>Returned array of <EM CLASS="code">
num_elem_this_blk</EM>
 values of the e<EM CLASS="code">
lem_var_index</EM>
th element variable for the element block with ID of <EM CLASS="code">
elem_blk_id</EM>
 at the <EM CLASS="code">
time_step</EM>
th time step.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3739"></A>As an example, the following code segment will read the <EM CLASS="code">
var_index</EM>
th element variable at one time step stored in an EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3740"></A>int *ids, num_elem_blk, error, exoid, *num_elem_in_block, step, var_ind;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3756"></A>float *var_vals;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3742"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-9339"></A>ids = (int *) calloc(num_elem_blk, sizeof(int));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3744"></A>error = ex_get_elem_blk_ids (exoid, ids);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3746"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3758"></A>step = 1; /* read at the first time step */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3747"></A>for (i=0; i&lt;num_elem_blk; i++) {</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3486"></A>	var_vals = (float *) calloc (num_elem_in_block[i], sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3490"></A>	error = ex_get_elem_var (exoid, step, var_ind, ids[i], </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3743"></A>			num_elem_in_block[i], var_vals);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3749"></A>	free (var_values); }</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2033"></A>EXGEV:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2034"></A><EM CLASS="code">
	SUBROUTINE EXGEV (IDEXO, ISTEP, IXELEV, IDELB, NUMELB, VALEV, IERR)</EM>
<A NAME="50334051_marker-139"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2035"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2753"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2036"></A><EM CLASS="code">
INTEGER ISTEP (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2754"></A>The time step number, as described under <EM CLASS="code">
EXPTIM</EM>
, at which the element variable is desired.  This is essentially an index (in the time dimension) into the element variable values array stored in the database. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2037"></A><EM CLASS="code">
INTEGER IXELEV (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2755"></A>The index of the desired element variable. The first variable has an index of 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2038"></A><EM CLASS="code">
INTEGER IDELB (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2756"></A>The desired element block ID.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2039"></A><EM CLASS="code">
INTEGER NUMELB (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2757"></A>The number of elements in this element block.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2040"></A><EM CLASS="code">
REAL VALEV(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2758"></A>Returned array of <EM CLASS="code">
NUMELB</EM>
 values of the <EM CLASS="code">
IXELEV</EM>
th element variable for the element block with ID of <EM CLASS="code">
IDELB</EM>
 at the <EM CLASS="code">
ISTEP</EM>
th time step.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2041"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2759"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4452"></A>As an example, the following code segment will read the <EM CLASS="code">
var_index</EM>
th element variable at one time step stored in an EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4454"></A>c NOTE: 		MAXEBK is maximum number of element blocks</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4459"></A>c		MAXELB is maximum number of elements per block</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4453"></A>	 integer ids(MAXEBK), var_index, num_elem_in_block(MAXEBK)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4462"></A>	 real var_values(MAXELB)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4455"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4447"></A>	 call exgebi (idexo, ids, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4457"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4458"></A>	 do 10 i = 1, num_elem_blk</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4460"></A>		call exgev (idexo, istep, var_index, ids(i),</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4461"></A>	1 		num_elem_in_block(i), var_values, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4456"></A>10	 continue</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-2042"></A><A NAME="50334051_32150"></A>Read <A NAME="50334051_marker-500"></A>Element Variable Values through Time</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-2043"></A>The function <EM CLASS="code">
ex_get_elem_var_time</EM>
 (or <EM CLASS="code">
EXGEVT</EM>
 for Fortran) reads the values of an element variable for a single element through a specified number of time steps.  Memory must be allocated for the element variable values array before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2044"></A>Because element variables are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2045"></A>In case of an error, <EM CLASS="code">
ex_get_elem_var_time</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGEVT</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2046"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3019"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3020"></A><EM CLASS="code">
ex_put_elem_block</EM>
 (or <EM CLASS="code">
EXPELB</EM>
 for Fortran) not called previously to specify parameters for all element blocks. </P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2047"></A>variable does not exist for the desired element or results haven't been written.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2048"></A>ex_get_elem_var_time:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2049"></A><EM CLASS="code">
	int ex_get_elem_var_time (exoid, int elem_var_index, int elem_number, int beg_time_step, int end_time_step, elem_var_vals);</EM>
<A NAME="50334051_marker-140"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2050"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2760"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2051"></A><EM CLASS="code">
int elem_var_index (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2761"></A>The index of the desired element variable. The first variable has an index of 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2052"></A><EM CLASS="code">
int elem_number (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2762"></A>The internal ID (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>) of the desired element. The first element is 1. </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2053"></A><EM CLASS="code">
int beg_time_step (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2763"></A>The beginning time step for which an element variable value is desired.  This is not a time value but rather a time step number, as described under <EM CLASS="code">
ex_put_time</EM>
. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2054"></A><EM CLASS="code">
int end_time_step (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2764"></A>The last time step for which an element variable value is desired.  If negative, the last time step in the database will be used. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2055"></A><EM CLASS="code">
void* elem_var_vals (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2765"></A>Returned array of (<EM CLASS="code">
end_time_step</EM>
 - <EM CLASS="code">
beg_time_step</EM>
 + 1) values of the <EM CLASS="code">
elem_number</EM>
th element for the e<EM CLASS="code">
lem_var_index</EM>
th element variable.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3759"></A>For example, the following coding will read the values of the <EM CLASS="code">
var_index</EM>
th element variable for element number 2 from the first time step to the last time step:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3760"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4451"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3780"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3781"></A>int error, exoid, num_time_steps, var_index, elem_num, beg_time, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3493"></A>	end_time;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3783"></A>float *var_values;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3784"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3770"></A>/* determine how many time steps are stored */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3763"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3771"></A>error = ex_inquire (exoid, EX_INQ_TIME, &amp;num_time_steps, &amp;fdum, cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3766"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3772"></A>/* read an element variable through time */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3761"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3773"></A>var_values = (float *) calloc (num_time_steps, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3762"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3767"></A>var_index = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3768"></A>elem_num = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3769"></A>beg_time = 1;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3775"></A>end_time = -1;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3776"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3774"></A>error = ex_get_elem_var_time (exoid, var_index, elem_num, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3779"></A>		beg_time, end_time, var_values);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2056"></A>EXGEVT:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2057"></A><EM CLASS="code">
	SUBROUTINE EXGEVT (IDEXO, IXELEV, IELNUM, ISTPB, ISTPE, VALEV, IERR)</EM>
<A NAME="50334051_marker-141"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2058"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2766"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2059"></A><EM CLASS="code">
INTEGER IXELEV (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2767"></A>The index of the desired element variable. The first variable has an index of 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2060"></A><EM CLASS="code">
INTEGER IELNUM (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2768"></A>The internal ID (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>) of the desired element. The first element is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2061"></A><EM CLASS="code">
INTEGER ISTPB (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2769"></A>The beginning time step for which an element variable value is desired.  This is not a time value but rather a time step number, as described under <EM CLASS="code">
EXPTIM</EM>
. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2062"></A><EM CLASS="code">
INTEGER ISTPE (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2770"></A>The last time step for which an element variable value is desired.  If negative, the last time step in the database will be used. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2063"></A><EM CLASS="code">
REAL VALEV(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2771"></A>Returned array of (<EM CLASS="code">
ISTPE</EM>
 - <EM CLASS="code">
ISTPB</EM>
 + 1) values of the <EM CLASS="code">
IELNUM</EM>
th element for the <EM CLASS="code">
IXELEV</EM>
th element variable.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2064"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2772"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3748"></A>For example, the following coding will read the values of the <EM CLASS="code">
var_index</EM>
th element variable for element number 2 from the first time step to the last time step:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3741"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4468"></A>c NOTE:		MAXVAL is the maximum number of values to be read</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4469"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4465"></A>	 integer var_index, elem_num, beg_time, end_time</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4467"></A>	 real var_values(MAXVAL)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4466"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3750"></A>c read an element variable through time</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3751"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3752"></A>	 var_index = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3754"></A>	 elem_num = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4463"></A>	 beg_time = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4464"></A>	 end_time = -1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3757"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3764"></A>	 call exgevt (idexo, var_index, elem_num, beg_time, end_time,</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3765"></A>	1	var_values, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1564"></A><A NAME="50334051_37477"></A>Write <A NAME="50334051_marker-501"></A>Global Variables Values at a Time Step</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-2124"></A>The function <EM CLASS="code">
ex_put_glob_vars</EM>
 (or <EM CLASS="code">
EXPGV</EM>
 for Fortran) writes the values of all the global variables for a single time step.  The function <EM CLASS="code">
ex_put_var_param</EM>
 (<EM CLASS="code">
EXPVP</EM>
 for Fortran) must be invoked before this call is made.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2140"></A>Because global variables are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-2142"></A>In case of an error, <EM CLASS="code">
ex_put_glob_vars</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPGV</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2143"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2144"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3021"></A><EM CLASS="code">
ex_put_var_param</EM>
 (or <EM CLASS="code">
EXPVP</EM>
 for Fortran) not called previously specifying the number of global variables.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2145"></A>ex_put_glob_vars:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2147"></A><EM CLASS="code">
	int ex_put_glob_vars (exoid, time_step, num_glob_vars, glob_var_vals);</EM>
<A NAME="50334051_marker-142"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2148"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2065"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2149"></A><EM CLASS="code">
int time_step (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2773"></A>The time step number, as described under <EM CLASS="code">
ex_put_time</EM>
.  This is essentially a counter that is incremented when results variables are output. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2154"></A><EM CLASS="code">
int num_glob_vars (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2774"></A>The number of global variables to be written to the database.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2155"></A><EM CLASS="code">
void* glob_var_vals (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2775"></A>Array of <EM CLASS="code">
num_glob_vars</EM>
 global variable values for the <EM CLASS="code">
time_step</EM>
th time step.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3785"></A>As an example, the following coding will write the values of all the global variables at one time step to an open EXODUS II file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4618"></A>int num_glo_vars, error, exoid, time_step;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3794"></A>float *glob_var_vals</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3795"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3791"></A>/* write global variables */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3797"></A>for (j=0; j&lt;num_glo_vars; j++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3790"></A>	/* application code fills this array */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3796"></A>	glob_var_vals[j] = 10.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-9816"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3793"></A>error = ex_put_glob_vars (exoid, time_step, num_glo_vars, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3498"></A>		glob_var_vals);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-2247"></A>EXPGV:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-2248"></A><EM CLASS="code">
	SUBROUTINE EXPGV (IDEXO, ISTEP, NVARGL, VALGV, IERR)</EM>
<A NAME="50334051_marker-143"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2251"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2776"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2252"></A><EM CLASS="code">
INTEGER ISTEP (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2777"></A>The time step number, as described under <EM CLASS="code">
EXPTIM</EM>
.  This is essentially a counter that is incremented only when results variables are output.  The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2253"></A><EM CLASS="code">
INTEGER NVARGL (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2778"></A>The number of global variables to be written to the database.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2254"></A><EM CLASS="code">
REAL VALGV(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2779"></A>Array of <EM CLASS="code">
NVARGL</EM>
 global variable values for the <EM CLASS="code">
ISTEP</EM>
th time step.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-2255"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2780"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4471"></A>As an example, the following coding will write the values of all the global variables at one time step to an open EXODUS II file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4470"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4486"></A>c NOTE:		MAXGVAR is the maximum number of global variables</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4487"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4483"></A>	 integer num_glo_vars</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4485"></A>	 real glob_var_vals(MAXGVAR)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4484"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4472"></A>c write all global variables for time step istep</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4473"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4474"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4475"></A>	 do 50 j = 1, num_glo_vars</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4480"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4481"></A>c application code fills in this array</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4482"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4476"></A>		glob_var_vals(j) = 10.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4477"></A>50	 continue</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4478"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4479"></A>	 call expgv (idexo, istep, num_glo_vars, glob_var_vals, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1891"></A><A NAME="50334051_39653"></A>Read <A NAME="50334051_marker-502"></A>Global Variables Values at a Time Step</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1892"></A>The function <EM CLASS="code">
ex_get_glob_vars</EM>
 (or <EM CLASS="code">
EXGGV</EM>
 for Fortran) reads the values of all the global variables for a single time step.  Memory must be allocated for the global variables values array before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1893"></A>Because global variables are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1894"></A>In case of an error, <EM CLASS="code">
ex_get_glob_vars</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGGV</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1895"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1896"></A>no global variables stored in the file.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3025"></A>a warning value is returned if no global variables are stored in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1897"></A>ex_get_glob_vars:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1898"></A><EM CLASS="code">
	int ex_get_glob_vars (exoid, time_step, num_glob_vars, glob_var_vals);</EM>
<A NAME="50334051_marker-144"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1899"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2781"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open.</EM>
</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1900"></A><EM CLASS="code">
int time_step (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-8252"></A>The time step, as described under <EM CLASS="code">
ex_put_time</EM>
, at which the global variable values are desired.  This is essentially an index (in the time dimension) into the global variable values array stored in the database.  The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-8253"></A><EM CLASS="code">
int num_glob_vars (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-8254"></A>The number of global variables stored in the database.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1902"></A><EM CLASS="code">
void* glob_var_vals (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2784"></A>Returned array of <EM CLASS="code">
num_glob_vars</EM>
 global variable values for the <EM CLASS="code">
time_step</EM>
th time step.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3798"></A>The following is an example code segment that reads all the global variables at one time step:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4619"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3799"></A>int num_glo_vars, error, time_step;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3806"></A>float *var_values;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3807"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3801"></A>error = ex_get_var_param (idexo, &quot;g&quot;, &amp;num_glo_vars);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3808"></A>var_values = (float *) calloc (num_glo_vars, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3803"></A>error = ex_get_glob_vars (idexo, time_step, num_glo_vars, var_values);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1903"></A>EXGGV:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1904"></A><EM CLASS="code">
	SUBROUTINE EXGGV (IDEXO, ISTEP, NVARGL, VALGV, IERR)</EM>
<A NAME="50334051_marker-145"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1905"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2785"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1906"></A><EM CLASS="code">
INTEGER ISTEP (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2786"></A>The time step number, as described under <EM CLASS="code">
EXPTIM</EM>
, at which global variables are desired.  This is essentially an index (in the time dimension) into the global variable values array stored in the database. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1907"></A><EM CLASS="code">
INTEGER NVARGL (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2787"></A>The number of global variables stored in the database.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1908"></A><EM CLASS="code">
REAL VALGV(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2788"></A>Returned array of <EM CLASS="code">
NVARGL</EM>
 global variable values for the <EM CLASS="code">
ISTEP</EM>
th time step.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1909"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2789"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4489"></A>The following is an example code segment that reads all the global variables at one time step:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4488"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4496"></A>c NOTE: MAXGVAR is the maximum number of global variables</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4497"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4495"></A>	 real var_values(MAXGVAR)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4494"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4490"></A>c read all global variables at one time step</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4491"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4492"></A>	 call exggv (idexo, istep, num_glo_vars, var_values, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1910"></A><A NAME="50334051_33485"></A>Read <A NAME="50334051_marker-503"></A>Global Variable Values through Time</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1911"></A>The function <EM CLASS="code">
ex_get_glob_var_time</EM>
 (or <EM CLASS="code">
EXGGVT</EM>
 for Fortran) reads the values of a single global variable through a specified number of time steps.  Memory must be allocated for the global variable values array before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1912"></A>Because global variables are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1913"></A>In case of an error, <EM CLASS="code">
ex_get_glob_var_time</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGGVT</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1914"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3022"></A>specified global variable does not exist.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3026"></A>a warning value is returned if no global variables are stored in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1916"></A>ex_get_glob_var_time:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1917"></A><EM CLASS="code">
	int ex_get_glob_var_time (exoid, glob_var_index, beg_time_step, end_time_step, glob_var_vals);</EM>
<A NAME="50334051_marker-146"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1918"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2790"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1919"></A><EM CLASS="code">
int glob_var_index (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2791"></A>The index of the desired global variable. The first variable has an index of 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1920"></A><EM CLASS="code">
int beg_time_step (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2792"></A>The beginning time step for which a global variable value is desired.  This is not a time value but rather a time step number, as described under <EM CLASS="code">
ex_put_time</EM>
.  The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1921"></A><EM CLASS="code">
int end_time_step (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2793"></A>The last time step for which a global variable value is desired.  If negative, the last time step in the database will be used.  The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1922"></A><EM CLASS="code">
void* glob_var_vals (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2794"></A>Returned array of (<EM CLASS="code">
end_time_step</EM>
 - <EM CLASS="code">
beg_time_step</EM>
 + 1) values for the <EM CLASS="code">
glob_var_index</EM>
th global variable.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3810"></A>The following is an example of using this function:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3800"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3826"></A>int error, exoid, num_time_steps, var_index, beg_time, end_time;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3827"></A>float *var_values;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3828"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3825"></A>/* determine how many time steps are stored */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3823"></A>error = ex_inquire (exoid, EX_INQ_TIME, &amp;num_time_steps, &amp;fdum, cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3821"></A>/* read the first global variable for all time steps */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3812"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3813"></A>var_index = 1;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3814"></A>beg_time = 1;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3815"></A>end_time = -1;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3816"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3817"></A>var_values = (float *) calloc (num_time_steps, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3818"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3819"></A>error = ex_get_glob_var_time (exoid, var_index, beg_time, end_time, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3500"></A>		var_values);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1923"></A>EXGGVT:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1924"></A><EM CLASS="code">
	SUBROUTINE EXGGVT (IDEXO, IXGLOV, ISTPB, ISTPE, VALGV, IERR)</EM>
<A NAME="50334051_marker-147"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1925"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2795"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1926"></A><EM CLASS="code">
INTEGER IXGLOV (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2796"></A>The index of the desired global variable. The first variable has an index of 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1927"></A><EM CLASS="code">
INTEGER ISTPB (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2797"></A>The beginning time step for which a global variable value is desired.  This is not a time value but rather a time step number, as described under <EM CLASS="code">
EXPTIM</EM>
. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1928"></A><EM CLASS="code">
INTEGER ISTPE (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2798"></A>The last time step for which a global variable value is desired.  If negative, the last time step in the database will be used. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1929"></A><EM CLASS="code">
REAL VALGV(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2799"></A>Returned array of (<EM CLASS="code">
ISTPE</EM>
 - <EM CLASS="code">
ISTPB</EM>
 + 1) values for the <EM CLASS="code">
IXGLOV</EM>
th global variable.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1930"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2800"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4499"></A>The following is an example of using this function:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4498"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4506"></A>c NOTE:		MAXVAL is the maximum number of values to be read</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4507"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4503"></A>	 integer var_index, beg_time, end_time</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4505"></A>	 real var_values(MAXVAL)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4504"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4500"></A>c read a single global variable for all time steps</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4501"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4508"></A>	 var_index = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4509"></A>	 beg_time = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4510"></A>	 end_time = -1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4502"></A>	 call exggvt (idexo, var_index, beg_time, end_time, var_values, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1931"></A><A NAME="50334051_19926"></A>Write <A NAME="50334051_marker-504"></A>Nodal Variable Values at a Time Step</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1932"></A>The function <EM CLASS="code">
ex_put_nodal_var</EM>
 (or <EM CLASS="code">
EXPNV</EM>
 for Fortran) writes the values of a single nodal variable for a single time step.  The function <EM CLASS="code">
ex_put_var_param</EM>
 (<EM CLASS="code">
EXPVP</EM>
 for Fortran) must be invoked before this call is made.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1933"></A>Because nodal variables are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1934"></A>In case of an error, <EM CLASS="code">
ex_put_nodal_var</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXPNV</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1935"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1936"></A>data file opened for read only.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-2943"></A>data file not initialized properly with call to <EM CLASS="code">
ex_put_init</EM>
 (<EM CLASS="code">
EXPINI</EM>
 for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1915"></A><EM CLASS="code">
ex_put_var_param</EM>
 (or <EM CLASS="code">
EXPVP</EM>
 for Fortran) not called previously specifying the number of nodal variables.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1937"></A>ex_put_nodal_var:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1938"></A><EM CLASS="code">
	int ex_put_nodal_var (exoid, time_step, nodal_var_index, num_nodes, nodal_var_vals);</EM>
<A NAME="50334051_marker-148"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1939"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2801"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1940"></A><EM CLASS="code">
int time_step (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2802"></A>The time step number, as described under <EM CLASS="code">
ex_put_time</EM>
.  This is essentially a counter that is incremented when results variables are output. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1941"></A><EM CLASS="code">
int nodal_var_index (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2803"></A>The index of the nodal variable. The first variable has an index of 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1942"></A><EM CLASS="code">
int num_nodes (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2804"></A>The number of nodal points.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1943"></A><EM CLASS="code">
void* nodal_var_vals (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2805"></A>Array of <EM CLASS="code">
num_nodes</EM>
 values of the <EM CLASS="code">
nodal_var_index</EM>
th nodal variable  for the <EM CLASS="code">
time_step</EM>
th time step.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3820"></A>As an example, the following code segment writes all the nodal variables for a single time step:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3832"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3805"></A>int num_nod_vars, num_nodes, error, exoid, time_step;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3847"></A>float *nodal_var_vals;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3843"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-9355"></A>/* write nodal variables */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3833"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3845"></A>nodal_var_vals = (float *) calloc (num_nodes, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3839"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3834"></A>for (k=1; k&lt;=num_nod_vars; k++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3835"></A>{</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3836"></A>	for (j=0; j&lt;num_nodes; j++)</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3846"></A>		/* application code fills in this array */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3838"></A>		nodal_var_vals[j] = 10.0;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3837"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3840"></A>	error = ex_put_nodal_var (exoid, time_step, k, num_nodes,</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3527"></A>			nodal_var_vals);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3844"></A>}</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1944"></A>EXPNV:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1945"></A><EM CLASS="code">
	SUBROUTINE EXPNV (IDEXO, ISTEP, IXNODV, NUMNP, VALNV, IERR)</EM>
<A NAME="50334051_marker-149"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1946"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2806"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1947"></A><EM CLASS="code">
INTEGER ISTEP (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2807"></A>The time step number, as described under <EM CLASS="code">
EXPTIM</EM>
.  This is essentially a counter that is incremented when results variables are output. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1948"></A><EM CLASS="code">
INTEGER IXNODV (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2808"></A>The index of the nodal variable. The first variable has an index of 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1949"></A><EM CLASS="code">
INTEGER NUMNP (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2809"></A>The number of nodal points.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1950"></A><EM CLASS="code">
REAL VALNV(*) (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2810"></A>Array of <EM CLASS="code">
NUMNP</EM>
 values of the <EM CLASS="code">
IXNODV</EM>
th  nodal variable  for the <EM CLASS="code">
ISTEP</EM>
th time step.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1951"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2811"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4512"></A>As an example, the following code segment writes all the nodal variables for a single time step:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4511"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4520"></A>	 real nodal_var_vals(MAXNOD)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4516"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3848"></A>	 do 70 k = 1, num_nod_vars</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4517"></A>		do 60 j = 1, num_nodes</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4515"></A>c			simulation code fills in this array</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4519"></A>			nodal_var_vals(j) = 10.0</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4521"></A>60 		continue</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4522"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4523"></A>		call expnv (idexo, istep, k, num_nodes, nodal_var_vals, ierr)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4531"></A>70 	continue</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1952"></A><A NAME="50334051_12540"></A>Read <A NAME="50334051_marker-505"></A>Nodal Variable Values at a Time Step</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1953"></A>The function <EM CLASS="code">
ex_get_nodal_var</EM>
 (or <EM CLASS="code">
EXGNV</EM>
 for Fortran) reads the values of a single nodal variable for a single time step.  Memory must be allocated for the nodal variable values array before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1954"></A>Because nodal variables are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1955"></A>In case of an error, <EM CLASS="code">
ex_get_nodal_var</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGNV</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1956"></A>data file not properly opened with call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open (EXCRE </EM>
or<EM CLASS="code">
 EXOPEN </EM>
for Fortran).</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1957"></A>specified nodal variable does not exist.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3024"></A>a warning value is returned if no nodal variables are stored in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1958"></A>ex_get_nodal_var:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1959"></A><EM CLASS="code">
	int ex_get_nodal_var (exoid, int time_step, nodal_var_index, num_nodes, nodal_var_vals);</EM>
<A NAME="50334051_marker-150"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1960"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2812"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1961"></A><EM CLASS="code">
int time_step (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2813"></A>The time step, as described under <EM CLASS="code">
ex_put_time</EM>
, at which the nodal variable values are desired.  This is essentially an index (in the time dimension) into the nodal variable values array stored in the database. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1962"></A><EM CLASS="code">
int nodal_var_index (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2814"></A>The index of the desired nodal variable. The first variable has an index of 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1963"></A><EM CLASS="code">
int num_nodes (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2815"></A>The number of nodal points.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1964"></A><EM CLASS="code">
void* nodal_var_vals (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2816"></A>Returned array of <EM CLASS="code">
num_nodes</EM>
 values of the <EM CLASS="code">
nodal_var_index</EM>
th nodal variable  for the <EM CLASS="code">
time_step</EM>
th time step.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3849"></A>For example, the following demonstrates how this function would be used:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3850"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-4514"></A>int num_nodes, time_step, var_index;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3857"></A>float *var_values;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3858"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3855"></A>/* read the second nodal variable at the first time step */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3859"></A>time_step = 1;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3860"></A>var_index = 2;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3861"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3852"></A>var_values = (float *) calloc (num_nodes, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3853"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3854"></A>error = ex_get_nodal_var (exoid, time_step, var_index, num_nodes, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3539"></A>		var_values);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1965"></A>EXGNV:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1966"></A><EM CLASS="code">
	SUBROUTINE EXGNV (IDEXO, ISTEP, IXNODV, NUMNP, VALNV, IERR)</EM>
<A NAME="50334051_marker-151"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1967"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-8284"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-8285"></A><EM CLASS="code">
INTEGER ISTEP (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-8286"></A>The time step number, as described under <EM CLASS="code">
EXPTIM</EM>
, at which the nodal variable is desired.  This is essentially an index (in the time dimension) into the nodal variable values array stored in the database. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1969"></A><EM CLASS="code">
INTEGER IXNODV (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2819"></A>The index of the desired nodal variable. The first variable has an index of 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1970"></A><EM CLASS="code">
INTEGER NUMNP (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2820"></A>The number of nodal points.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1971"></A><EM CLASS="code">
REAL VALNV(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2821"></A>Returned array of <EM CLASS="code">
NUMNP</EM>
 values of the <EM CLASS="code">
IXNODV</EM>
th  nodal variable  for the <EM CLASS="code">
ISTEP</EM>
th time step.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1972"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2822"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4525"></A>For example, the following demonstrates how this function would be used:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4524"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4537"></A>c NOTE:		MAXNOD is the maximum number of nodes for the model</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4538"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4534"></A>	 integer var_index</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4526"></A>	 real var_values(MAXNOD)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4535"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4536"></A>c read a nodal variable at one time step</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4527"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4529"></A>	 istep = 10</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4530"></A>	 var_index = 2</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4532"></A>	 num_nodes = 1000</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4533"></A>&nbsp;</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4528"></A>	 call exgnv (idexo, istep, var_index, num_nodes, var_values, ierr)</P>
<DIV>
<H3 CLASS="Heading3">
<A NAME="50334051_pgfId-1973"></A><A NAME="50334051_18090"></A>Read <A NAME="50334051_marker-506"></A>Nodal Variable Values through Time</H3>
<P CLASS="Body">
<A NAME="50334051_pgfId-1974"></A>The function <EM CLASS="code">
ex_get_nodal_var_time</EM>
 (or <EM CLASS="code">
EXGNVT</EM>
 for Fortran) reads the values of a nodal variable for a single node through a specified number of time steps.  Memory must be allocated for the nodal variable values array before this function is invoked.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1975"></A>Because nodal variables are floating point values, the application code must declare the array passed to be the appropriate type (&quot;float&quot; or &quot;double&quot; in C; &quot;REAL*4&quot; or &quot;REAL*8&quot; in Fortran) to match the compute word size passed in <EM CLASS="code">
ex_create</EM>
 (or <EM CLASS="code">
EXCRE</EM>
 for Fortran) or <EM CLASS="code">
ex_open</EM>
 (or <EM CLASS="code">
EXOPEN</EM>
 for Fortran).</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-1976"></A>In case of an error, <EM CLASS="code">
ex_get_nodal_var_time</EM>
 returns a negative number; a warning will return a positive number.  <EM CLASS="code">
EXGNVT</EM>
 returns a nonzero error (negative) or warning (positive) number in <EM CLASS="code">
IERR</EM>
.  Possible causes of errors include:</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-1978"></A>specified nodal variable does not exist.</P>
<P CLASS="Bullet">
<A NAME="50334051_pgfId-3023"></A>a warning value is returned if no nodal variables are stored in the file.</P>
</DIV>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1979"></A>ex_get_nodal_var_time:  C Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1980"></A><EM CLASS="code">
	int ex_get_nodal_var_time (exoid, nodal_var_index, node_number, beg_time_step, end_time_step, nodal_var_vals);</EM>
<A NAME="50334051_marker-152"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1981"></A><EM CLASS="code">
int exoid (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2823"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
ex_create</EM>
 or <EM CLASS="code">
ex_open</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1982"></A><EM CLASS="code">
int nodal_var_index (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2824"></A>The index of the desired nodal variable. The first variable has an index of 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1983"></A><EM CLASS="code">
int node_number (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2825"></A>The internal ID (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>) of the desired node. The first node is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1984"></A><EM CLASS="code">
int beg_time_step (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2826"></A>The beginning time step for which a nodal variable value is desired.  This is not a time value but rather a time step number, as described under <EM CLASS="code">
ex_put_time</EM>
. The first time step is 1. </P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1985"></A><EM CLASS="code">
int end_time_step (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2827"></A>The last time step for which a nodal variable value is desired.  If negative, the last time step in the database will be used. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1986"></A><EM CLASS="code">
void* nodal_var_vals (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2828"></A>Returned array of (<EM CLASS="code">
end_time_step</EM>
 - <EM CLASS="code">
beg_time_step</EM>
 + 1) values of the <EM CLASS="code">
node_number</EM>
th node for the <EM CLASS="code">
nodal_var_index</EM>
th nodal variable.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-3862"></A>For example, the following code segment will read the values of the first nodal variable for node number one for all time steps stored in the data file:</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3863"></A>#include &quot;exodusII.h&quot;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3879"></A>int num_time_steps, var_index, node_num, beg_time, end_time, error, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3544"></A>	exoid;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3880"></A>float *var_values;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3881"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3878"></A>/* determine how many time steps are stored */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3875"></A>error = ex_inquire (exoid, EX_INQ_TIME, &amp;num_time_steps, &amp;fdum, cdum);</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3876"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3877"></A>/* read a nodal variable through time */</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3865"></A>var_values = (float *) calloc (num_time_steps, sizeof(float));</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3866"></A>&nbsp;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3867"></A>var_index = 1; node_num = 1; beg_time = 1; end_time = -1;</P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3872"></A>error = ex_get_nodal_var_time (exoid, var_index, node_num, beg_time, </P>
<P CLASS="CodeBody">
<A NAME="50334051_pgfId-3870"></A>		end_time, var_values);</P>
</DIV>
<DIV>
<H1 CLASS="Section">
<A NAME="50334051_pgfId-1987"></A>EXGNVT:  Fortran Interface</H1>
<P CLASS="FuncDesc">
<A NAME="50334051_pgfId-1988"></A><EM CLASS="code">
	SUBROUTINE EXGNVT (IDEXO, IXNODV, NODNUM, ISTPB, ISTPE, VALNV, IERR)</EM>
<A NAME="50334051_marker-153"></A></P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1989"></A><EM CLASS="code">
INTEGER IDEXO (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2829"></A>EXODUS file ID returned from a previous call to <EM CLASS="code">
EXCRE</EM>
 or <EM CLASS="code">
EXOPEN</EM>
.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1990"></A><EM CLASS="code">
INTEGER IXNODV (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2830"></A>The index of the desired nodal variable. The first variable has an index of 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1991"></A><EM CLASS="code">
INTEGER NODNUM (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2831"></A>The internal ID (see <A HREF="exodusII.book.html#50334051_19003" CLASS="XRef">See Node Number Map</A>) of the desired node. The first node is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1992"></A><EM CLASS="code">
INTEGER ISTPB (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2832"></A>The beginning time step for which a nodal variable value is desired.  This is not a time value but rather a time step number, as described under <EM CLASS="code">
EXPTIM</EM>
. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1993"></A><EM CLASS="code">
INTEGER ISTPE (R)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-8302"></A>The last time step for which a nodal variable value is desired.  If negative, the last time step in the database will be used. The first time step is 1.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-8303"></A><EM CLASS="code">
REAL VALNV(*) (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-8304"></A>Returned array of (<EM CLASS="code">
ISTPE</EM>
 - <EM CLASS="code">
ISTPB</EM>
 + 1) values of the <EM CLASS="code">
NODNUM</EM>
th node for the <EM CLASS="code">
IXNODV</EM>
th nodal variable.</P>
<P CLASS="Var">
<A NAME="50334051_pgfId-1995"></A><EM CLASS="code">
INTEGER IERR (W)</EM>
</P>
<P CLASS="VarPar">
<A NAME="50334051_pgfId-2835"></A>Returned error code.  If no errors occurred, 0 is returned.</P>
<P CLASS="Body">
<A NAME="50334051_pgfId-4540"></A>For example, the following code segment will read the values of the first nodal variable for node number one for all time steps stored in the data file:</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4539"></A>	 integer var_ind, btime, etime</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3871"></A>	 real var_vals(MAXVAL)</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3874"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4541"></A>c read a nodal variable through time</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4542"></A>c</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4543"></A>	 var_ind = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-1977"></A>	 node_num = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3864"></A>	 btime = 1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-3868"></A>	 etime = -1</P>
<P CLASS="CodeBodyFor">
<A NAME="50334051_pgfId-4545"></A>	 call exgnvt (idexo, var_ind, node_num, btime, etime, var_vals, ierr)</P>
<DIV>
<H2 CLASS="FM1Heading">
<A NAME="50334051_pgfId-4902"></A>References</H2>
<P CLASS="Ref1">
<A NAME="50334051_pgfId-750"></A>W. C. Mills-Curran, A. P. Gilkey, and D. P. Flanagan, &quot;EXODUS: A Finite Element File Format for Pre- and Post-processing,&quot; Technical Report SAND87-2977, Sandia National Laboratories, Albuquerque, New Mexico, September 1988.</P>
<P CLASS="Ref">
<A NAME="50334051_pgfId-751"></A>G. D. Sjaardema, &quot;Overview of the Sandia National Laboratories Engineering Analysis Code Access System,&quot; Technical Report SAND92-2292, Sandia National Laboratories, Albuquerque, New Mexico, January 1993. </P>
<P CLASS="Ref">
<A NAME="50334051_pgfId-752"></A>R. K. Rew, G. P. Davis, and S. Emmerson, &quot;NetCDF User's Guide: An Interface for Data Access,&quot; Version 2.3, University Corporation for Atmospheric Research, Boulder, Colorado, April 1993.</P>
<P CLASS="Ref">
<A NAME="50334051_pgfId-753"></A>Sun Microsystems, &quot;External Data Representation Standard: Protocol Specification,&quot; RFC 1014; Information Sciences Institute, May 1988. </P>
<P CLASS="Ref">
<A NAME="50334051_pgfId-696"></A>PDA Engineering, &quot;PATRAN Plus User Manual,&quot; Publication No. 2191024, Costa Mesa, California, January 1990. </P>
<P CLASS="Body">
<A NAME="50334051_pgfId-9852"></A>&nbsp;</P>
</DIV>
<DIV>
<H2 CLASS="Appendix">
<A NAME="50334052_pgfId-89"></A><DIV>
<IMG SRC="exodusII.book-10.gif">
</DIV>
<A NAME="50334052_41997"></A>Appendix A</H2>
</DIV>
<DIV>
<H2 CLASS="AppTitle">
<A NAME="50334052_pgfId-98"></A>Implementation of EXODUS II with netCDF</H2>
<DIV>
<H4 CLASS="Heading">
<A NAME="50334052_pgfId-151"></A>Description</H4>
<P CLASS="Body">
<A NAME="50334052_pgfId-533"></A>The netCDF software is an I/O library, callable from C or Fortran, which stores and retrieves scientific data structures in self-describing, machine-independent files.  &quot;Self-describing&quot; means that a file includes information defining the data it contains.  &quot;Machine-independent&quot; means that a file is represented in a form that can be accessed by computers with different ways of storing integers, characters, and floating-point numbers.  It is available via anonymous FTP from unidata.ucar.edu in the file pub/netcdf/netcdf.tar.Z.</P>
<P CLASS="Body">
<A NAME="50334052_pgfId-534"></A>For the EXODUS II implementation, the standard netCDF distribution is used except that the following defined constants in the include file <EM CLASS="code">
netcdf.h</EM>
 are modified to the values shown:</P>
<P CLASS="Body">
<A NAME="50334052_pgfId-537"></A><EM CLASS="code">
#define MAX_NC_DIMS 8192 </EM>
</P>
<P CLASS="Body">
<A NAME="50334052_pgfId-538"></A><EM CLASS="code">
#define MAX_NC_ATTRS 1024</EM>
</P>
<P CLASS="Body">
<A NAME="50334052_pgfId-539"></A><EM CLASS="code">
#define MAX_NC_VARS 8192</EM>
</P>
<P CLASS="Body">
<A NAME="50334052_pgfId-540"></A><EM CLASS="code">
#define MAX_NC_NAME 256</EM>
</P>
</DIV>
<DIV>
<H4 CLASS="Heading">
<A NAME="50334052_pgfId-532"></A><A NAME="50334052_marker-557"></A>Efficiency Issues</H4>
<P CLASS="Body">
<A NAME="50334052_pgfId-522"></A>There are some efficiency concerns with using netCDF as the low level data handler.  The main one is that whenever a new object is introduced, the file is put into &quot;define&quot; mode, the new object is defined, and then the file is taken out of &quot;define&quot; mode.  A result of going in and out of &quot;define&quot; mode is that all of the data that was output previous to the introduction of the new object is copied to a new file.  Obviously, this copying of data to a new file is very inefficient.  We have attempted to minimize the number of times the data file is put into &quot;define&quot; mode by accumulating objects within a single EXODUS II API function.  Thus using optional features such as the element variable truth table, concatenated node and side sets, and writing all property array names with <EM CLASS="code">
ex_put_prop_names</EM>
 (<EM CLASS="code">
EXPPN</EM>
 for Fortran) will increase efficiency significantly.</P>
</DIV>
<DIV>
<H4 CLASS="Heading">
<A NAME="50334052_pgfId-521"></A>netCDF Data Objects</H4>
<P CLASS="Body">
<A NAME="50334052_pgfId-520"></A>This section describes how EXODUS II data  are mapped to <A NAME="50334052_marker-80"></A>netCDF entities.  This information is needed only for those individuals who desire to access an EXODUS II database via netCDF calls directly or desire to modify the routines that comprise the Application Programming Interface (API).</P>
<P CLASS="Body">
<A NAME="50334052_pgfId-85"></A>The following is a list of the names of the data entities found in an EXODUS II file and a description of each entity.  The names are constants predefined in the include file <EM CLASS="code">
exodusII_int.h</EM>
 for C or <EM CLASS="code">
exodusII_int.inc</EM>
 for Fortran.  They are grouped into three netCDF categories:  attributes, dimensions, and variables.</P>
</DIV>
<DIV>
<H4 CLASS="AppMinor">
<A NAME="50334052_pgfId-93"></A>Attributes</H4>
<P CLASS="Body1">
<A NAME="50334052_pgfId-94"></A>An attribute is used to describe data entities.  It can be global (describe entire file) or attached to a dimension or variable.</P>
<P CLASS="AppList1">
<A NAME="50334052_pgfId-96"></A><EM CLASS="code">
title</EM>
				the database title; character global attribute</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-134"></A><EM CLASS="code">
version</EM>
				the EXODUS II file version number; float global attribute</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-99"></A><EM CLASS="code">
api version</EM>
				the EXODUS II API version number; float global attribute</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-88"></A><EM CLASS="code">
floating point word size						</EM>
word size of floating point numbers in the file; int global attribute</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-148"></A><EM CLASS="code">
elem_type</EM>
				element type names for each element block; character variable attribute attached to <EM CLASS="code">
connect</EM>
 variable</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-149"></A><EM CLASS="code">
name</EM>
				name of element block, node set, or side set property; character variable attribute attached to specific property</P>
</DIV>
<DIV>
<H4 CLASS="AppMinor">
<A NAME="50334052_pgfId-117"></A>Dimensions</H4>
<P CLASS="Body1">
<A NAME="50334052_pgfId-146"></A>A dimension is an integer scalar value that is used to define the size of variables.</P>
<P CLASS="AppList1">
<A NAME="50334052_pgfId-107"></A><EM CLASS="code">
num_nodes</EM>
				number of nodes</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-108"></A><EM CLASS="code">
num_dim</EM>
				number of dimensions of the finite element model; 1-, 2-, or 3-d</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-109"></A><EM CLASS="code">
num_elem</EM>
				number of elements</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-91"></A><EM CLASS="code">
num_el_blk</EM>
				number of element blocks</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-92"></A><EM CLASS="code">
num_el_in_blk#</EM>
				number of elements in element block #</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-100"></A><EM CLASS="code">
num_nod_per_el#	</EM>
			number of nodes per element  in element block #</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-155"></A><EM CLASS="code">
num_att_in_blk#</EM>
				number of attributes per element in element block #</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-156"></A><EM CLASS="code">
num_side_sets</EM>
				number of side sets</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-118"></A><EM CLASS="code">
num_side_ss#</EM>
				number of sides (also the number of elements) in side set #</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-114"></A><EM CLASS="code">
num_df_ss#</EM>
				number of distribution factors in side set #</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-125"></A><EM CLASS="code">
num_node_sets</EM>
				number of node sets</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-120"></A><EM CLASS="code">
num_nod_ns#</EM>
				number of nodes in node set #</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-150"></A><EM CLASS="code">
num_df_ns#</EM>
				number of distribution factors in node set #</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-130"></A><EM CLASS="code">
num_qa_rec</EM>
				number of QA records</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-132"></A><EM CLASS="code">
num_info</EM>
				number of information records</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-126"></A><EM CLASS="code">
num_glo_var</EM>
				number of global variables</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-137"></A><EM CLASS="code">
num_nod_var</EM>
				number of nodal variables</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-140"></A><EM CLASS="code">
num_elem_var</EM>
				number of element variables</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-147"></A><EM CLASS="code">
time_step</EM>
				unlimited (expandable) dimension for time steps</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-110"></A><EM CLASS="code">
len_string</EM>
				length of a string; currently set to allow 32 characters (plus NULL character for C interface)</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-157"></A><EM CLASS="code">
len_line</EM>
				length of a line; currently set to allow 80 characters (plus NULL character for C interface)</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-192"></A><EM CLASS="code">
four</EM>
				number of strings in a single QA record</P>
</DIV>
<DIV>
<H4 CLASS="AppMinor">
<A NAME="50334052_pgfId-153"></A>Variables</H4>
<P CLASS="Body1">
<A NAME="50334052_pgfId-154"></A>A variable is an entity that contains data.  Its size and shape are specified by dimensions.   Note that the order of the dimensions is &quot;row order&quot; as implemented in the C language, so the last dimension specified varies fastest, the first dimension varies slowest.  For multi-dimension variables, illustrations are included in the descriptions below for ease of understanding.  For variables that are dimensioned through time, ellipses (. . .) are used to show that the variable can expand in that dimension.</P>
<P CLASS="AppList1">
<A NAME="50334052_pgfId-111"></A><EM CLASS="code">
coord (num_dim, num_nodes)</EM>
				  	nodal coordinates; float or double </P>
<DIV>
<MAP NAME="exodusII.book-11">
</MAP>
<IMG SRC="exodusII.book-11.gif" USEMAP="#exodusII.book-11">
</DIV>
<P CLASS="AppList">
<A NAME="50334052_pgfId-160"></A><EM CLASS="code">
coor_names (num_dim, len_string)				</EM>
  	names of coordinates; character </P>
<DIV>
<MAP NAME="exodusII.book-12">
</MAP>
<IMG SRC="exodusII.book-12.gif" USEMAP="#exodusII.book-12">
</DIV>
<P CLASS="AppList">
<A NAME="50334052_pgfId-162"></A><EM CLASS="code">
connect# (num_el_in_blk#, num_nod_per_el#)</EM>
					element connectivity for element block #; integer </P>
<DIV>
<MAP NAME="exodusII.book-13">
</MAP>
<IMG SRC="exodusII.book-13.gif" USEMAP="#exodusII.book-13">
</DIV>
<P CLASS="AppList">
<A NAME="50334052_pgfId-164"></A><EM CLASS="code">
attrib# (num_el_in_blk#, num_att_in_blk#)</EM>
					list of attributes for element block #; float or double </P>
<DIV>
<MAP NAME="exodusII.book-14">
</MAP>
<IMG SRC="exodusII.book-14.gif" USEMAP="#exodusII.book-14">
</DIV>
<P CLASS="AppList">
<A NAME="50334052_pgfId-113"></A><EM CLASS="code">
eb_prop# (num_el_blk)					</EM>
list of the #th property for all element blocks; integer</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-90"></A><EM CLASS="code">
elem_map (num_elem)</EM>
					element order map; integer</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-122"></A><EM CLASS="code">
dist_fact_ss# (num_df_ss#)</EM>
					distribution factors for each node in side set #; float or double</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-123"></A><EM CLASS="code">
elem_ss# (num_side_ss#)			</EM>
		list of elements in side set #; integer</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-121"></A><EM CLASS="code">
side_ss# (num_side_ss#)			</EM>
		list of sides in side set #; integer</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-119"></A><EM CLASS="code">
ss_prop# (num_side_sets)					</EM>
list of the #th property for all side sets; integer</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-128"></A><EM CLASS="code">
node_ns# (num_nod_ns#)</EM>
					list of nodes in node set #; integer</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-129"></A><EM CLASS="code">
dist_fact_ns# (num_nod_ns#)					</EM>
list of distribution factors in node set #; float or double</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-124"></A><EM CLASS="code">
ns_prop# (num_node_sets)					</EM>
list of the #th property for all node sets; integer</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-166"></A><EM CLASS="code">
qa_records (num_qa_rec, 4, len_string)</EM>
					QA records; character </P>
<DIV>
<MAP NAME="exodusII.book-15">
</MAP>
<IMG SRC="exodusII.book-15.gif" USEMAP="#exodusII.book-15">
</DIV>
<P CLASS="AppList">
<A NAME="50334052_pgfId-169"></A><EM CLASS="code">
info_records (num_info, len_line)					</EM>
information records; character </P>
<DIV>
<MAP NAME="exodusII.book-16">
</MAP>
<IMG SRC="exodusII.book-16.gif" USEMAP="#exodusII.book-16">
</DIV>
<P CLASS="AppList">
<A NAME="50334052_pgfId-135"></A><EM CLASS="code">
time_whole (time_step)					</EM>
simulation times for time steps; float or double</P>
<P CLASS="AppList">
<A NAME="50334052_pgfId-171"></A><EM CLASS="code">
elem_var_tab (num_el_blk, num_elem_var)</EM>
					element variable truth table; integer </P>
<DIV>
<MAP NAME="exodusII.book-17">
</MAP>
<IMG SRC="exodusII.book-17.gif" USEMAP="#exodusII.book-17">
</DIV>
<P CLASS="AppList">
<A NAME="50334052_pgfId-172"></A><EM CLASS="code">
name_glo_var (num_glo_var, len_string)					</EM>
names of global variables; character</P>
<DIV>
<MAP NAME="exodusII.book-18">
</MAP>
<IMG SRC="exodusII.book-18.gif" USEMAP="#exodusII.book-18">
</DIV>
<P CLASS="AppList">
<A NAME="50334052_pgfId-174"></A><EM CLASS="code">
vals_glo_var (time_step, num_glo_var)					</EM>
values of global variables; float or double </P>
<DIV>
<MAP NAME="exodusII.book-19">
</MAP>
<IMG SRC="exodusII.book-19.gif" USEMAP="#exodusII.book-19">
</DIV>
<P CLASS="AppList">
<A NAME="50334052_pgfId-179"></A><EM CLASS="code">
name_nod_var (num_nod_var, len_string)					</EM>
names of nodal variables; character</P>
<DIV>
<MAP NAME="exodusII.book-20">
</MAP>
<IMG SRC="exodusII.book-20.gif" USEMAP="#exodusII.book-20">
</DIV>
<P CLASS="AppList">
<A NAME="50334052_pgfId-184"></A><EM CLASS="code">
vals_nod_var (time_step, num_nod_var, num_nodes)</EM>
					values of nodal variables; float or double  </P>
<DIV>
<MAP NAME="exodusII.book-21">
</MAP>
<IMG SRC="exodusII.book-21.gif" USEMAP="#exodusII.book-21">
</DIV>
<P CLASS="AppList">
<A NAME="50334052_pgfId-181"></A><EM CLASS="code">
name_elem_var (num_elem_var, len_string)</EM>
					names of element variables; character</P>
<DIV>
<MAP NAME="exodusII.book-22">
</MAP>
<IMG SRC="exodusII.book-22.gif" USEMAP="#exodusII.book-22">
</DIV>
<P CLASS="AppList">
<A NAME="50334052_pgfId-186"></A><EM CLASS="code">
vals_elem_var#1eb#2 (time_step, num_el_in_blk#2) 					</EM>
values of element variable #1 in element block #2; for each element block, there is one of these for each element variable that is valid for that element block; float or double </P>
<DIV>
<MAP NAME="exodusII.book-23">
</MAP>
<IMG SRC="exodusII.book-23.gif" USEMAP="#exodusII.book-23">
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Appendix">
<A NAME="50334053_pgfId-192"></A><DIV>
<IMG SRC="exodusII.book-24.gif">
</DIV>
Appendix B</H2>
</DIV>
<DIV>
<H2 CLASS="AppTitle">
<A NAME="50334053_pgfId-204"></A><A NAME="50334053_marker-188"></A>Function Call Summary</H2>
<P CLASS="Body">
<A NAME="50334053_pgfId-256"></A>This appendix includes an alphabetized list of EXODUS II functions, passed arguments, and page number where their descriptions are located in the manual.  The C interface routines are listed first followed by the FORTRAN binding routines. </P>
<DIV>
<H4 CLASS="Heading">
<A NAME="50334053_pgfId-980"></A>C binding routines</H4>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-195"></A><EM CLASS="code">
	int ex_close ( </EM>
<A NAME="50334053_marker-49"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-196"></A><EM CLASS="code">
int exoid);  			<A HREF="exodusII.book.html#50334051_12158" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-197"></A><EM CLASS="code">
	int ex_create ( </EM>
<A NAME="50334053_marker-50"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-198"></A><EM CLASS="code">
char* path,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-199"></A><EM CLASS="code">
int cmode,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-200"></A><EM CLASS="code">
int* comp_ws,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-202"></A><EM CLASS="code">
int* io_ws);  			<A HREF="exodusII.book.html#50334051_21931" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-205"></A><EM CLASS="code">
	int ex_cvt_nodes_to_sides ( </EM>
<A NAME="50334053_marker-51"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-206"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-213"></A><EM CLASS="code">
int* num_side_per_set,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-214"></A><EM CLASS="code">
int* num_nodes_per_set,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-215"></A><EM CLASS="code">
int* side_sets_elem_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-216"></A><EM CLASS="code">
int* side_sets_node_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-217"></A><EM CLASS="code">
int* side_sets_elem_list,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-218"></A><EM CLASS="code">
int* side_sets_node_list,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-219"></A><EM CLASS="code">
int* side_sets_side_list);  			<A HREF="exodusII.book.html#50334051_24098" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-220"></A><EM CLASS="code">
	void ex_err (</EM>
<A NAME="50334053_marker-52"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-221"></A><EM CLASS="code">
char* module_name,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-222"></A><EM CLASS="code">
char* message,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-223"></A><EM CLASS="code">
int err_num);  			<A HREF="exodusII.book.html#50334051_22311" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-224"></A><EM CLASS="code">
	int ex_get_all_times ( </EM>
<A NAME="50334053_marker-53"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-225"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-226"></A><EM CLASS="code">
void* time_values);  			<A HREF="exodusII.book.html#50334051_34299" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-227"></A><EM CLASS="code">
	int ex_get_concat_node_sets ( </EM>
<A NAME="50334053_marker-54"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-228"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-229"></A><EM CLASS="code">
int* node_set_ids,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-230"></A><EM CLASS="code">
int* num_nodes_per_set,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-231"></A><EM CLASS="code">
int* num_dist_per_set,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-232"></A><EM CLASS="code">
int* node_sets_node index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-233"></A><EM CLASS="code">
int* node_sets_dist_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-234"></A><EM CLASS="code">
int* node_sets_node_list,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-235"></A><EM CLASS="code">
void* node_sets_dist_fact);  			<A HREF="exodusII.book.html#50334051_31865" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-236"></A><EM CLASS="code">
	int ex_get_concat_side_sets ( </EM>
<A NAME="50334053_marker-55"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-237"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-238"></A><EM CLASS="code">
int* side_set_ids,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-239"></A><EM CLASS="code">
int* num_side_per_set,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-240"></A><EM CLASS="code">
int* num_dist_per_set,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-241"></A><EM CLASS="code">
int* side_sets_elem_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-242"></A><EM CLASS="code">
int* side_sets_dist_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-243"></A><EM CLASS="code">
int* side_sets_elem_list,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-244"></A><EM CLASS="code">
int* side_sets_side_list,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-245"></A><EM CLASS="code">
void* side_sets_dist_fact);  			<A HREF="exodusII.book.html#50334051_30116" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-246"></A><EM CLASS="code">
	int ex_get_coord ( </EM>
<A NAME="50334053_marker-56"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-247"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-248"></A><EM CLASS="code">
void* x_coor,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1274"></A><EM CLASS="code">
void* y_coor,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1278"></A><EM CLASS="code">
void* z_coor);  			<A HREF="exodusII.book.html#50334051_36174" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1280"></A><EM CLASS="code">
	int ex_get_coord_names ( </EM>
<A NAME="50334053_marker-1279"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-252"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-253"></A><EM CLASS="code">
char** coord_names);  			<A HREF="exodusII.book.html#50334051_31901" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-254"></A><EM CLASS="code">
	int ex_get_elem_attr ( </EM>
<A NAME="50334053_marker-58"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-255"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-257"></A><EM CLASS="code">
int elem_blk_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-258"></A><EM CLASS="code">
void* attrib);  			<A HREF="exodusII.book.html#50334051_16035" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-259"></A><EM CLASS="code">
	int ex_get_elem_blk_ids ( </EM>
<A NAME="50334053_marker-59"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-260"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-261"></A><EM CLASS="code">
int* elem_blk_ids);  			<A HREF="exodusII.book.html#50334051_15251" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-262"></A><EM CLASS="code">
	int ex_get_elem_block ( </EM>
<A NAME="50334053_marker-60"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-263"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-264"></A><EM CLASS="code">
int elem_blk_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-265"></A><EM CLASS="code">
char* elem_type,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-266"></A><EM CLASS="code">
int* num_elem_this_blk,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-267"></A><EM CLASS="code">
int* num_nodes_per_elem,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-268"></A><EM CLASS="code">
int* num_attr);  			<A HREF="exodusII.book.html#50334051_28882" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-269"></A><EM CLASS="code">
	int ex_get_elem_conn ( </EM>
<A NAME="50334053_marker-61"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-270"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-271"></A><EM CLASS="code">
int elem_blk_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-272"></A><EM CLASS="code">
int* connect);  			<A HREF="exodusII.book.html#50334051_17436" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-273"></A><EM CLASS="code">
	int ex_get_elem_num_map (</EM>
<A NAME="50334053_marker-1370"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1365"></A>int exoid,</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1366"></A>int* elem_map);			<A HREF="exodusII.book.html#50334051_22184" CLASS="XRef"></A></P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1364"></A><EM CLASS="code">
	int ex_get_elem_var  ( </EM>
<A NAME="50334053_marker-62"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-274"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-275"></A><EM CLASS="code">
int time_step,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-276"></A><EM CLASS="code">
int elem_var_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-277"></A><EM CLASS="code">
int elem_blk_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-278"></A><EM CLASS="code">
int num_elem_this_blk,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-279"></A><EM CLASS="code">
void* elem_var_vals);  			<A HREF="exodusII.book.html#50334051_29752" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-280"></A><EM CLASS="code">
	int ex_get_elem_var_tab ( </EM>
<A NAME="50334053_marker-63"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-281"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-282"></A><EM CLASS="code">
int num_elem_blk,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-283"></A><EM CLASS="code">
int num_elem_var,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-284"></A><EM CLASS="code">
int* elem_var_tab);  			<A HREF="exodusII.book.html#50334051_22499" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-285"></A><EM CLASS="code">
	int ex_get_elem_var_time ( </EM>
<A NAME="50334053_marker-64"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-286"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-287"></A><EM CLASS="code">
int elem_var_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-288"></A><EM CLASS="code">
int elem_number,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-289"></A><EM CLASS="code">
int beg_time_step,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-290"></A><EM CLASS="code">
int end_time_step,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-291"></A><EM CLASS="code">
void* elem_var_vals);  			<A HREF="exodusII.book.html#50334051_32150" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-292"></A><EM CLASS="code">
	int ex_get_glob_vars ( </EM>
<A NAME="50334053_marker-65"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-293"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-294"></A><EM CLASS="code">
int time_step,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-295"></A><EM CLASS="code">
int num_glob_vars</EM>
,</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-296"></A><EM CLASS="code">
void* glob_var_vals);  			<A HREF="exodusII.book.html#50334051_39653" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-297"></A><EM CLASS="code">
	int ex_get_glob_var_time ( </EM>
<A NAME="50334053_marker-66"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-298"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-299"></A><EM CLASS="code">
int glob_var_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-300"></A><EM CLASS="code">
int beg_time_step,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-301"></A><EM CLASS="code">
int end_time_step,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-302"></A><EM CLASS="code">
void* glob_var_vals);  			<A HREF="exodusII.book.html#50334051_33485" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-303"></A><EM CLASS="code">
	int ex_get_info ( </EM>
<A NAME="50334053_marker-67"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-304"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-305"></A><EM CLASS="code">
char** info);  			<A HREF="exodusII.book.html#50334051_16434" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-306"></A><EM CLASS="code">
	int ex_get_init ( </EM>
<A NAME="50334053_marker-68"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-307"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-308"></A><EM CLASS="code">
char* title,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-309"></A><EM CLASS="code">
int* num_dim,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-310"></A><EM CLASS="code">
int* num_nodes,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-311"></A><EM CLASS="code">
int* num_elem,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-312"></A><EM CLASS="code">
int* num_elem_blk,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-313"></A><EM CLASS="code">
int* num_node_sets,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-314"></A><EM CLASS="code">
int* num_side_sets);  			<A HREF="exodusII.book.html#50334051_24784" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-315"></A><EM CLASS="code">
	int ex_get_map ( </EM>
<A NAME="50334053_marker-69"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-316"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-317"></A><EM CLASS="code">
int* elem_map);  			<A HREF="exodusII.book.html#50334051_22279" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-318"></A><EM CLASS="code">
	int ex_get_nodal_var ( </EM>
<A NAME="50334053_marker-70"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-319"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-320"></A><EM CLASS="code">
int time_step,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-321"></A><EM CLASS="code">
int nodal_var_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-322"></A><EM CLASS="code">
int num_nodes,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-323"></A><EM CLASS="code">
void* nodal_var_vals);  			<A HREF="exodusII.book.html#50334051_12540" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-324"></A><EM CLASS="code">
	int ex_get_nodal_var_time ( </EM>
<A NAME="50334053_marker-71"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-325"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-326"></A><EM CLASS="code">
int nodal_var_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-327"></A><EM CLASS="code">
int node_number,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-328"></A><EM CLASS="code">
int beg_time_step,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-329"></A><EM CLASS="code">
int end_time_step,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-330"></A><EM CLASS="code">
void* nodal_var_vals);  			<A HREF="exodusII.book.html#50334051_18090" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-331"></A><EM CLASS="code">
	int ex_get_node_num_map (</EM>
<A NAME="50334053_marker-1343"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1338"></A>int exoid,</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1339"></A>int* node_map);			<A HREF="exodusII.book.html#50334051_35467" CLASS="XRef"></A></P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1334"></A><EM CLASS="code">
	int ex_get_node_set ( </EM>
<A NAME="50334053_marker-72"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-332"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-333"></A><EM CLASS="code">
int node_set_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-334"></A><EM CLASS="code">
int* node_set_node_list);  			<A HREF="exodusII.book.html#50334051_33368" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-335"></A><EM CLASS="code">
	int ex_get_node_set_dist_fact ( </EM>
<A NAME="50334053_marker-73"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-336"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-337"></A><EM CLASS="code">
int node_set_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-338"></A><EM CLASS="code">
void* node_set_dist_fact);  			<A HREF="exodusII.book.html#50334051_37354" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-339"></A><EM CLASS="code">
	int ex_get_node_set_ids ( </EM>
<A NAME="50334053_marker-74"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-340"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-341"></A><EM CLASS="code">
int</EM>
<EM CLASS="Bold">
* node_set_ids</EM>
<EM CLASS="code">
);  			<A HREF="exodusII.book.html#50334051_34277" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-342"></A><EM CLASS="code">
	int ex_get_node_set_param ( </EM>
<A NAME="50334053_marker-75"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-343"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-344"></A><EM CLASS="code">
int node_set_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-345"></A><EM CLASS="code">
int* num_nodes_in_set,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-346"></A><EM CLASS="code">
int* num_dist_in_set);  			<A HREF="exodusII.book.html#50334051_25184" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-347"></A><EM CLASS="code">
	int ex_get_prop ( </EM>
<A NAME="50334053_marker-76"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-348"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-349"></A><EM CLASS="code">
int obj_type,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-350"></A><EM CLASS="code">
int obj_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-351"></A><EM CLASS="code">
char* prop_name,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-352"></A><EM CLASS="code">
int* value);  			<A HREF="exodusII.book.html#50334051_31447" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-353"></A><EM CLASS="code">
	int ex_get_prop_array ( </EM>
<A NAME="50334053_marker-77"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-354"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-355"></A><EM CLASS="code">
int obj_type,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-356"></A><EM CLASS="code">
char* prop_name,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-357"></A><EM CLASS="code">
int* values);  			<A HREF="exodusII.book.html#50334051_41253" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-358"></A><EM CLASS="code">
	int ex_get_prop_names ( </EM>
<A NAME="50334053_marker-78"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-359"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1283"></A><EM CLASS="code">
int obj_type,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1287"></A><EM CLASS="code">
char** prop_names);  			<A HREF="exodusII.book.html#50334051_23137" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1289"></A><EM CLASS="code">
	int ex_get_qa ( </EM>
<A NAME="50334053_marker-1288"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-363"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-364"></A><EM CLASS="code">
char* qa_record);  			<A HREF="exodusII.book.html#50334051_16581" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-365"></A><EM CLASS="code">
	int ex_get_side_set ( </EM>
<A NAME="50334053_marker-80"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-366"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-367"></A><EM CLASS="code">
int side_set_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-368"></A><EM CLASS="code">
int* side_set_elem_list,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-369"></A><EM CLASS="code">
int* side_set_side_list);  			<A HREF="exodusII.book.html#50334051_34153" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-370"></A><EM CLASS="code">
	int ex_get_side_set_dist_fact ( </EM>
<A NAME="50334053_marker-81"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-371"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-372"></A><EM CLASS="code">
int side_set_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-373"></A><EM CLASS="code">
void* side_set_dist_fact);  			<A HREF="exodusII.book.html#50334051_42724" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-374"></A><EM CLASS="code">
	int ex_get_side_set_ids ( </EM>
<A NAME="50334053_marker-82"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-375"></A><EM CLASS="code">
int exoid</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-376"></A><EM CLASS="code">
int* side_set_ids);  			<A HREF="exodusII.book.html#50334051_19733" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-377"></A><EM CLASS="code">
	int ex_get_side_set_node_list ( </EM>
<A NAME="50334053_marker-83"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-378"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-379"></A><EM CLASS="code">
int side_set_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-380"></A><EM CLASS="code">
int* side_set_node_cnt_list,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-381"></A><EM CLASS="code">
int* side_set_node_list);  			<A HREF="exodusII.book.html#50334051_16306" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-382"></A><EM CLASS="code">
	int ex_get_side_set_param ( </EM>
<A NAME="50334053_marker-84"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-383"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-384"></A><EM CLASS="code">
int side_set_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-385"></A><EM CLASS="code">
int* num_side_in_set,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-386"></A><EM CLASS="code">
int* num_dist_fact_in_set);  			<A HREF="exodusII.book.html#50334051_22538" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-387"></A><EM CLASS="code">
	int ex_get_time ( </EM>
<A NAME="50334053_marker-85"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-388"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-389"></A><EM CLASS="code">
int time_step,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-390"></A><EM CLASS="code">
void* time_value);  			<A HREF="exodusII.book.html#50334051_15529" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-391"></A><EM CLASS="code">
	int ex_get_var_names ( </EM>
<A NAME="50334053_marker-86"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-392"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-393"></A><EM CLASS="code">
char* var_type,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-394"></A><EM CLASS="code">
int num_vars,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-395"></A><EM CLASS="code">
char** var_names);  			<A HREF="exodusII.book.html#50334051_24360" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-396"></A><EM CLASS="code">
	int ex_get_var_param ( </EM>
<A NAME="50334053_marker-87"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-397"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-398"></A><EM CLASS="code">
char* var_type,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-399"></A><EM CLASS="code">
int* num_vars);  			<A HREF="exodusII.book.html#50334051_13500" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-400"></A><EM CLASS="code">
	int ex_inquire ( </EM>
<A NAME="50334053_marker-88"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-401"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-402"></A><EM CLASS="code">
int req_info,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-403"></A><EM CLASS="code">
int* ret_int,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-404"></A><EM CLASS="code">
float* ret_float,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-405"></A><EM CLASS="code">
char* ret_char);  			<A HREF="exodusII.book.html#50334051_23612" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-406"></A><EM CLASS="code">
	int ex_open ( </EM>
<A NAME="50334053_marker-89"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-407"></A><EM CLASS="code">
char* path,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-408"></A><EM CLASS="code">
int mode,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-409"></A><EM CLASS="code">
int* comp_ws,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-410"></A><EM CLASS="code">
int* io_ws,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-411"></A><EM CLASS="code">
float* version);  			<A HREF="exodusII.book.html#50334051_14859" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-412"></A><EM CLASS="code">
	int ex_opts ( </EM>
<A NAME="50334053_marker-90"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-413"></A><EM CLASS="code">
int option_val);  			<A HREF="exodusII.book.html#50334051_42529" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-414"></A><EM CLASS="code">
	int ex_put_concat_node_sets ( </EM>
<A NAME="50334053_marker-91"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-415"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-416"></A><EM CLASS="code">
int* node_set_ids,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-417"></A><EM CLASS="code">
int* num_nodes_per_set,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-418"></A><EM CLASS="code">
int* num_dist_per_set,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-419"></A><EM CLASS="code">
int* node_sets_node_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-420"></A><EM CLASS="code">
int* node_sets_dist_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-421"></A><EM CLASS="code">
int* node_sets_node_list,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-422"></A><EM CLASS="code">
void* node_sets_dist_fact);  			<A HREF="exodusII.book.html#50334051_39090" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-423"></A><EM CLASS="code">
	int ex_put_concat_side_sets ( </EM>
<A NAME="50334053_marker-92"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-424"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-425"></A><EM CLASS="code">
int* side_sets_ids,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-426"></A><EM CLASS="code">
int* num_side_per_set,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-427"></A><EM CLASS="code">
int* num_dist_per_set,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-428"></A><EM CLASS="code">
int* side_sets_elem_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-429"></A><EM CLASS="code">
int* side_sets_dist_index</EM>
,</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-430"></A><EM CLASS="code">
int* side_sets_elem_list,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-431"></A><EM CLASS="code">
int* side_sets_side_list,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-432"></A><EM CLASS="code">
void* side_sets_dist_fact);  			<A HREF="exodusII.book.html#50334051_37836" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-433"></A><EM CLASS="code">
	int ex_put_coord ( </EM>
<A NAME="50334053_marker-93"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-434"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-435"></A><EM CLASS="code">
void* x_coor,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-436"></A><EM CLASS="code">
void* y_coor</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-437"></A><EM CLASS="code">
void* z_coor);  			<A HREF="exodusII.book.html#50334051_10305" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-438"></A><EM CLASS="code">
	int ex_put_coord_names ( </EM>
<A NAME="50334053_marker-94"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-439"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-440"></A><EM CLASS="code">
char** coord_names);  			<A HREF="exodusII.book.html#50334051_32573" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-441"></A><EM CLASS="code">
	int ex_put_elem_attr ( </EM>
<A NAME="50334053_marker-95"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-442"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-443"></A><EM CLASS="code">
int elem_blk_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-444"></A><EM CLASS="code">
void* attrib);  			<A HREF="exodusII.book.html#50334051_42312" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-445"></A><EM CLASS="code">
	int ex_put_elem_block ( </EM>
<A NAME="50334053_marker-96"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-446"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-447"></A><EM CLASS="code">
int elem_blk_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-448"></A><EM CLASS="code">
char* elem_type,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-449"></A><EM CLASS="code">
int num_elem_this_blk,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-450"></A><EM CLASS="code">
int num_nodes_per_elem,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-451"></A><EM CLASS="code">
int num_attr);  			<A HREF="exodusII.book.html#50334051_14923" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-452"></A><EM CLASS="code">
	int ex_put_elem_conn ( </EM>
<A NAME="50334053_marker-97"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-453"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-454"></A><EM CLASS="code">
int elem_blk_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-455"></A><EM CLASS="code">
int* connect);  			<A HREF="exodusII.book.html#50334051_34365" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-456"></A><EM CLASS="code">
	int ex_put_elem_num_map (</EM>
<A NAME="50334053_marker-1358"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1353"></A>int exoid,</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1354"></A>int* elem_map);			<A HREF="exodusII.book.html#50334051_35671" CLASS="XRef"></A></P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1352"></A><EM CLASS="code">
	int ex_put_elem_var ( </EM>
<A NAME="50334053_marker-98"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-457"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-458"></A><EM CLASS="code">
int time_step,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-459"></A><EM CLASS="code">
int elem_var_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-460"></A><EM CLASS="code">
int elem_blk_id</EM>
,</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-461"></A><EM CLASS="code">
int num_elem_this_blk,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-462"></A><EM CLASS="code">
void* elem_var_vals);  			<A HREF="exodusII.book.html#50334051_38391" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-463"></A><EM CLASS="code">
	int ex_put_elem_var_tab ( </EM>
<A NAME="50334053_marker-99"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-464"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-465"></A><EM CLASS="code">
int num_elem_blk,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-466"></A><EM CLASS="code">
int num_elem_var,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-467"></A><EM CLASS="code">
int* elem_var_tab);  			<A HREF="exodusII.book.html#50334051_31128" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-468"></A><EM CLASS="code">
	int ex_put_glob_vars ( </EM>
<A NAME="50334053_marker-100"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-469"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-470"></A><EM CLASS="code">
int time_step,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-471"></A><EM CLASS="code">
int num_glob_vars,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-472"></A><EM CLASS="code">
void* glob_var_vals);  			<A HREF="exodusII.book.html#50334051_37477" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-473"></A><EM CLASS="code">
	int ex_put_info ( </EM>
<A NAME="50334053_marker-101"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-474"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-475"></A><EM CLASS="code">
int num_info,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-476"></A><EM CLASS="code">
char* info);  			<A HREF="exodusII.book.html#50334051_29061" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-477"></A><EM CLASS="code">
	int ex_put_init ( </EM>
<A NAME="50334053_marker-102"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-478"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-479"></A><EM CLASS="code">
char* title,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-480"></A><EM CLASS="code">
int num_dim,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-481"></A><EM CLASS="code">
int num_nodes,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-482"></A><EM CLASS="code">
int num_elem,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-483"></A><EM CLASS="code">
int num_elem_blk,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-484"></A><EM CLASS="code">
int num_node_sets,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-485"></A><EM CLASS="code">
int num_side_sets);  			<A HREF="exodusII.book.html#50334051_34390" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-486"></A><EM CLASS="code">
	int ex_put_map ( </EM>
<A NAME="50334053_marker-103"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-487"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-488"></A><EM CLASS="code">
int* elem_map);  			<A HREF="exodusII.book.html#50334051_41386" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-489"></A><EM CLASS="code">
	int ex_put_nodal_var ( </EM>
<A NAME="50334053_marker-104"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-490"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-491"></A><EM CLASS="code">
int time_step</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-492"></A><EM CLASS="code">
int nodal_var_index,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-493"></A><EM CLASS="code">
int num_nodes,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-494"></A><EM CLASS="code">
void* nodal_var_vals);  			<A HREF="exodusII.book.html#50334051_19926" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-495"></A><EM CLASS="code">
	int ex_put_node_num_map (</EM>
<A NAME="50334053_marker-1328"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1323"></A>int exoid,</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1324"></A>int* node_map)			<A HREF="exodusII.book.html#50334051_29827" CLASS="XRef"></A></P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1312"></A><EM CLASS="code">
	int ex_put_node_set ( </EM>
<A NAME="50334053_marker-105"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-496"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-497"></A><EM CLASS="code">
int node_set_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-498"></A><EM CLASS="code">
int* node_set_node_list);  			<A HREF="exodusII.book.html#50334051_10725" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-499"></A><EM CLASS="code">
	int ex_put_node_set_dist_fact ( </EM>
<A NAME="50334053_marker-106"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-500"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-501"></A><EM CLASS="code">
int node_set_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-502"></A><EM CLASS="code">
void* node_set_dist_fact);  			<A HREF="exodusII.book.html#50334051_30340" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-503"></A><EM CLASS="code">
	int ex_put_node_set_param ( </EM>
<A NAME="50334053_marker-107"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-504"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-505"></A><EM CLASS="code">
int node_set_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-506"></A><EM CLASS="code">
int num_nodes_in_set,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-507"></A><EM CLASS="code">
int num_dist_in_set);  			<A HREF="exodusII.book.html#50334051_17372" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-508"></A><EM CLASS="code">
	int ex_put_prop ( </EM>
<A NAME="50334053_marker-108"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-509"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-510"></A><EM CLASS="code">
int obj_type,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-511"></A><EM CLASS="code">
int obj_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-512"></A><EM CLASS="code">
char* prop_name,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-513"></A><EM CLASS="code">
int value);  			<A HREF="exodusII.book.html#50334051_16441" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-514"></A><EM CLASS="code">
	int ex_put_prop_array ( </EM>
<A NAME="50334053_marker-109"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-515"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-516"></A><EM CLASS="code">
int obj_type,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-517"></A><EM CLASS="code">
char* prop_name,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-518"></A><EM CLASS="code">
int* values);  			<A HREF="exodusII.book.html#50334051_38300" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-519"></A><EM CLASS="code">
	int ex_put_prop_names ( </EM>
<A NAME="50334053_marker-110"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-520"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-521"></A><EM CLASS="code">
int obj_type,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-522"></A><EM CLASS="code">
int num_props,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-523"></A><EM CLASS="code">
char** prop_names);  			<A HREF="exodusII.book.html#50334051_21505" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-524"></A><EM CLASS="code">
	int ex_put_qa ( </EM>
<A NAME="50334053_marker-111"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-525"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-526"></A><EM CLASS="code">
int num_qa_records,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-527"></A><EM CLASS="code">
char* qa_record);  			<A HREF="exodusII.book.html#50334051_15957" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-528"></A><EM CLASS="code">
	int ex_put_side_set ( </EM>
<A NAME="50334053_marker-112"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-529"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-530"></A><EM CLASS="code">
int side_set_id</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-531"></A><EM CLASS="code">
int* side_set_elem_list,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-532"></A><EM CLASS="code">
int* side_set_side_list);  			<A HREF="exodusII.book.html#50334051_42079" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-533"></A><EM CLASS="code">
	int ex_put_side_set_dist_fact ( </EM>
<A NAME="50334053_marker-113"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-534"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-535"></A><EM CLASS="code">
int side_set_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-536"></A><EM CLASS="code">
void* side_set_dist_fact);  			<A HREF="exodusII.book.html#50334051_13356" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-537"></A><EM CLASS="code">
	int ex_put_side_set_param ( </EM>
<A NAME="50334053_marker-114"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-538"></A><EM CLASS="code">
int</EM>
<EM CLASS="Bold">
 exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-539"></A><EM CLASS="code">
int side_set_id,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-540"></A><EM CLASS="code">
int num_side_in_set,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-541"></A><EM CLASS="code">
int num_dist_fact_in_set);  			<A HREF="exodusII.book.html#50334051_32859" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-542"></A><EM CLASS="code">
	int ex_put_var_names ( </EM>
<A NAME="50334053_marker-115"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-543"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-544"></A><EM CLASS="code">
char* var_type,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-545"></A><EM CLASS="code">
int num_vars,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-546"></A><EM CLASS="code">
char** var_names);  			<A HREF="exodusII.book.html#50334051_26126" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-547"></A><EM CLASS="code">
	int ex_put_var_param ( </EM>
<A NAME="50334053_marker-116"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-548"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-549"></A><EM CLASS="code">
char* var_type,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-550"></A><EM CLASS="code">
int num_vars);  			<A HREF="exodusII.book.html#50334051_29220" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-551"></A><EM CLASS="code">
	int ex_put_time ( </EM>
<A NAME="50334053_marker-117"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-552"></A><EM CLASS="code">
int exoid,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-553"></A><EM CLASS="code">
int time_step,</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-554"></A><EM CLASS="code">
void* time_value);  			<A HREF="exodusII.book.html#50334051_33640" CLASS="XRef"></A></EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-555"></A><EM CLASS="code">
	int ex_update (</EM>
<A NAME="50334053_marker-118"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-556"></A><EM CLASS="code">
int exoid);  			<A HREF="exodusII.book.html#50334051_28073" CLASS="XRef"></A></EM>
</P>
</DIV>
<DIV>
<H4 CLASS="Heading">
<A NAME="50334053_pgfId-557"></A>FORTRAN binding routines</H4>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-558"></A><EM CLASS="code">
	SUBROUTINE EXCLOS ( IDEXO, IERR)		<A HREF="exodusII.book.html#50334051_12158" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-119"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-559"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-560"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-561"></A><EM CLASS="code">
	SUBROUTINE EXCN2S(IDEXO, NSESS, NDESS, IXEESS, IXNESS, LTEESS, LTNESS, LTSESS, IERR)			<A HREF="exodusII.book.html#50334051_24098" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-120"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-562"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-563"></A><EM CLASS="code">
INTEGER NSESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-564"></A><EM CLASS="code">
INTEGER NDESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-565"></A><EM CLASS="code">
INTEGER IXEESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-566"></A><EM CLASS="code">
INTEGER IXNESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-567"></A><EM CLASS="code">
INTEGER LTEESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-568"></A><EM CLASS="code">
INTEGER LTNESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-569"></A><EM CLASS="code">
INTEGER LTSESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-570"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-571"></A><EM CLASS="code">
	INTEGER FUNCTION EXCRE (PATH, ICMODE, ICOMPWS, IOWS, IERR)			<A HREF="exodusII.book.html#50334051_21931" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-121"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-572"></A><EM CLASS="code">
CHARACTER*(*) PATH</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-573"></A><EM CLASS="code">
INTEGER ICMODE		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-574"></A><EM CLASS="code">
INTEGER ICOMPWS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-575"></A><EM CLASS="code">
INTEGER IOWS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-576"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-577"></A><EM CLASS="code">
	SUBROUTINE EXERR ( MODNAM, MSG, ERRNUM)		<A HREF="exodusII.book.html#50334051_22311" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-122"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-578"></A><EM CLASS="code">
CHARACTER*MXSTLN MODNAM</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-579"></A><EM CLASS="code">
CHARACTER*MXLNLN MSG</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-580"></A><EM CLASS="code">
INTEGER ERRNUM		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-581"></A><EM CLASS="code">
	SUBROUTINE EXGATM ( IDEXO, TIME, IERR)		<A HREF="exodusII.book.html#50334051_34299" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-123"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-582"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-583"></A><EM CLASS="code">
REAL TIME(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-584"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-585"></A><EM CLASS="code">
	SUBROUTINE EXGCNS ( IDEXO, IDNPSS, NNNPS, NDNPS, IXNNPS, IXDNPS, LTNNPS, FACNPS, IERR)			<A HREF="exodusII.book.html#50334051_31865" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-124"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-586"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-587"></A><EM CLASS="code">
INTEGER IDNPSS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-588"></A><EM CLASS="code">
INTEGER NNNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-589"></A><EM CLASS="code">
INTEGER NDNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-590"></A><EM CLASS="code">
INTEGER IXNNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-591"></A><EM CLASS="code">
INTEGER IXDNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-592"></A><EM CLASS="code">
INTEGER LTNNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-593"></A><EM CLASS="code">
REAL FACNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-594"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-595"></A><EM CLASS="code">
	SUBROUTINE EXGCON ( IDEXO, NAMECO, IERR)		<A HREF="exodusII.book.html#50334051_31901" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-125"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-596"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-597"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMECO(*)</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-598"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-599"></A><EM CLASS="code">
	SUBROUTINE EXGCOR ( IDEXO, XN, YN, ZN, IERR)		<A HREF="exodusII.book.html#50334051_36174" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-126"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-600"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-601"></A><EM CLASS="code">
REAL XN(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-602"></A><EM CLASS="code">
REAL YN(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-603"></A><EM CLASS="code">
REAL ZN(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-604"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-605"></A><EM CLASS="code">
	SUBROUTINE EXGCSS ( IDEXO, IDESSS, NSESS, NDESS, IXEESS, IXDESS, LTEESS, LTSESS, FACESS, IERR)			<A HREF="exodusII.book.html#50334051_30116" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-127"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-606"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-607"></A><EM CLASS="code">
INTEGER IDESSS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-608"></A><EM CLASS="code">
INTEGER NSESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-609"></A><EM CLASS="code">
INTEGER NDESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-610"></A><EM CLASS="code">
INTEGER IXEESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-611"></A><EM CLASS="code">
INTEGER IXDESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-612"></A><EM CLASS="code">
INTEGER LTEESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-613"></A><EM CLASS="code">
INTEGER LTSESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-614"></A><EM CLASS="code">
REAL FACESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-615"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-616"></A><EM CLASS="code">
	SUBROUTINE EXGEAT ( IDEXO, IDELB, ATRIB, IERR)		<A HREF="exodusII.book.html#50334051_16035" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-128"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-617"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-618"></A><EM CLASS="code">
INTEGER IDELB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-619"></A><EM CLASS="code">
REAL ATRIB(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-620"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-621"></A><EM CLASS="code">
	SUBROUTINE EXGEBI ( IDEXO, IDELBS, IERR)		<A HREF="exodusII.book.html#50334051_15251" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-129"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-622"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-623"></A><EM CLASS="code">
INTEGER IDELBS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-624"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-625"></A><EM CLASS="code">
	SUBROUTINE EXGELB ( IDEXO, IDELB, NAMELB, NUMELB, NUMLNK, NUMATR, IERR)			<A HREF="exodusII.book.html#50334051_28882" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-130"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-626"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-627"></A><EM CLASS="code">
INTEGER IDELB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-628"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMELB</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-629"></A><EM CLASS="code">
INTEGER NUMELB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-630"></A><EM CLASS="code">
INTEGER NUMLNK		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-631"></A><EM CLASS="code">
INTEGER NUMATR		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-632"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-633"></A><EM CLASS="code">
	SUBROUTINE EXGELC ( IDEXO, IDELB, LINK, IERR)		<A HREF="exodusII.book.html#50334051_17436" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-131"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-634"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-635"></A><EM CLASS="code">
INTEGER IDELB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-636"></A><EM CLASS="code">
INTEGER LINK(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-637"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-638"></A><EM CLASS="code">
	SUBROUTINE EXGENM ( IDEXO, MAPEL, IERR)		<A HREF="exodusII.book.html#50334051_22184" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-1378"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1372"></A>INTEGER IDEXO</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1376"></A>INTEGER MAPEL(*)</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1377"></A>INTEGER IERR</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1371"></A><EM CLASS="code">
	SUBROUTINE EXGEV ( IDEXO, ISTEP, IXELEV, IDELB, NUMELB, VALEV, IERR)</EM>
<A NAME="50334053_marker-132"></A></P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1303"></A>			<A HREF="exodusII.book.html#50334051_29752" CLASS="XRef"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-639"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-640"></A><EM CLASS="code">
INTEGER ISTEP		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-641"></A><EM CLASS="code">
INTEGER IXELEV		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-642"></A><EM CLASS="code">
INTEGER IDELB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-643"></A><EM CLASS="code">
INTEGER NUMELB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-644"></A><EM CLASS="code">
REAL VALEV(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-645"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-646"></A><EM CLASS="code">
	SUBROUTINE EXGEVT ( IDEXO, IXELEV, IELNUM, ISTPB, ISTPE, VALEV, IERR)</EM>
<A NAME="50334053_marker-133"></A></P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1304"></A>			<A HREF="exodusII.book.html#50334051_32150" CLASS="XRef"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-647"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-648"></A><EM CLASS="code">
INTEGER IXELEV		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-649"></A><EM CLASS="code">
INTEGER IELNUM		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-650"></A><EM CLASS="code">
INTEGER ISTPB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-651"></A><EM CLASS="code">
INTEGER ISTPE		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-652"></A><EM CLASS="code">
REAL VALEV(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-653"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-654"></A><EM CLASS="code">
	SUBROUTINE EXGGV ( IDEXO, ISTEP, NVARGL, VALGV, IERR)		<A HREF="exodusII.book.html#50334051_39653" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-134"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-655"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-656"></A><EM CLASS="code">
INTEGER ISTEP		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-657"></A><EM CLASS="code">
INTEGER NVARGL		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-658"></A><EM CLASS="code">
REAL VALGV(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-659"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-660"></A><EM CLASS="code">
	SUBROUTINE EXGGVT ( IDEXO, IXGLOV, ISTPB, ISTPE, VALGV, IERR)</EM>
<A NAME="50334053_marker-135"></A></P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1305"></A>			<A HREF="exodusII.book.html#50334051_33485" CLASS="XRef"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-661"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-662"></A><EM CLASS="code">
INTEGER IXGLOV		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-663"></A><EM CLASS="code">
INTEGER ISTPB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-664"></A><EM CLASS="code">
INTEGER ISTPE		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-665"></A><EM CLASS="code">
REAL VALGV(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-666"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-667"></A><EM CLASS="code">
	SUBROUTINE EXGINF ( IDEXO, INFO, IERR)		<A HREF="exodusII.book.html#50334051_16434" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-136"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-668"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-669"></A><EM CLASS="code">
CHARACTER*MXLNLN INFO(*)</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-670"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-671"></A><EM CLASS="code">
	SUBROUTINE EXGINI ( IDEXO, TITLE, NDIM, NUMNP, NUMEL, NELBLK, NUMNPS, NUMESS, IERR)			<A HREF="exodusII.book.html#50334051_24784" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-137"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-672"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-673"></A><EM CLASS="code">
CHARACTER*MXLNLN TITLE</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-674"></A><EM CLASS="code">
INTEGER NDIM		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-675"></A><EM CLASS="code">
INTEGER NUMNP		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-676"></A><EM CLASS="code">
INTEGER NUMEL		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-677"></A><EM CLASS="code">
INTEGER NELBLK		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-678"></A><EM CLASS="code">
INTEGER NUMNPS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-679"></A><EM CLASS="code">
INTEGER NUMESS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-680"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-681"></A><EM CLASS="code">
	SUBROUTINE EXGMAP ( IDEXO, MAPEL, IERR)		<A HREF="exodusII.book.html#50334051_22279" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-138"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-682"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-683"></A><EM CLASS="code">
INTEGER MAPEL(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-684"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-685"></A><EM CLASS="code">
	SUBROUTINE EXGNNM (IDEXO, MAPNOD, IERR)		<A HREF="exodusII.book.html#50334051_35467" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-1351"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1345"></A>INTEGER IDEXO</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1349"></A>INTEGER MAPNOD(*)</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1350"></A>INTEGER IERR</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1344"></A><EM CLASS="code">
	SUBROUTINE EXGNP ( IDEXO, IDNPS, NNNPS, NDNPS, IERR)		<A HREF="exodusII.book.html#50334051_25184" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-139"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-686"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-687"></A><EM CLASS="code">
INTEGER IDNPS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-688"></A><EM CLASS="code">
INTEGER NNNPS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-689"></A><EM CLASS="code">
INTEGER NDNPS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-690"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-691"></A><EM CLASS="code">
	SUBROUTINE EXGNS ( IDEXO, IDNPS, LTNNPS, IERR)		<A HREF="exodusII.book.html#50334051_33368" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-140"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-692"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-693"></A><EM CLASS="code">
INTEGER IDNPS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-694"></A><EM CLASS="code">
INTEGER LTNNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-695"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-696"></A><EM CLASS="code">
	SUBROUTINE EXGNSD ( IDEXO, IDNPS, FACNPS, IERR)		<A HREF="exodusII.book.html#50334051_37354" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-141"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-697"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-698"></A><EM CLASS="code">
INTEGER IDNPS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-699"></A><EM CLASS="code">
REAL FACNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-700"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-701"></A><EM CLASS="code">
	SUBROUTINE EXGNSI ( IDEXO, IDNPSS, IERR)		<A HREF="exodusII.book.html#50334051_34277" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-142"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-702"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-703"></A><EM CLASS="code">
INTEGER IDNPSS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-704"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-705"></A><EM CLASS="code">
	SUBROUTINE EXGNV ( IDEXO, ISTEP, IXNODV, NUMNP, VALNV, IERR)</EM>
<A NAME="50334053_marker-143"></A></P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1306"></A>			<A HREF="exodusII.book.html#50334051_12540" CLASS="XRef"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-706"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-707"></A><EM CLASS="code">
INTEGER ISTEP	</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-708"></A><EM CLASS="code">
INTEGER IXNODV		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-709"></A><EM CLASS="code">
INTEGER NUMNP		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-710"></A><EM CLASS="code">
REAL VALNV(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-711"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-712"></A><EM CLASS="code">
	SUBROUTINE EXGNVT ( IDEXO, IXNODV, NODNUM, ISTPB, ISTPE, VALNV, IERR)</EM>
<A NAME="50334053_marker-144"></A></P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1307"></A>			<A HREF="exodusII.book.html#50334051_18090" CLASS="XRef"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-713"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-714"></A><EM CLASS="code">
INTEGER IXNODV		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-715"></A><EM CLASS="code">
INTEGER NODNUM		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-716"></A><EM CLASS="code">
INTEGER ISTPB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-717"></A><EM CLASS="code">
INTEGER ISTPE		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-718"></A><EM CLASS="code">
REAL VALNV(*)</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-719"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-720"></A><EM CLASS="code">
	SUBROUTINE EXGP ( IDEXO, ITYPE, ID, NAMEPR, IVAL, IERR)		<A HREF="exodusII.book.html#50334051_31447" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-145"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-721"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-722"></A><EM CLASS="code">
INTEGER ITYPE		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-723"></A><EM CLASS="code">
INTEGER ID		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-724"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMEPR</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-725"></A><EM CLASS="code">
INTEGER IVAL		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-726"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-727"></A><EM CLASS="code">
	SUBROUTINE EXGPA ( IDEXO, ITYPE, NAMEPR, IVALS, IERR)		<A HREF="exodusII.book.html#50334051_41253" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-146"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-728"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-729"></A><EM CLASS="code">
INTEGER ITYPE		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-730"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMEPR</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-731"></A><EM CLASS="code">
INTEGER IVAL(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-732"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-733"></A><EM CLASS="code">
	SUBROUTINE EXGPN ( IDEXO, ITYPE, NAMEPR, IERR)		<A HREF="exodusII.book.html#50334051_23137" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-147"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-734"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-735"></A><EM CLASS="code">
INTEGER ITYPE		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-736"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMEPR(*)</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-737"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-738"></A><EM CLASS="code">
	SUBROUTINE EXGQA ( IDEXO, QAREC, IERR)		<A HREF="exodusII.book.html#50334051_16581" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-148"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-739"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-740"></A><EM CLASS="code">
CHARACTER*MXSTLN QAREC(4,*)</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-741"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-742"></A><EM CLASS="code">
	SUBROUTINE EXGSP ( IDEXO, IDESS, NSESS, NDESS, IERR)		<A HREF="exodusII.book.html#50334051_22538" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-149"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-743"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-744"></A><EM CLASS="code">
INTEGER IDESS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-745"></A><EM CLASS="code">
INTEGER NSESS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-746"></A><EM CLASS="code">
INTEGER NDESS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-747"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-748"></A><EM CLASS="code">
	SUBROUTINE EXGSS ( IDEXO, IDESS, LTEESS, LTSESS, IERR)		<A HREF="exodusII.book.html#50334051_34153" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-150"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-749"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-750"></A><EM CLASS="code">
INTEGER IDESS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-751"></A><EM CLASS="code">
INTEGER LTEESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-752"></A><EM CLASS="code">
INTEGER LTSESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-753"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-754"></A><EM CLASS="code">
	SUBROUTINE EXGSSD ( IDEXO, IDESS, FACESS, IERR)		<A HREF="exodusII.book.html#50334051_42724" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-151"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-755"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-756"></A><EM CLASS="code">
INTEGER IDESS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-757"></A><EM CLASS="code">
REAL FACESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-758"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-759"></A><EM CLASS="code">
	SUBROUTINE EXGSSI ( IDEXO, IDESSS, IERR)		<A HREF="exodusII.book.html#50334051_19733" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-152"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-760"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-761"></A><EM CLASS="code">
INTEGER IDESSS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-762"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-763"></A><EM CLASS="code">
	SUBROUTINE EXGSSN ( IDEXO, IDESS, INCNT, LTNESS, IERR)		<A HREF="exodusII.book.html#50334051_16306" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-153"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-764"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-765"></A><EM CLASS="code">
INTEGER IDESS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-766"></A><EM CLASS="code">
INCNT(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-767"></A><EM CLASS="code">
INTEGER LTNESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-768"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-769"></A><EM CLASS="code">
	SUBROUTINE EXGTIM ( IDEXO, NSTEP, TIME, IERR)		<A HREF="exodusII.book.html#50334051_15529" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-1650"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-770"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-771"></A><EM CLASS="code">
INTEGER NSTEP		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-772"></A><EM CLASS="code">
REAL TIME		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-773"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-774"></A><EM CLASS="code">
	SUBROUTINE EXGVAN ( IDEXO, VARTYP, NVAR, NAMES, IERR)		<A HREF="exodusII.book.html#50334051_24360" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-154"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-775"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-776"></A><EM CLASS="code">
CHARACTER*1 VARTYP</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-777"></A><EM CLASS="code">
INTEGER NVAR		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-778"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMES(*)</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-779"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-780"></A><EM CLASS="code">
	SUBROUTINE EXGVP ( IDEXO, VARTYP, NVAR, IERR)		<A HREF="exodusII.book.html#50334051_13500" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-155"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-781"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-782"></A><EM CLASS="code">
CHARACTER*1 VARTYP</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-783"></A><EM CLASS="code">
INTEGER NVAR		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-784"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-785"></A><EM CLASS="code">
	SUBROUTINE EXGVTT ( IDEXO, NELBLK, NVAREL, ISEVOK, IERR)		<A HREF="exodusII.book.html#50334051_22499" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-156"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-786"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-787"></A><EM CLASS="code">
INTEGER NELBLK		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-788"></A><EM CLASS="code">
INTEGER NVAREL		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-789"></A><EM CLASS="code">
INTEGER ISEVOK(NVAREL, NELBLK)</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-790"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-791"></A><EM CLASS="code">
	SUBROUTINE EXINQ ( IDEXO, INFREQ, INTRET, RELRET, CHRRET, IERR)</EM>
<A NAME="50334053_marker-157"></A></P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1308"></A>			<A HREF="exodusII.book.html#50334051_23612" CLASS="XRef"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-792"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-793"></A><EM CLASS="code">
INTEGER INFREQ		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-794"></A><EM CLASS="code">
INTEGER INTRET		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-795"></A><EM CLASS="code">
REAL RELRET		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-796"></A><EM CLASS="code">
CHARACTER*(*) CHRRET</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-797"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-798"></A><EM CLASS="code">
	INTEGER FUNCTION EXOPEN (PATH, IMODE, ICOMPWS, IOWS, VERS, IERR)</EM>
<A NAME="50334053_marker-158"></A></P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1309"></A>			<A HREF="exodusII.book.html#50334051_14859" CLASS="XRef"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-799"></A><EM CLASS="code">
CHARACTER*(*) PATH</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-800"></A><EM CLASS="code">
INTEGER IMODE		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-801"></A><EM CLASS="code">
INTEGER ICOMPWS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-802"></A><EM CLASS="code">
INTEGER IOWS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-803"></A><EM CLASS="code">
REAL VERS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-804"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-805"></A><EM CLASS="code">
	SUBROUTINE EXOPTS ( OPTVAL, IERR)		<A HREF="exodusII.book.html#50334051_42529" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-159"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-806"></A><EM CLASS="code">
INTEGER OPTVAL		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-807"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-808"></A><EM CLASS="code">
	SUBROUTINE EXPCNS ( IDEXO, IDNPSS, NNNPS, NDNPS, IXNNPS, IXDNPS, LTNNPS, FACNPS, IERR)			<A HREF="exodusII.book.html#50334051_39090" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-160"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-809"></A><EM CLASS="code">
INTEGER IDEXO</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-810"></A><EM CLASS="code">
INTEGER IDNPSS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-811"></A><EM CLASS="code">
INTEGER NNNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-812"></A><EM CLASS="code">
INTEGER NDNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-813"></A><EM CLASS="code">
INTEGER IXNNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-814"></A><EM CLASS="code">
INTEGER IXDNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-815"></A><EM CLASS="code">
INTEGER LTNNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-816"></A><EM CLASS="code">
REAL FACNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-817"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-818"></A><EM CLASS="code">
	SUBROUTINE EXPCON ( IDEXO, NAMECO, IERR)		<A HREF="exodusII.book.html#50334051_32573" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-161"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-819"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-820"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMECO(*)</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-821"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-822"></A><EM CLASS="code">
	SUBROUTINE EXPCOR ( IDEXO, XN, YN, ZN, IERR)		<A HREF="exodusII.book.html#50334051_10305" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-162"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-823"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-824"></A><EM CLASS="code">
REAL XN(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-825"></A><EM CLASS="code">
REAL YN(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-826"></A><EM CLASS="code">
REAL ZN(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-827"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-828"></A><EM CLASS="code">
	SUBROUTINE EXPCSS ( IDEXO, IDESSS, NSESS, NDESS, IXEESS, IXDESS, LTEESS, LTSESS, FACESS, IERR)			<A HREF="exodusII.book.html#50334051_37836" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-163"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-829"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-830"></A><EM CLASS="code">
INTEGER IDESSS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-831"></A><EM CLASS="code">
INTEGER NSESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-832"></A><EM CLASS="code">
INTEGER NDESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-833"></A><EM CLASS="code">
INTEGER IXEESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-834"></A><EM CLASS="code">
INTEGER IXDESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-835"></A><EM CLASS="code">
INTEGER LTEESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-836"></A><EM CLASS="code">
INTEGER LTSESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-837"></A><EM CLASS="code">
REAL FACESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-838"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-839"></A><EM CLASS="code">
	SUBROUTINE EXPEAT ( IDEXO, IDELB, ATRIB, IERR)		<A HREF="exodusII.book.html#50334051_42312" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-164"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-840"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-841"></A><EM CLASS="code">
INTEGER IDELB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-842"></A><EM CLASS="code">
REAL ATRIB(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-843"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-844"></A><EM CLASS="code">
	SUBROUTINE EXPELB ( IDEXO, IDELB, NAMELB, NUMELB, NUMLNK, NUMATR, IERR)			<A HREF="exodusII.book.html#50334051_14923" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-165"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-845"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-846"></A><EM CLASS="code">
INTEGER IDELB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-847"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMELB</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-848"></A><EM CLASS="code">
INTEGER NUMELB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-849"></A><EM CLASS="code">
INTEGER NUMLNK		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-850"></A><EM CLASS="code">
INTEGER NUMATR		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-851"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-852"></A><EM CLASS="code">
	SUBROUTINE EXPENM (IDEXO, MAPEL, IERR)		<A HREF="exodusII.book.html#50334051_35671" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-1363"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1360"></A>INTEGER IDEXO</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1361"></A>INTEGER MAPEL(*)</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1362"></A>INTEGER IERR</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1359"></A><EM CLASS="code">
	SUBROUTINE EXPELC ( IDEXO, IDELB, LINK, IERR)			<A HREF="exodusII.book.html#50334051_34365" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-166"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-853"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-854"></A><EM CLASS="code">
INTEGER IDELB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-855"></A><EM CLASS="code">
INTEGER LINK(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-856"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-857"></A><EM CLASS="code">
	SUBROUTINE EXPEV ( IDEXO, ISTEP, IXELEV, IDELB, NUMELB, VALEV, IERR)</EM>
<A NAME="50334053_marker-167"></A></P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1310"></A>			<A HREF="exodusII.book.html#50334051_38391" CLASS="XRef"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-858"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-859"></A><EM CLASS="code">
INTEGER ISTEP		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-860"></A><EM CLASS="code">
INTEGER IXELEV		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-861"></A><EM CLASS="code">
INTEGER IDELB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-862"></A><EM CLASS="code">
INTEGER NUMELB		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-863"></A><EM CLASS="code">
REAL VALEV(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-864"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-865"></A><EM CLASS="code">
	SUBROUTINE EXPGV ( IDEXO, ISTEP, NVARGL, VALGV, IERR)		<A HREF="exodusII.book.html#50334051_37477" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-168"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-866"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-867"></A><EM CLASS="code">
INTEGER ISTEP		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-868"></A><EM CLASS="code">
INTEGER NVARGL		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-869"></A><EM CLASS="code">
REAL VALGV(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-870"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-871"></A><EM CLASS="code">
	SUBROUTINE EXPINF ( IDEXO, NINFO, INFO, IERR)		<A HREF="exodusII.book.html#50334051_29061" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-169"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-872"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-873"></A><EM CLASS="code">
INTEGER NINFO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-874"></A><EM CLASS="code">
CHARACTER*MXLNLN INFO(*)</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-875"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-876"></A><EM CLASS="code">
	SUBROUTINE EXPINI ( IDEXO, TITLE, NDIM, NUMNP, NUMEL, NELBLK, NUMNPS, NUMESS, IERR)			<A HREF="exodusII.book.html#50334051_34390" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-170"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-877"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-878"></A><EM CLASS="code">
CHARACTER*MXLNLN TITLE</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-879"></A><EM CLASS="code">
INTEGER NDIM</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-880"></A><EM CLASS="code">
INTEGER NUMNP</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-881"></A><EM CLASS="code">
INTEGER NUMEL</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-882"></A><EM CLASS="code">
INTEGER NELBLK</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-883"></A><EM CLASS="code">
INTEGER NUMNPS</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-884"></A><EM CLASS="code">
INTEGER NUMESS</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-885"></A><EM CLASS="code">
INTEGER IERR</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-886"></A><EM CLASS="code">
	SUBROUTINE EXPMAP ( IDEXO, MAPEL, IERR)		<A HREF="exodusII.book.html#50334051_41386" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-171"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-887"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-888"></A><EM CLASS="code">
INTEGER MAPEL(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-889"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-890"></A><EM CLASS="code">
	SUBROUTINE EXPNNM ( IDEXO, MAPNOD, IERR)		<A HREF="exodusII.book.html#50334051_29827" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-1333"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1330"></A>INTEGER IDEXO</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1331"></A>INTEGER MAPNOD(*)</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-1332"></A>INTEGER IERR</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1329"></A><EM CLASS="code">
	SUBROUTINE EXPNP ( IDEXO, IDNPS, NNNPS, NDNPS, IERR)		<A HREF="exodusII.book.html#50334051_17372" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-172"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-891"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-892"></A><EM CLASS="code">
INTEGER IDNPS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-893"></A><EM CLASS="code">
INTEGER NNNPS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-894"></A><EM CLASS="code">
INTEGER NDNPS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-895"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-896"></A><EM CLASS="code">
	SUBROUTINE EXPNS ( IDEXO, IDNPS, LTNNPS, IERR)		<A HREF="exodusII.book.html#50334051_10725" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-173"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-897"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-898"></A><EM CLASS="code">
INTEGER IDNPS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-899"></A><EM CLASS="code">
INTEGER LTNNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-900"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-901"></A><EM CLASS="code">
	SUBROUTINE EXPNSD ( IDEXO, IDNPS, FACNPS, IERR)		<A HREF="exodusII.book.html#50334051_30340" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-174"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-902"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-903"></A><EM CLASS="code">
INTEGER IDNPS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-904"></A><EM CLASS="code">
REAL FACNPS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-905"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-906"></A><EM CLASS="code">
	SUBROUTINE EXPNV ( IDEXO, ISTEP, IXNODV, NUMNP, VALNV, IERR)</EM>
<A NAME="50334053_marker-175"></A></P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-1311"></A>			<A HREF="exodusII.book.html#50334051_19926" CLASS="XRef"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-907"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-908"></A><EM CLASS="code">
INTEGER ISTEP		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-909"></A><EM CLASS="code">
INTEGER IXNODV		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-910"></A><EM CLASS="code">
INTEGER NUMNP		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-911"></A><EM CLASS="code">
REAL VALNV(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-912"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-913"></A><EM CLASS="code">
	SUBROUTINE EXPP ( IDEXO, ITYPE, ID, NAMEPR, IVAL, IERR)		<A HREF="exodusII.book.html#50334051_16441" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-176"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-914"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-915"></A><EM CLASS="code">
INTEGER ITYPE		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-916"></A><EM CLASS="code">
INTEGER ID		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-917"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMEPR</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-918"></A><EM CLASS="code">
INTEGER IVAL		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-919"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-920"></A><EM CLASS="code">
	SUBROUTINE EXPPA ( IDEXO, ITYPE, NAMEPR, IVALS, IERR)		<A HREF="exodusII.book.html#50334051_38300" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-177"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-921"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-922"></A><EM CLASS="code">
INTEGER ITYPE		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-923"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMEPR</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-924"></A><EM CLASS="code">
INTEGER IVAL(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-925"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-926"></A><EM CLASS="code">
	SUBROUTINE EXPPN ( IDEXO, ITYPE, NPROPS, NAMEPR, IERR)		<A HREF="exodusII.book.html#50334051_21505" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-178"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-927"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-928"></A><EM CLASS="code">
INTEGER ITYPE		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-929"></A><EM CLASS="code">
INTEGER NPROPS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-930"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMEPR(*)</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-931"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-932"></A><EM CLASS="code">
	SUBROUTINE EXPQA ( IDEXO, NQAREC, QAREC, IERR)		<A HREF="exodusII.book.html#50334051_15957" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-179"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-933"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-934"></A><EM CLASS="code">
INTEGER NQAREC		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-935"></A><EM CLASS="code">
CHARACTER*MXSTLN QAREC (4,*)</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-936"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-937"></A><EM CLASS="code">
	SUBROUTINE EXPSP ( IDEXO, IDESS, NSESS, NDESS, IERR)		<A HREF="exodusII.book.html#50334051_32859" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-180"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-938"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-939"></A><EM CLASS="code">
INTEGER IDESS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-940"></A><EM CLASS="code">
INTEGER NSESS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-941"></A><EM CLASS="code">
INTEGER NDESS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-942"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-943"></A><EM CLASS="code">
	SUBROUTINE EXPSS ( IDEXO, IDESS, LTEESS, LTSESS, IERR)		<A HREF="exodusII.book.html#50334051_42079" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-181"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-944"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-945"></A><EM CLASS="code">
INTEGER IDESS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-946"></A><EM CLASS="code">
INTEGER LTEESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-947"></A><EM CLASS="code">
INTEGER LTSESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-948"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-949"></A><EM CLASS="code">
	SUBROUTINE EXPSSD ( IDEXO, IDESS, FACESS, IERR)		<A HREF="exodusII.book.html#50334051_13356" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-182"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-950"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-951"></A><EM CLASS="code">
INTEGER IDESS		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-952"></A><EM CLASS="code">
REAL FACESS(*)		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-953"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-954"></A><EM CLASS="code">
	SUBROUTINE EXPTIM ( IDEXO, NSTEP, TIME, IERR)		<A HREF="exodusII.book.html#50334051_33640" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-183"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-955"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-956"></A><EM CLASS="code">
INTEGER NSTEP		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-957"></A><EM CLASS="code">
REAL TIME		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-958"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-959"></A><EM CLASS="code">
	SUBROUTINE EXPVAN ( IDEXO, VARTYP, NVAR,  NAMES, IERR)		<A HREF="exodusII.book.html#50334051_26126" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-184"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-960"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-961"></A><EM CLASS="code">
CHARACTER*1 VARTYP</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-962"></A><EM CLASS="code">
INTEGER NVAR		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-963"></A><EM CLASS="code">
CHARACTER*MXSTLN NAMES(*)</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-964"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-965"></A><EM CLASS="code">
	SUBROUTINE EXPVP ( IDEXO, VARTYP, NVAR, IERR)		<A HREF="exodusII.book.html#50334051_29220" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-185"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-966"></A><EM CLASS="code">
INTEGER IDEXO</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-967"></A><EM CLASS="code">
CHARACTER*1 VARTYP</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-968"></A><EM CLASS="code">
INTEGER NVAR		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-969"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-970"></A><EM CLASS="code">
	SUBROUTINE EXPVTT ( IDEXO, NELBLK, NVAREL, ISEVOK, IERR)		<A HREF="exodusII.book.html#50334051_31128" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-186"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-971"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-972"></A><EM CLASS="code">
INTEGER NELBLK		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-973"></A><EM CLASS="code">
INTEGER NVAREL		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-974"></A><EM CLASS="code">
INTEGER ISEVOK(NVAREL,NELBLK)</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-975"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="FuncDesc">
<A NAME="50334053_pgfId-976"></A><EM CLASS="code">
	SUBROUTINE EXUPDA ( IDEXO, IERR)		<A HREF="exodusII.book.html#50334051_28073" CLASS="XRef"></A></EM>
<A NAME="50334053_marker-187"></A></P>
<P CLASS="Var">
<A NAME="50334053_pgfId-977"></A><EM CLASS="code">
INTEGER IDEXO		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-978"></A><EM CLASS="code">
INTEGER IERR		</EM>
</P>
<P CLASS="Var">
<A NAME="50334053_pgfId-979"></A>&nbsp;</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Appendix">
<A NAME="50334054_pgfId-78"></A><DIV>
<IMG SRC="exodusII.book-25.gif">
</DIV>
<A NAME="50334054_12865"></A>Appendix C</H2>
</DIV>
<DIV>
<H2 CLASS="AppTitle">
<A NAME="50334054_pgfId-87"></A><A NAME="50334054_42694"></A><A NAME="50334054_marker-72"></A>Error Messages</H2>
<P CLASS="Body">
<A NAME="50334054_pgfId-113"></A>This appendix contains descriptions of error codes that are returned by the EXODUS II library routines.</P>
<P CLASS="Body">
<A NAME="50334054_pgfId-81"></A>The following are return codes that are specific to EXODUS II routines.  The error names are defined constants (in <EM CLASS="code">
exodusII.h</EM>
 for C and <EM CLASS="code">
exodusII.inc</EM>
 for Fortran) currently assigned the specified values.  A 0 (zero) means no error; a positive number is a warning;  a negative number is a fatal error.</P>
<TABLE>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="50334054_pgfId-395"></A>Error Name (C)</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="50334054_pgfId-467"></A>Error Name (Fortran)</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="50334054_pgfId-397"></A>Value</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="50334054_pgfId-399"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-401"></A>EX_FATAL</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-469"></A>EXFATL</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-403"></A>-1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-405"></A>fatal error flag</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-407"></A>EX_OK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-471"></A>EXOK</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-409"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-411"></A>no error flag</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-413"></A>EX_WARN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-473"></A>EXWARN</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-415"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-417"></A>warning flag</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-419"></A>EX_MEMFAIL</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-475"></A>EXMEMF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-421"></A>-100</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-423"></A>memory allocation failure flag</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-425"></A>EX_BADFILEMODE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-477"></A>EXBFMD</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-427"></A>-101</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-429"></A>bad file mode</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-431"></A>EX_BADFILEID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-479"></A>EXBFID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-433"></A>-102</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-435"></A>bad file id; usually an unopened file</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-437"></A>EX_WRONGFILETYPE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-481"></A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-439"></A>-103</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-441"></A>wrong file type for function</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-443"></A>EX_LOOKUPFAIL</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-483"></A>EXBTID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-445"></A>-104</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-447"></A>property table lookup failed</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-449"></A>EX_BADPARAM</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-485"></A>EXBPRM</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-451"></A>-105</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-453"></A>bad parameter passed</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-455"></A>EX_MSG</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-487"></A>EXPMSG</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-457"></A>100</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-459"></A>user-defined message </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-461"></A>EX_PRTLASTMSG</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-489"></A>EXLMSG</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-463"></A>101</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-465"></A>print last error message msg code</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="50334054_pgfId-114"></A>The following are codes returned by netCDF functions.  The error names are defined constants (in <EM CLASS="code">
netcdf.h</EM>
) currently set to the specified values.  </P>
<TABLE>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="50334054_pgfId-98"></A>Error Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="50334054_pgfId-99"></A>Value</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="50334054_pgfId-100"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-108"></A>NC_NOERR</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-109"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-110"></A>No error</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-101"></A>NC_EBADID</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-102"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-103"></A>Not a netcdf id</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-104"></A>NC_ENFILE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-105"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-141"></A>Too many netcdfs open</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-142"></A>NC_EEXIST</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-143"></A>3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-144"></A>netcdf file exists &amp;&amp; NC_NOCLOBBER</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-145"></A>NC_EINVAL</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-146"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-147"></A>Invalid argument</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-148"></A>NC_EPERM</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-149"></A>5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-150"></A>Write to read only file</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-151"></A>NC_ENOTINDEFINE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-152"></A>6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-153"></A>Operation not allowed in data mode</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-154"></A>NC_EINDEFINE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-155"></A>7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-156"></A>Operation not allowed in define mode</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-157"></A>NC_EINVALCOORDS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-158"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-159"></A>Coordinates out of domain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-160"></A>NC_EMAXDIMS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-161"></A>9</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-162"></A>MAX_NC_DIMS (defined in netcdf.h) exceeded</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-163"></A>NC_ENAMEINUSE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-164"></A>10</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-165"></A>String match to name in use</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-166"></A>NC_ENOTATT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-167"></A>11</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-168"></A>Attribute not found</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-169"></A>NC_EMAXATTS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-170"></A>12</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-171"></A>MAX_NC_ATTRS (defined in netcdf.h) exceeded</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-172"></A>NC_EBADTYPE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-173"></A>13</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-174"></A>Not a netcdf data type</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-175"></A>NC_EBADDIM</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-176"></A>14</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-177"></A>Invalid dimension id</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-178"></A>NC_EUNLIMPOS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-179"></A>15</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-180"></A>NC_UNLIMITED in the wrong index</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-181"></A>NC_EMAXVARS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-182"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-183"></A>MAX_NC_VARS (defined in netcdf.h) exceeded</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-184"></A>NC_ENOTVAR</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-185"></A>17</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-186"></A>Variable not found</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-187"></A>NC_EGLOBAL</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-188"></A>18</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-189"></A>Action prohibited on NC_GLOBAL varid</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-190"></A>NC_ENOTNC</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-191"></A>19</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-192"></A>Not a netcdf file</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-193"></A>NC_ESTS</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-194"></A>20</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-195"></A>In Fortran, string too short</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-196"></A>NC_EMAXNAME</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-197"></A>21</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-198"></A>MAX_NC_NAME (defined in netcdf.h) exceeded</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-199"></A>NC_EUNLIMIT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-200"></A>22</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-201"></A>NC_UNLIMITED size already in use</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-202"></A>NC_EXDR</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-203"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-204"></A>XDR error</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-205"></A>NC_SYSERR</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-206"></A>-1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="50334054_pgfId-207"></A>Fatal system error</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="50334054_pgfId-107"></A>&nbsp;</P>
</DIV>
<DIV>
<H2 CLASS="Appendix">
<A NAME="50334055_pgfId-65"></A><DIV>
<IMG SRC="exodusII.book-26.gif">
</DIV>
Appendix D</H2>
</DIV>
<DIV>
<H2 CLASS="AppTitle">
<A NAME="50334055_pgfId-78"></A> Sample Codes</H2>
<P CLASS="Body">
<A NAME="50334055_pgfId-131"></A>This appendix contains examples of C and Fortran programs that use the EXODUS II API.</P>
<DIV>
<H4 CLASS="Heading">
<A NAME="50334055_pgfId-125"></A>C Write <A NAME="50334055_marker-58"></A>Example Code</H4>
<P CLASS="Body">
<A NAME="50334055_pgfId-2002"></A>The following is a C program that creates and populates an EXODUS II file:</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-704"></A><EM CLASS="code">
#include &lt;stdio.h&gt;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-68"></A><EM CLASS="code">
#include &quot;netcdf.h&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-69"></A><EM CLASS="code">
#include &quot;exodusII.h&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-70"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-71"></A><EM CLASS="code">
main ()</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-72"></A><EM CLASS="code">
{</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-73"></A><EM CLASS="code">
   int exoid, num_dim, num_nodes, num_elem, num_elem_blk;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-74"></A><EM CLASS="code">
   int num_elem_in_block[10], num_nodes_per_elem[10];</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-76"></A><EM CLASS="code">
   int num_node_sets, num_sides, num_side_sets, error;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-79"></A><EM CLASS="code">
   int i, j, k, m, *elem_map, *connect;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-80"></A><EM CLASS="code">
   int node_list[100],elem_list[100],side_list[100];</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-87"></A><EM CLASS="code">
   int ebids[10], ids[10];</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-88"></A><EM CLASS="code">
   int num_sides_per_set[10], num_nodes_per_set[10], num_elem_per_set[10];</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-89"></A><EM CLASS="code">
   int num_df_per_set[10];</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-90"></A><EM CLASS="code">
   int df_ind[10], node_ind[10], elem_ind[10], side_ind[10];</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-91"></A><EM CLASS="code">
   int  num_qa_rec, num_info;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-92"></A><EM CLASS="code">
   int num_glo_vars, num_nod_vars, num_ele_vars;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-93"></A><EM CLASS="code">
   int *truth_tab;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-94"></A><EM CLASS="code">
   int whole_time_step, num_time_steps;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-95"></A><EM CLASS="code">
   int ndims, nvars, ngatts, recdim;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-96"></A><EM CLASS="code">
   int CPU_word_size,IO_word_size;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-97"></A><EM CLASS="code">
   int prop_array[2];</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-98"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-99"></A><EM CLASS="code">
   float *glob_var_vals, *nodal_var_vals, *elem_var_vals;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-100"></A><EM CLASS="code">
   float time_value;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-101"></A><EM CLASS="code">
   float x[100], y[100], z[100], *dummy;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-102"></A><EM CLASS="code">
   float attrib[1], dist_fact[100];</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-103"></A><EM CLASS="code">
   char *coord_names[3], *qa_record[2][4], *info[3], *var_names[3];</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-104"></A><EM CLASS="code">
   char tmpstr[80];</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-105"></A><EM CLASS="code">
   char *prop_names[2];</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-106"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-107"></A><EM CLASS="code">
   dummy = 0; /* assign this so the Cray compiler doesn't complain */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-108"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-109"></A><EM CLASS="code">
/* Specify compute and i/o word size */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-110"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-111"></A><EM CLASS="code">
   CPU_word_size = 0;			/* float or double */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-112"></A><EM CLASS="code">
   IO_word_size = 0;			/* use system default (4 bytes) */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-113"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-114"></A><EM CLASS="code">
/* create EXODUS II file */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-115"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-116"></A><EM CLASS="code">
   exoid = ex_create (&quot;test.exo&quot;,	/* filename path */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-117"></A><EM CLASS="code">
                       EX_CLOBBER,	/* create mode */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-118"></A><EM CLASS="code">
		       &amp;CPU_word_size,	/* CPU float word size in bytes */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-119"></A><EM CLASS="code">
		       &amp;IO_word_size);	/* I/O float word size in bytes */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-120"></A><EM CLASS="code">
/* ncopts = NC_VERBOSE; */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-121"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-122"></A><EM CLASS="code">
/* initialize file with parameters */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-123"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-124"></A><EM CLASS="code">
   num_dim = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-126"></A><EM CLASS="code">
   num_nodes = 26;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-127"></A><EM CLASS="code">
   num_elem = 5;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-128"></A><EM CLASS="code">
   num_elem_blk = 5;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-129"></A><EM CLASS="code">
   num_node_sets = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-130"></A><EM CLASS="code">
   num_side_sets = 5;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-132"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-133"></A><EM CLASS="code">
   error = ex_put_init (exoid, &quot;This is a test&quot;, num_dim, num_nodes, num_elem,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-134"></A><EM CLASS="code">
                        num_elem_blk, num_node_sets, num_side_sets);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-135"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-136"></A><EM CLASS="code">
/* write nodal coordinates values and names to database */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-137"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-138"></A><EM CLASS="code">
/* Quad #1 */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-139"></A><EM CLASS="code">
   x[0] = 0.0; y[0] = 0.0; z[0] = 0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-140"></A><EM CLASS="code">
   x[1] = 1.0; y[1] = 0.0; z[1] = 0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-141"></A><EM CLASS="code">
   x[2] = 1.0; y[2] = 1.0; z[2] = 0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-142"></A><EM CLASS="code">
   x[3] = 0.0; y[3] = 1.0; z[3] = 0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-143"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-144"></A><EM CLASS="code">
/* Quad #2 */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-145"></A><EM CLASS="code">
   x[4]  =  1.0; y[4]  =  0.0; z[4]  =  0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-146"></A><EM CLASS="code">
   x[5]  =  2.0; y[5]  =  0.0; z[5]  =  0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-147"></A><EM CLASS="code">
   x[6]  =  2.0; y[6]  =  1.0; z[6]  =  0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-148"></A><EM CLASS="code">
   x[7]  =  1.0; y[7]  =  1.0; z[7]  =  0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-149"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-150"></A><EM CLASS="code">
/* Hex #1 */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-151"></A><EM CLASS="code">
   x[8]  =  0.0; y[8]  =  0.0; z[8]  =  0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-152"></A><EM CLASS="code">
   x[9]  = 10.0; y[9]  =  0.0; z[9]  =  0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-153"></A><EM CLASS="code">
   x[10] = 10.0; y[10] =  0.0; z[10] =-10.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-154"></A><EM CLASS="code">
   x[11] =  1.0; y[11] =  0.0; z[11] =-10.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-155"></A><EM CLASS="code">
   x[12] =  1.0; y[12] = 10.0; z[12] =  0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-156"></A><EM CLASS="code">
   x[13] = 10.0; y[13] = 10.0; z[13] =  0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-157"></A><EM CLASS="code">
   x[14] = 10.0; y[14] = 10.0; z[14] =-10.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-158"></A><EM CLASS="code">
   x[15] =  1.0; y[15] = 10.0; z[15] =-10.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-159"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-160"></A><EM CLASS="code">
/* Tetra #1 */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-161"></A><EM CLASS="code">
   x[16] =  0.0; y[16] =  0.0; z[16] =  0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-162"></A><EM CLASS="code">
   x[17] =  1.0; y[17] =  0.0; z[17] =  5.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-163"></A><EM CLASS="code">
   x[18] = 10.0; y[18] =  0.0; z[18] =  2.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-164"></A><EM CLASS="code">
   x[19] =  7.0; y[19] =  5.0; z[19] =  3.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-165"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-166"></A><EM CLASS="code">
/* Wedge #1 */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-167"></A><EM CLASS="code">
   x[20] =  3.0; y[20] =  0.0; z[20] =  6.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-168"></A><EM CLASS="code">
   x[21] =  6.0; y[21] =  0.0; z[21] =  0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-169"></A><EM CLASS="code">
   x[22] =  0.0; y[22] =  0.0; z[22] =  0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-170"></A><EM CLASS="code">
   x[23] =  3.0; y[23] =  2.0; z[23] =  6.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-171"></A><EM CLASS="code">
   x[24] =  6.0; y[24] =  2.0; z[24] =  2.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-172"></A><EM CLASS="code">
   x[25] =  0.0; y[25] =  2.0; z[25] =  0.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-173"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-174"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-175"></A><EM CLASS="code">
   error = ex_put_coord (exoid, x, y, z);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-176"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-177"></A><EM CLASS="code">
   coord_names[0] = &quot;xcoor&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-178"></A><EM CLASS="code">
   coord_names[1] = &quot;ycoor&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-179"></A><EM CLASS="code">
   coord_names[2] = &quot;zcoor&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-180"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-181"></A><EM CLASS="code">
   error = ex_put_coord_names (exoid, coord_names);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-182"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-183"></A><EM CLASS="code">
/* write element order map */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-184"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-185"></A><EM CLASS="code">
   elem_map = (int *) calloc(num_elem, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-186"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-187"></A><EM CLASS="code">
   for (i=1; i&lt;=num_elem; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-188"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-189"></A><EM CLASS="code">
      elem_map[i-1] = i;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-190"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-191"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-192"></A><EM CLASS="code">
   error = ex_put_map (exoid, elem_map);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-193"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-194"></A><EM CLASS="code">
   free (elem_map);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-195"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-196"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-197"></A><EM CLASS="code">
/* write element block parameters */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-198"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-199"></A><EM CLASS="code">
   num_elem_in_block[0] = 1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-200"></A><EM CLASS="code">
   num_elem_in_block[1] = 1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-201"></A><EM CLASS="code">
   num_elem_in_block[2] = 1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-202"></A><EM CLASS="code">
   num_elem_in_block[3] = 1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-203"></A><EM CLASS="code">
   num_elem_in_block[4] = 1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-204"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-205"></A><EM CLASS="code">
   num_nodes_per_elem[0] = 4; /* elements in block #1 are 4-node quads  */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-206"></A><EM CLASS="code">
   num_nodes_per_elem[1] = 4; /* elements in block #2 are 4-node quads  */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-207"></A><EM CLASS="code">
   num_nodes_per_elem[2] = 8; /* elements in block #3 are 8-node hexes  */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-208"></A><EM CLASS="code">
   num_nodes_per_elem[3] = 4; /* elements in block #3 are 4-node tetras */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-209"></A><EM CLASS="code">
   num_nodes_per_elem[4] = 6; /* elements in block #3 are 6-node wedges */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-210"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-211"></A><EM CLASS="code">
   ebids[0] = 10;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-212"></A><EM CLASS="code">
   ebids[1] = 11;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-213"></A><EM CLASS="code">
   ebids[2] = 12;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-214"></A><EM CLASS="code">
   ebids[3] = 13;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-215"></A><EM CLASS="code">
   ebids[4] = 14;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-216"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-217"></A><EM CLASS="code">
   error = ex_put_elem_block (exoid, ebids[0], &quot;QUAD&quot;, num_elem_in_block[0],</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-218"></A><EM CLASS="code">
                              num_nodes_per_elem[0], 1);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-219"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-220"></A><EM CLASS="code">
   error = ex_put_elem_block (exoid, ebids[1], &quot;QUAD&quot;, num_elem_in_block[1],</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-221"></A><EM CLASS="code">
                               num_nodes_per_elem[1], 1);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-222"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-223"></A><EM CLASS="code">
   error = ex_put_elem_block (exoid, ebids[2], &quot;HEX&quot;, num_elem_in_block[2],</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-224"></A><EM CLASS="code">
                               num_nodes_per_elem[2], 1);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-225"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-226"></A><EM CLASS="code">
   error = ex_put_elem_block (exoid, ebids[3], &quot;TETRA&quot;, num_elem_in_block[3],</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-227"></A><EM CLASS="code">
                               num_nodes_per_elem[3], 1);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-228"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-229"></A><EM CLASS="code">
   error = ex_put_elem_block (exoid, ebids[4], &quot;WEDGE&quot;, num_elem_in_block[4],</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-230"></A><EM CLASS="code">
                               num_nodes_per_elem[4], 1);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-231"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-232"></A><EM CLASS="code">
/* write element block properties */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-233"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-234"></A><EM CLASS="code">
   prop_names[0] = &quot;TOP&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-235"></A><EM CLASS="code">
   prop_names[1] = &quot;RIGHT&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-236"></A><EM CLASS="code">
   error = ex_put_prop_names(exoid,EX_ELEM_BLOCK,2,prop_names);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-237"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-238"></A><EM CLASS="code">
   error = ex_put_prop(exoid, EX_ELEM_BLOCK, ebids[0], &quot;TOP&quot;, 1);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-239"></A><EM CLASS="code">
   error = ex_put_prop(exoid, EX_ELEM_BLOCK, ebids[1], &quot;TOP&quot;, 1);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-240"></A><EM CLASS="code">
   error = ex_put_prop(exoid, EX_ELEM_BLOCK, ebids[2], &quot;RIGHT&quot;, 1);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-241"></A><EM CLASS="code">
   error = ex_put_prop(exoid, EX_ELEM_BLOCK, ebids[3], &quot;RIGHT&quot;, 1);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-242"></A><EM CLASS="code">
   error = ex_put_prop(exoid, EX_ELEM_BLOCK, ebids[4], &quot;RIGHT&quot;, 1);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-243"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-244"></A><EM CLASS="code">
/* write element connectivity */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-245"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-246"></A><EM CLASS="code">
   connect = (int *) calloc(8, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-247"></A><EM CLASS="code">
   connect[0] = 1; connect[1] = 2; connect[2] = 3; connect[3] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-248"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-249"></A><EM CLASS="code">
   error = ex_put_elem_conn (exoid, ebids[0], connect);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-250"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-251"></A><EM CLASS="code">
   connect[0] = 5; connect[1] = 6; connect[2] = 7; connect[3] = 8;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-252"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-253"></A><EM CLASS="code">
   error = ex_put_elem_conn (exoid, ebids[1], connect);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-254"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-255"></A><EM CLASS="code">
   connect[0] = 9; connect[1] = 10; connect[2] = 11; connect[3] = 12;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-256"></A><EM CLASS="code">
   connect[4] = 13; connect[5] = 14; connect[6] = 15; connect[7] = 16;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-257"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-258"></A><EM CLASS="code">
   error = ex_put_elem_conn (exoid, ebids[2], connect);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-259"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-260"></A><EM CLASS="code">
   connect[0] = 17; connect[1] = 18; connect[2] = 19; connect[3] = 20;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-261"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-262"></A><EM CLASS="code">
   error = ex_put_elem_conn (exoid, ebids[3], connect);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-263"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-264"></A><EM CLASS="code">
   connect[0] = 21; connect[1] = 22; connect[2] = 23;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-265"></A><EM CLASS="code">
   connect[3] = 24; connect[4] = 25; connect[5] = 26;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-266"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-267"></A><EM CLASS="code">
   error = ex_put_elem_conn (exoid, ebids[4], connect);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-268"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-269"></A><EM CLASS="code">
   free (connect);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-270"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-271"></A><EM CLASS="code">
/* write element block attributes */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-272"></A><EM CLASS="code">
   attrib[0] = 3.14159;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-273"></A><EM CLASS="code">
   error = ex_put_elem_attr (exoid, ebids[0], attrib);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-274"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-275"></A><EM CLASS="code">
   attrib[0] = 6.14159;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-276"></A><EM CLASS="code">
   error = ex_put_elem_attr (exoid, ebids[1], attrib);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-277"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-278"></A><EM CLASS="code">
   error = ex_put_elem_attr (exoid, ebids[2], attrib);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-279"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-280"></A><EM CLASS="code">
   error = ex_put_elem_attr (exoid, ebids[3], attrib);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-281"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-282"></A><EM CLASS="code">
   error = ex_put_elem_attr (exoid, ebids[4], attrib);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-283"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-284"></A><EM CLASS="code">
/* write individual node sets */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-285"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-286"></A><EM CLASS="code">
   error = ex_put_node_set_param (exoid, 20, 5, 5);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-287"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-288"></A><EM CLASS="code">
   node_list[0] = 100; node_list[1] = 101; node_list[2] = 102; </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-289"></A><EM CLASS="code">
   node_list[3] = 103; node_list[4] = 104; </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-290"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-291"></A><EM CLASS="code">
   dist_fact[0] = 1.0; dist_fact[1] = 2.0; dist_fact[2] = 3.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-292"></A><EM CLASS="code">
   dist_fact[3] = 4.0; dist_fact[4] = 5.0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-293"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-294"></A><EM CLASS="code">
   error = ex_put_node_set (exoid, 20, node_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-295"></A><EM CLASS="code">
   error = ex_put_node_set_dist_fact (exoid, 20, dist_fact);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-296"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-297"></A><EM CLASS="code">
   error = ex_put_node_set_param (exoid, 21, 3, 3);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-298"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-299"></A><EM CLASS="code">
   node_list[0] = 200; node_list[1] = 201; node_list[2] = 202; </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-300"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-301"></A><EM CLASS="code">
   dist_fact[0] = 1.1; dist_fact[1] = 2.1; dist_fact[2] = 3.1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-302"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-303"></A><EM CLASS="code">
   error = ex_put_node_set (exoid, 21, node_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-304"></A><EM CLASS="code">
   error = ex_put_node_set_dist_fact (exoid, 21, dist_fact);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-305"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-306"></A><EM CLASS="code">
   error = ex_put_prop(exoid, EX_NODE_SET, 20, &quot;FACE&quot;, 4);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-307"></A><EM CLASS="code">
   error = ex_put_prop(exoid, EX_NODE_SET, 21, &quot;FACE&quot;, 5);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-308"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-309"></A><EM CLASS="code">
   prop_array[0] = 1000;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-310"></A><EM CLASS="code">
   prop_array[1] = 2000;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-311"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-312"></A><EM CLASS="code">
   error = ex_put_prop_array(exoid, EX_NODE_SET, &quot;VELOCITY&quot;, prop_array);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-313"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-314"></A><EM CLASS="code">
/* write concatenated node sets; this produces the same information as</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-315"></A><EM CLASS="code">
 * the above code which writes individual node sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-316"></A><EM CLASS="code">
 */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-317"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-318"></A><EM CLASS="code">
/* THIS SECTION IS COMMENTED OUT</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-319"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-320"></A><EM CLASS="code">
   ids[0] = 20; ids[1] = 21;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-321"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-322"></A><EM CLASS="code">
   num_nodes_per_set[0] = 5; num_nodes_per_set[1] = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-323"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-324"></A><EM CLASS="code">
   node_ind[0] = 0; node_ind[1] = 5;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-325"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-326"></A><EM CLASS="code">
   node_list[0] = 100; node_list[1] = 101; node_list[2] = 102; </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-327"></A><EM CLASS="code">
   node_list[3] = 103; node_list[4] = 104; </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-328"></A><EM CLASS="code">
   node_list[5] = 200; node_list[6] = 201; node_list[7] = 202;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-329"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-330"></A><EM CLASS="code">
   num_df_per_set[0] = 5; num_df_per_set[1] = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-331"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-332"></A><EM CLASS="code">
   df_ind[0] = 0; df_ind[1] = 5;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-333"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-334"></A><EM CLASS="code">
   dist_fact[0] = 1.0; dist_fact[1] = 2.0; dist_fact[2] = 3.0; </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-335"></A><EM CLASS="code">
   dist_fact[3] = 4.0; dist_fact[4] = 5.0; </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-336"></A><EM CLASS="code">
   dist_fact[5] = 1.1; dist_fact[6] = 2.1; dist_fact[7] = 3.1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-337"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-338"></A><EM CLASS="code">
   error = ex_put_concat_node_sets (exoid, ids, num_nodes_per_set,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-339"></A><EM CLASS="code">
				    num_df_per_set, node_ind,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-340"></A><EM CLASS="code">
				    df_ind, node_list, dist_fact);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-341"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-342"></A><EM CLASS="code">
   error = ex_put_prop(exoid, EX_NODE_SET, 20, &quot;FACE&quot;, 4);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-343"></A><EM CLASS="code">
   error = ex_put_prop(exoid, EX_NODE_SET, 21, &quot;FACE&quot;, 5);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-344"></A><EM CLASS="code">
   prop_array[0] = 1000;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-345"></A><EM CLASS="code">
   prop_array[1] = 2000;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-346"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-347"></A><EM CLASS="code">
   error = ex_put_prop_array(exoid, EX_NODE_SET, &quot;VELOCITY&quot;, prop_array);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-348"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-349"></A><EM CLASS="code">
   END COMMENTED OUT SECTION */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-350"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-351"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-352"></A><EM CLASS="code">
/* write individual side sets */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-353"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-354"></A><EM CLASS="code">
   /* side set #1  - quad */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-355"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-356"></A><EM CLASS="code">
   error = ex_put_side_set_param (exoid, 30, 2, 4);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-357"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-358"></A><EM CLASS="code">
   elem_list[0] = 2; elem_list[1] = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-359"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-360"></A><EM CLASS="code">
   side_list[0] = 4; side_list[1] = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-361"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-362"></A><EM CLASS="code">
   dist_fact[0] = 30.0; dist_fact[1] = 30.1; dist_fact[2] = 30.2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-363"></A><EM CLASS="code">
   dist_fact[3] = 30.3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-364"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-365"></A><EM CLASS="code">
   error = ex_put_side_set (exoid, 30, elem_list, side_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-366"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-367"></A><EM CLASS="code">
   error = ex_put_side_set_dist_fact (exoid, 30, dist_fact);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-368"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-369"></A><EM CLASS="code">
   /* side set #2  - quad, spanning 2 elements  */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-370"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-371"></A><EM CLASS="code">
   error = ex_put_side_set_param (exoid, 31, 2, 4);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-372"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-373"></A><EM CLASS="code">
   elem_list[0] = 1; elem_list[1] = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-374"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-375"></A><EM CLASS="code">
   side_list[0] = 2; side_list[1] = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-376"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-377"></A><EM CLASS="code">
   dist_fact[0] = 31.0; dist_fact[1] = 31.1; dist_fact[2] = 31.2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-378"></A><EM CLASS="code">
   dist_fact[3] = 31.3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-379"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-380"></A><EM CLASS="code">
   error = ex_put_side_set (exoid, 31, elem_list, side_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-381"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-382"></A><EM CLASS="code">
   error = ex_put_side_set_dist_fact (exoid, 31, dist_fact);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-383"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-384"></A><EM CLASS="code">
   /* side set #3  - hex */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-385"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-386"></A><EM CLASS="code">
   error = ex_put_side_set_param (exoid, 32, 7, 0);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-387"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-388"></A><EM CLASS="code">
   elem_list[0] = 3; elem_list[1] = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-389"></A><EM CLASS="code">
   elem_list[2] = 3; elem_list[3] = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-390"></A><EM CLASS="code">
   elem_list[4] = 3; elem_list[5] = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-391"></A><EM CLASS="code">
   elem_list[6] = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-392"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-393"></A><EM CLASS="code">
   side_list[0] = 5; side_list[1] = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-394"></A><EM CLASS="code">
   side_list[2] = 3; side_list[3] = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-395"></A><EM CLASS="code">
   side_list[4] = 4; side_list[5] = 1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-396"></A><EM CLASS="code">
   side_list[6] = 6;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-397"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-398"></A><EM CLASS="code">
   error = ex_put_side_set (exoid, 32, elem_list, side_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-399"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-400"></A><EM CLASS="code">
   /* side set #4  - tetras */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-401"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-402"></A><EM CLASS="code">
   error = ex_put_side_set_param (exoid, 33, 4, 0);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-403"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-404"></A><EM CLASS="code">
   elem_list[0] = 4; elem_list[1] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-405"></A><EM CLASS="code">
   elem_list[2] = 4; elem_list[3] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-406"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-407"></A><EM CLASS="code">
   side_list[0] = 1; side_list[1] = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-408"></A><EM CLASS="code">
   side_list[2] = 3; side_list[3] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-409"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-410"></A><EM CLASS="code">
   error = ex_put_side_set (exoid, 33, elem_list, side_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-411"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-412"></A><EM CLASS="code">
   /* side set #5  - wedges */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-413"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-414"></A><EM CLASS="code">
   error = ex_put_side_set_param (exoid, 34, 5, 0);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-415"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-416"></A><EM CLASS="code">
   elem_list[0] = 5; elem_list[1] = 5;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-417"></A><EM CLASS="code">
   elem_list[2] = 5; elem_list[3] = 5;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-418"></A><EM CLASS="code">
   elem_list[4] = 5;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-419"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-420"></A><EM CLASS="code">
   side_list[0] = 1; side_list[1] = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-421"></A><EM CLASS="code">
   side_list[2] = 3; side_list[3] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-422"></A><EM CLASS="code">
   side_list[4] = 5;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-423"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-424"></A><EM CLASS="code">
   error = ex_put_side_set (exoid, 34, elem_list, side_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-425"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-426"></A><EM CLASS="code">
/* write concatenated side sets; side set node lists (which is how side sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-427"></A><EM CLASS="code">
 * were described in EXODUS I) are converted to side set side lists and then</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-428"></A><EM CLASS="code">
 * written out; this produces the same information as the above code which </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-429"></A><EM CLASS="code">
 * writes individual side sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-430"></A><EM CLASS="code">
 */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-431"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-432"></A><EM CLASS="code">
/* THIS SECTION IS COMMENTED OUT</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-433"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-434"></A><EM CLASS="code">
   ids[0] = 30;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-435"></A><EM CLASS="code">
   ids[1] = 31;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-436"></A><EM CLASS="code">
   ids[2] = 32;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-437"></A><EM CLASS="code">
   ids[3] = 33;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-438"></A><EM CLASS="code">
   ids[4] = 34;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-439"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-440"></A><EM CLASS="code">
   node_list[0] = 8; node_list[1] = 5;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-441"></A><EM CLASS="code">
   node_list[2] = 6; node_list[3] = 7;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-442"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-443"></A><EM CLASS="code">
   node_list[4] = 2; node_list[5] = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-444"></A><EM CLASS="code">
   node_list[6] = 7; node_list[7] = 8;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-445"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-446"></A><EM CLASS="code">
   node_list[8] = 9; node_list[9] = 12;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-447"></A><EM CLASS="code">
   node_list[10] = 11; node_list[11] = 10;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-448"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-449"></A><EM CLASS="code">
   node_list[12] = 11; node_list[13] = 12;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-450"></A><EM CLASS="code">
   node_list[14] = 16; node_list[15] = 15;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-451"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-452"></A><EM CLASS="code">
   node_list[16] = 16; node_list[17] = 15;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-453"></A><EM CLASS="code">
   node_list[18] = 11; node_list[19] = 12;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-454"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-455"></A><EM CLASS="code">
   node_list[20] = 10; node_list[21] = 11;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-456"></A><EM CLASS="code">
   node_list[22] = 15; node_list[23] = 14;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-457"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-458"></A><EM CLASS="code">
   node_list[24] = 13; node_list[25] = 16;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-459"></A><EM CLASS="code">
   node_list[26] = 12; node_list[27] =  9;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-460"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-461"></A><EM CLASS="code">
   node_list[28] = 14; node_list[29] = 13;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-462"></A><EM CLASS="code">
   node_list[30] =  9; node_list[31] = 10;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-463"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-464"></A><EM CLASS="code">
   node_list[32] = 16; node_list[33] = 13;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-465"></A><EM CLASS="code">
   node_list[34] = 14; node_list[35] = 15;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-466"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-467"></A><EM CLASS="code">
   node_list[36] = 17; node_list[37] = 18;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-468"></A><EM CLASS="code">
   node_list[38] = 20;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-469"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-470"></A><EM CLASS="code">
   node_list[39] = 18; node_list[40] = 19;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-471"></A><EM CLASS="code">
   node_list[41] = 20;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-472"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-473"></A><EM CLASS="code">
   node_list[42] = 20; node_list[43] = 19;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-474"></A><EM CLASS="code">
   node_list[44] = 17;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-475"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-476"></A><EM CLASS="code">
   node_list[45] = 19; node_list[46] = 18;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-477"></A><EM CLASS="code">
   node_list[47] = 17;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-478"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-479"></A><EM CLASS="code">
   node_list[48] = 25; node_list[49] = 24;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-480"></A><EM CLASS="code">
   node_list[50] = 21; node_list[51] = 22;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-481"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-482"></A><EM CLASS="code">
   node_list[52] = 26; node_list[53] = 25;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-483"></A><EM CLASS="code">
   node_list[54] = 22; node_list[55] = 23;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-484"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-485"></A><EM CLASS="code">
   node_list[56] = 26; node_list[57] = 23;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-486"></A><EM CLASS="code">
   node_list[58] = 21; node_list[59] = 24;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-487"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-488"></A><EM CLASS="code">
   node_list[60] = 23; node_list[61] = 22;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-489"></A><EM CLASS="code">
   node_list[62] = 21;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-490"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-491"></A><EM CLASS="code">
   node_list[63] = 24; node_list[64] = 25;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-492"></A><EM CLASS="code">
   node_list[65] = 26;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-493"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-494"></A><EM CLASS="code">
   node_ind[0] = 0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-495"></A><EM CLASS="code">
   node_ind[1] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-496"></A><EM CLASS="code">
   node_ind[2] = 8;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-497"></A><EM CLASS="code">
   node_ind[3] = 36;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-498"></A><EM CLASS="code">
   node_ind[4] = 47;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-499"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-500"></A><EM CLASS="code">
   num_elem_per_set[0] = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-501"></A><EM CLASS="code">
   num_elem_per_set[1] = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-502"></A><EM CLASS="code">
   num_elem_per_set[2] = 7;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-503"></A><EM CLASS="code">
   num_elem_per_set[3] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-504"></A><EM CLASS="code">
   num_elem_per_set[4] = 5;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-505"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-506"></A><EM CLASS="code">
   num_nodes_per_set[0] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-507"></A><EM CLASS="code">
   num_nodes_per_set[1] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-508"></A><EM CLASS="code">
   num_nodes_per_set[2] = 28;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-509"></A><EM CLASS="code">
   num_nodes_per_set[3] = 12;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-510"></A><EM CLASS="code">
   num_nodes_per_set[4] = 18;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-511"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-512"></A><EM CLASS="code">
   elem_ind[0] = 0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-513"></A><EM CLASS="code">
   elem_ind[1] = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-514"></A><EM CLASS="code">
   elem_ind[2] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-515"></A><EM CLASS="code">
   elem_ind[3] = 11;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-516"></A><EM CLASS="code">
   elem_ind[4] = 15;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-517"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-518"></A><EM CLASS="code">
   elem_list[0] = 2; elem_list[1] = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-519"></A><EM CLASS="code">
   elem_list[2] = 1; elem_list[3] = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-520"></A><EM CLASS="code">
   elem_list[4] = 3; elem_list[5] = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-521"></A><EM CLASS="code">
   elem_list[6] = 3; elem_list[7] = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-522"></A><EM CLASS="code">
   elem_list[8] = 3; elem_list[9] = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-523"></A><EM CLASS="code">
   elem_list[10] = 3; elem_list[11] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-524"></A><EM CLASS="code">
   elem_list[12] = 4; elem_list[13] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-525"></A><EM CLASS="code">
   elem_list[14] = 4; elem_list[15] = 5;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-526"></A><EM CLASS="code">
   elem_list[16] = 5; elem_list[17] = 5;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-527"></A><EM CLASS="code">
   elem_list[18] = 5; elem_list[19] = 5;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-528"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-529"></A><EM CLASS="code">
   error = ex_cvt_nodes_to_sides(exoid,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-530"></A><EM CLASS="code">
                         num_elem_per_set,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-531"></A><EM CLASS="code">
                         num_nodes_per_set,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-532"></A><EM CLASS="code">
                         elem_ind,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-533"></A><EM CLASS="code">
                         node_ind,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-534"></A><EM CLASS="code">
                         elem_list,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-535"></A><EM CLASS="code">
                         node_list,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-536"></A><EM CLASS="code">
                         side_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-537"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-538"></A><EM CLASS="code">
   num_df_per_set[0] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-539"></A><EM CLASS="code">
   num_df_per_set[1] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-540"></A><EM CLASS="code">
   num_df_per_set[2] = 0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-541"></A><EM CLASS="code">
   num_df_per_set[3] = 0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-542"></A><EM CLASS="code">
   num_df_per_set[4] = 0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-543"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-544"></A><EM CLASS="code">
   df_ind[0] = 0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-545"></A><EM CLASS="code">
   df_ind[1] = 4;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-546"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-547"></A><EM CLASS="code">
   dist_fact[0] = 30.0; dist_fact[1] = 30.1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-548"></A><EM CLASS="code">
   dist_fact[2] = 30.2; dist_fact[3] = 30.3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-549"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-550"></A><EM CLASS="code">
   dist_fact[4] = 31.0; dist_fact[5] = 31.1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-551"></A><EM CLASS="code">
   dist_fact[6] = 31.2; dist_fact[7] = 31.3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-552"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-553"></A><EM CLASS="code">
   error = ex_put_concat_side_sets (exoid, ids, num_elem_per_set,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-554"></A><EM CLASS="code">
				    num_df_per_set, elem_ind, df_ind,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-555"></A><EM CLASS="code">
				    elem_list, side_list, dist_fact);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-556"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-557"></A><EM CLASS="code">
   END COMMENTED OUT SECTION */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-558"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-559"></A><EM CLASS="code">
   error = ex_put_prop(exoid, EX_SIDE_SET, 30, &quot;COLOR&quot;, 100);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-560"></A><EM CLASS="code">
   error = ex_put_prop(exoid, EX_SIDE_SET, 31, &quot;COLOR&quot;, 101);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-561"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-562"></A><EM CLASS="code">
/* write QA records */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-563"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-564"></A><EM CLASS="code">
   num_qa_rec = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-565"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-566"></A><EM CLASS="code">
   qa_record[0][0] = &quot;TESTWT&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-567"></A><EM CLASS="code">
   qa_record[0][1] = &quot;testwt&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-568"></A><EM CLASS="code">
   qa_record[0][2] = &quot;07/07/93&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-569"></A><EM CLASS="code">
   qa_record[0][3] = &quot;15:41:33&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-570"></A><EM CLASS="code">
   qa_record[1][0] = &quot;FASTQ&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-571"></A><EM CLASS="code">
   qa_record[1][1] = &quot;fastq&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-572"></A><EM CLASS="code">
   qa_record[1][2] = &quot;07/07/93&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-573"></A><EM CLASS="code">
   qa_record[1][3] = &quot;16:41:33&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-574"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-575"></A><EM CLASS="code">
   error = ex_put_qa (exoid, num_qa_rec, qa_record);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-576"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-577"></A><EM CLASS="code">
/* write information records */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-578"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-579"></A><EM CLASS="code">
   num_info = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-580"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-581"></A><EM CLASS="code">
   info[0] = &quot;This is the first information record.&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-582"></A><EM CLASS="code">
   info[1] = &quot;This is the second information record.&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-583"></A><EM CLASS="code">
   info[2] = &quot;This is the third information record.&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-584"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-585"></A><EM CLASS="code">
   error = ex_put_info (exoid, num_info, info);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-586"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-587"></A><EM CLASS="code">
/* write results variables parameters and names */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-588"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-589"></A><EM CLASS="code">
   num_glo_vars = 1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-590"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-591"></A><EM CLASS="code">
   var_names[0] = &quot;glo_vars&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-592"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-593"></A><EM CLASS="code">
   error = ex_put_var_param (exoid, &quot;g&quot;, num_glo_vars);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-594"></A><EM CLASS="code">
   error = ex_put_var_names (exoid, &quot;g&quot;, num_glo_vars, var_names);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-595"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-596"></A><EM CLASS="code">
   num_nod_vars = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-597"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-598"></A><EM CLASS="code">
   var_names[0] = &quot;nod_var0&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-599"></A><EM CLASS="code">
   var_names[1] = &quot;nod_var1&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-600"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-601"></A><EM CLASS="code">
   error = ex_put_var_param (exoid, &quot;n&quot;, num_nod_vars);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-602"></A><EM CLASS="code">
   error = ex_put_var_names (exoid, &quot;n&quot;, num_nod_vars, var_names);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-603"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-604"></A><EM CLASS="code">
   num_ele_vars = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-605"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-606"></A><EM CLASS="code">
   var_names[0] = &quot;ele_var0&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-607"></A><EM CLASS="code">
   var_names[1] = &quot;ele_var1&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-608"></A><EM CLASS="code">
   var_names[2] = &quot;ele_var2&quot;;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-609"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-610"></A><EM CLASS="code">
   error = ex_put_var_param (exoid, &quot;e&quot;, num_ele_vars);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-611"></A><EM CLASS="code">
   error = ex_put_var_names (exoid, &quot;e&quot;, num_ele_vars, var_names);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-612"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-613"></A><EM CLASS="code">
/* write element variable truth table */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-614"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-615"></A><EM CLASS="code">
   truth_tab = (int *) calloc ((num_elem_blk*num_ele_vars), sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-616"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-617"></A><EM CLASS="code">
   k = 0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-618"></A><EM CLASS="code">
   for (i=0; i&lt;num_elem_blk; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-619"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-620"></A><EM CLASS="code">
      for (j=0; j&lt;num_ele_vars; j++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-621"></A><EM CLASS="code">
      {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-622"></A><EM CLASS="code">
         truth_tab[k++] = 1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-623"></A><EM CLASS="code">
      }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-624"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-625"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-626"></A><EM CLASS="code">
   error = ex_put_elem_var_tab (exoid, num_elem_blk, num_ele_vars, truth_tab);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-627"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-628"></A><EM CLASS="code">
   free (truth_tab);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-629"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-630"></A><EM CLASS="code">
/* for each time step, write the analysis results;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-631"></A><EM CLASS="code">
 * the code below fills the arrays glob_var_vals, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-632"></A><EM CLASS="code">
 * nodal_var_vals, and elem_var_vals with values for debugging purposes;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-633"></A><EM CLASS="code">
 * obviously the analysis code will populate these arrays</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-634"></A><EM CLASS="code">
 */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-635"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-636"></A><EM CLASS="code">
   whole_time_step = 1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-637"></A><EM CLASS="code">
   num_time_steps = 10;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-638"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-639"></A><EM CLASS="code">
   glob_var_vals = (float *) calloc (num_glo_vars, CPU_word_size);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-640"></A><EM CLASS="code">
   nodal_var_vals = (float *) calloc (num_nodes, CPU_word_size);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-641"></A><EM CLASS="code">
   elem_var_vals = (float *) calloc (4, CPU_word_size);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-642"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-643"></A><EM CLASS="code">
   for (i=0; i&lt;num_time_steps; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-644"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-645"></A><EM CLASS="code">
     time_value = (float)(i+1)/100.;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-646"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-647"></A><EM CLASS="code">
/* write time value */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-648"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-649"></A><EM CLASS="code">
     error = ex_put_time (exoid, whole_time_step, &amp;time_value);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-650"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-651"></A><EM CLASS="code">
/* write global variables */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-652"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-653"></A><EM CLASS="code">
     for (j=0; j&lt;num_glo_vars; j++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-654"></A><EM CLASS="code">
     {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-655"></A><EM CLASS="code">
       glob_var_vals[j] = (float)(j+2) * time_value;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-656"></A><EM CLASS="code">
     }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-657"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-658"></A><EM CLASS="code">
     error = ex_put_glob_vars (exoid, whole_time_step, num_glo_vars, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-659"></A><EM CLASS="code">
                               glob_var_vals);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-660"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-661"></A><EM CLASS="code">
/* write nodal variables */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-662"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-663"></A><EM CLASS="code">
     for (k=1; k&lt;=num_nod_vars; k++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-664"></A><EM CLASS="code">
     {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-665"></A><EM CLASS="code">
       for (j=0; j&lt;num_nodes; j++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-666"></A><EM CLASS="code">
       {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-667"></A><EM CLASS="code">
         nodal_var_vals[j] = (float)k + ((float)(j+1) * time_value);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-668"></A><EM CLASS="code">
       }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-669"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-670"></A><EM CLASS="code">
       error = ex_put_nodal_var (exoid, whole_time_step, k, num_nodes,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-671"></A><EM CLASS="code">
                                 nodal_var_vals);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-672"></A><EM CLASS="code">
     }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-673"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-674"></A><EM CLASS="code">
/* write element variables */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-675"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-676"></A><EM CLASS="code">
     for (k=1; k&lt;=num_ele_vars; k++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-677"></A><EM CLASS="code">
     {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-678"></A><EM CLASS="code">
       for (j=0; j&lt;num_elem_blk; j++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-679"></A><EM CLASS="code">
       {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-680"></A><EM CLASS="code">
         for (m=0; m&lt;num_elem_in_block[j]; m++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-681"></A><EM CLASS="code">
         {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-682"></A><EM CLASS="code">
           elem_var_vals[m] = (float)(k+1) + (float)(j+2) + </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-683"></A><EM CLASS="code">
                              ((float)(m+1)*time_value);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-684"></A><EM CLASS="code">
         }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-685"></A><EM CLASS="code">
         error = ex_put_elem_var (exoid, whole_time_step, k, ebids[j],</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-686"></A><EM CLASS="code">
                                  num_elem_in_block[j], elem_var_vals);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-687"></A><EM CLASS="code">
       }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-688"></A><EM CLASS="code">
     }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-689"></A><EM CLASS="code">
     whole_time_step++;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-690"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-691"></A><EM CLASS="code">
/* update the data file; this should be done at the end of every time step</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-692"></A><EM CLASS="code">
 * to ensure that no data is lost if the analysis dies</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-693"></A><EM CLASS="code">
 */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-694"></A><EM CLASS="code">
     error = ex_update (exoid);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-695"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-696"></A><EM CLASS="code">
   free(glob_var_vals);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-697"></A><EM CLASS="code">
   free(nodal_var_vals);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-698"></A><EM CLASS="code">
   free(elem_var_vals);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-699"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-700"></A><EM CLASS="code">
/* close the EXODUS files</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-701"></A><EM CLASS="code">
 */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-702"></A><EM CLASS="code">
   error = ex_close (exoid);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-703"></A><EM CLASS="code">
}</EM>
</P>
</DIV>
<DIV>
<H4 CLASS="Heading">
<A NAME="50334055_pgfId-705"></A>C Read <A NAME="50334055_marker-59"></A>Example Code</H4>
<P CLASS="Body">
<A NAME="50334055_pgfId-2001"></A>The following C program reads data from an EXODUS II file:</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-706"></A><EM CLASS="code">
#include &lt;stdio.h&gt;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-707"></A><EM CLASS="code">
#include &quot;netcdf.h&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-708"></A><EM CLASS="code">
#include &quot;exodusII.h&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-709"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-710"></A><EM CLASS="code">
main ()</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-711"></A><EM CLASS="code">
{</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-712"></A><EM CLASS="code">
   int exoid, num_dim, num_nodes, num_elem, num_elem_blk, num_node_sets;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-713"></A><EM CLASS="code">
   int num_side_sets, error;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-714"></A><EM CLASS="code">
   int i, j, k, m, node_ctr;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-715"></A><EM CLASS="code">
   int *elem_map, *connect, *node_list, *node_ctr_list, *elem_list, *side_list;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-716"></A><EM CLASS="code">
   int *ids; </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-717"></A><EM CLASS="code">
   int *num_sides_per_set, *num_nodes_per_set, *num_elem_per_set;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-718"></A><EM CLASS="code">
   int *num_df_per_set;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-719"></A><EM CLASS="code">
   int *node_ind, *elem_ind, *df_ind, *side_ind, num_qa_rec, num_info;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-720"></A><EM CLASS="code">
   int num_glo_vars, num_nod_vars, num_ele_vars;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-721"></A><EM CLASS="code">
   int *truth_tab;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-722"></A><EM CLASS="code">
   int whole_time_step, num_time_steps;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-723"></A><EM CLASS="code">
   int id, *num_elem_in_block, *num_nodes_per_elem, *num_attr;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-724"></A><EM CLASS="code">
   int num_nodes_in_set, num_elem_in_set;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-725"></A><EM CLASS="code">
   int num_sides_in_set, num_df_in_set;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-726"></A><EM CLASS="code">
   int list_len, elem_list_len, node_list_len, side_list_len, df_list_len;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-727"></A><EM CLASS="code">
   int node_num, time_step, var_index, beg_time, end_time, elem_num;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-728"></A><EM CLASS="code">
   int CPU_word_size,IO_word_size;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-729"></A><EM CLASS="code">
   int prop_array[2], num_props, prop_value, *prop_values;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-730"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-731"></A><EM CLASS="code">
   float *glob_var_vals, *nodal_var_vals, *elem_var_vals;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-732"></A><EM CLASS="code">
   float time_value, *time_values, *var_values;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-733"></A><EM CLASS="code">
   float *x, *y, *z, *dummy;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-734"></A><EM CLASS="code">
   float attrib[1], *dist_fact;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-735"></A><EM CLASS="code">
   float version, fdum;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-736"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-737"></A><EM CLASS="code">
   char *coord_names[3], *qa_record[2][4], *info[3], *var_names[3];</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-738"></A><EM CLASS="code">
   char title[MAX_LINE_LENGTH+1], elem_type[MAX_STR_LENGTH+1];</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-739"></A><EM CLASS="code">
   char *cdum;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-740"></A><EM CLASS="code">
   char *prop_names[3];</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-741"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-742"></A><EM CLASS="code">
   dummy = 0; /* assign this so the Cray compiler doesn't complain */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-743"></A><EM CLASS="code">
   cdum = 0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-744"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-745"></A><EM CLASS="code">
   CPU_word_size = 0;			/* float or double */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-746"></A><EM CLASS="code">
   IO_word_size = 0;			/* use what is stored in file */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-747"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-748"></A><EM CLASS="code">
/* open EXODUS II files */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-749"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-750"></A><EM CLASS="code">
   exoid = ex_open (&quot;test.exo&quot;, 	/* filename path */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-751"></A><EM CLASS="code">
                     EX_READ, 		/* access mode = READ */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-752"></A><EM CLASS="code">
                     &amp;CPU_word_size,	/* CPU word size */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-753"></A><EM CLASS="code">
                     &amp;IO_word_size,	/* IO word size */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-754"></A><EM CLASS="code">
                     &amp;version);		/* ExodusII library version */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-755"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-756"></A><EM CLASS="code">
   if (exoid &lt; 0) exit(1);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-757"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-758"></A><EM CLASS="code">
/* ncopts = NC_VERBOSE; */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-759"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-760"></A><EM CLASS="code">
/* read database parameters */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-761"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-762"></A><EM CLASS="code">
   error = ex_get_init (exoid, title, &amp;num_dim, &amp;num_nodes, &amp;num_elem,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-763"></A><EM CLASS="code">
                        &amp;num_elem_blk, &amp;num_node_sets, &amp;num_side_sets);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-764"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-765"></A><EM CLASS="code">
/* read nodal coordinates values and names from database */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-766"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-767"></A><EM CLASS="code">
   x = (float *) calloc(num_nodes, sizeof(float));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-768"></A><EM CLASS="code">
   y = (float *) calloc(num_nodes, sizeof(float));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-769"></A><EM CLASS="code">
   if (num_dim &gt;= 3)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-770"></A><EM CLASS="code">
     z = (float *) calloc(num_nodes, sizeof(float));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-771"></A><EM CLASS="code">
   else</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-772"></A><EM CLASS="code">
     z = 0;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-773"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-774"></A><EM CLASS="code">
   error = ex_get_coord (exoid, x, y, z);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-775"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-776"></A><EM CLASS="code">
   free (x);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-777"></A><EM CLASS="code">
   free (y);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-778"></A><EM CLASS="code">
   if (num_dim &gt;= 3)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-779"></A><EM CLASS="code">
     free (z);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-780"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-781"></A><EM CLASS="code">
   for (i=0; i&lt;num_dim; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-782"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-783"></A><EM CLASS="code">
      coord_names[i] = (char *) calloc ((MAX_STR_LENGTH+1), sizeof(char));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-784"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-785"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-786"></A><EM CLASS="code">
   error = ex_get_coord_names (exoid, coord_names);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-787"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-788"></A><EM CLASS="code">
   for (i=0; i&lt;num_dim; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-789"></A><EM CLASS="code">
     free(coord_names[i]);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-790"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-791"></A><EM CLASS="code">
/* read element order map */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-792"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-793"></A><EM CLASS="code">
   elem_map = (int *) calloc(num_elem, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-794"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-795"></A><EM CLASS="code">
   error = ex_get_map (exoid, elem_map);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-796"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-797"></A><EM CLASS="code">
   free (elem_map);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-798"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-799"></A><EM CLASS="code">
/* read element block parameters */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-800"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-801"></A><EM CLASS="code">
   ids = (int *) calloc(num_elem_blk, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-802"></A><EM CLASS="code">
   num_elem_in_block = (int *) calloc(num_elem_blk, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-803"></A><EM CLASS="code">
   num_nodes_per_elem = (int *) calloc(num_elem_blk, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-804"></A><EM CLASS="code">
   num_attr = (int *) calloc(num_elem_blk, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-805"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-806"></A><EM CLASS="code">
   error = ex_get_elem_blk_ids (exoid, ids);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-807"></A><EM CLASS="code">
   </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-808"></A><EM CLASS="code">
   for (i=0; i&lt;num_elem_blk; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-809"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-810"></A><EM CLASS="code">
     error = ex_get_elem_block (exoid, ids[i], elem_type,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-811"></A><EM CLASS="code">
                                &amp;(num_elem_in_block[i]), </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-812"></A><EM CLASS="code">
                                &amp;(num_nodes_per_elem[i]), &amp;(num_attr[i]));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-813"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-814"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-815"></A><EM CLASS="code">
   /* read element block properties */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-816"></A><EM CLASS="code">
   error = ex_inquire (exoid, EX_INQ_EB_PROP, &amp;num_props, &amp;fdum, cdum);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-817"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-818"></A><EM CLASS="code">
   for (i=0; i&lt;num_props; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-819"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-820"></A><EM CLASS="code">
      prop_names[i] = (char *) calloc ((MAX_VAR_NAME_LENGTH+1), sizeof(char));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-821"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-822"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-823"></A><EM CLASS="code">
   error = ex_get_prop_names(exoid,EX_ELEM_BLOCK,prop_names);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-824"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-825"></A><EM CLASS="code">
   for (i=0; i&lt;num_props; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-826"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-827"></A><EM CLASS="code">
     for (j=0; j&lt;num_elem_blk; j++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-828"></A><EM CLASS="code">
     {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-829"></A><EM CLASS="code">
       error = ex_get_prop(exoid, EX_ELEM_BLOCK, ids[j], prop_names[i],</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-830"></A><EM CLASS="code">
                           &amp;prop_value);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-831"></A><EM CLASS="code">
     }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-832"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-833"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-834"></A><EM CLASS="code">
   for (i=0; i&lt;num_props; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-835"></A><EM CLASS="code">
     free(prop_names[i]);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-836"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-837"></A><EM CLASS="code">
/* read element connectivity */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-838"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-839"></A><EM CLASS="code">
   for (i=0; i&lt;num_elem_blk; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-840"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-841"></A><EM CLASS="code">
      connect = (int *) calloc((num_nodes_per_elem[i] * num_elem_in_block[i]), </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-842"></A><EM CLASS="code">
                                sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-843"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-844"></A><EM CLASS="code">
      error = ex_get_elem_conn (exoid, ids[i], connect);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-845"></A><EM CLASS="code">
      free (connect);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-846"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-847"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-848"></A><EM CLASS="code">
/* read element block attributes */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-849"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-850"></A><EM CLASS="code">
   for (i=0; i&lt;num_elem_blk; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-851"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-852"></A><EM CLASS="code">
      error = ex_get_elem_attr (exoid, ids[i], attrib);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-853"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-854"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-855"></A><EM CLASS="code">
   free (ids);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-856"></A><EM CLASS="code">
   free (num_nodes_per_elem);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-857"></A><EM CLASS="code">
   free (num_attr);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-858"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-859"></A><EM CLASS="code">
/* read individual node sets */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-860"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-861"></A><EM CLASS="code">
   ids = (int *) calloc(num_node_sets, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-862"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-863"></A><EM CLASS="code">
   error = ex_get_node_set_ids (exoid, ids);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-864"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-865"></A><EM CLASS="code">
   for (i=0; i&lt;num_node_sets; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-866"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-867"></A><EM CLASS="code">
      error = ex_get_node_set_param (exoid, ids[i], </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-868"></A><EM CLASS="code">
					&amp;num_nodes_in_set, &amp;num_df_in_set);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-869"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-870"></A><EM CLASS="code">
      node_list = (int *) calloc(num_nodes_in_set, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-871"></A><EM CLASS="code">
      dist_fact = (float *) calloc(num_nodes_in_set, sizeof(float));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-872"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-873"></A><EM CLASS="code">
      error = ex_get_node_set (exoid, ids[i], node_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-874"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-875"></A><EM CLASS="code">
      if (num_df_in_set &gt; 0)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-876"></A><EM CLASS="code">
      {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-877"></A><EM CLASS="code">
        error = ex_get_node_set_dist_fact (exoid, ids[i], dist_fact);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-878"></A><EM CLASS="code">
      }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-879"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-880"></A><EM CLASS="code">
      free (node_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-881"></A><EM CLASS="code">
      free (dist_fact);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-882"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-883"></A><EM CLASS="code">
   free(ids);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-884"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-885"></A><EM CLASS="code">
   /* read node set properties */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-886"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-887"></A><EM CLASS="code">
   error = ex_inquire (exoid, EX_INQ_NS_PROP, &amp;num_props, &amp;fdum, cdum);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-888"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-889"></A><EM CLASS="code">
   for (i=0; i&lt;num_props; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-890"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-891"></A><EM CLASS="code">
      prop_names[i] = (char *) calloc ((MAX_VAR_NAME_LENGTH+1), sizeof(char));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-892"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-893"></A><EM CLASS="code">
   prop_values = (int *) calloc (num_node_sets, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-894"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-895"></A><EM CLASS="code">
   error = ex_get_prop_names(exoid,EX_NODE_SET,prop_names);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-896"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-897"></A><EM CLASS="code">
   for (i=0; i&lt;num_props; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-898"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-899"></A><EM CLASS="code">
     error = ex_get_prop_array(exoid, EX_NODE_SET, prop_names[i],</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-900"></A><EM CLASS="code">
                         prop_values);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-901"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-902"></A><EM CLASS="code">
   for (i=0; i&lt;num_props; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-903"></A><EM CLASS="code">
     free(prop_names[i]);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-904"></A><EM CLASS="code">
   free(prop_values);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-905"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-906"></A><EM CLASS="code">
/* read concatenated node sets; this produces the same information as</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-907"></A><EM CLASS="code">
 * the above code which reads individual node sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-908"></A><EM CLASS="code">
 */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-909"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-910"></A><EM CLASS="code">
   error = ex_inquire (exoid, EX_INQ_NODE_SETS, &amp;num_node_sets, &amp;fdum, cdum);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-911"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-912"></A><EM CLASS="code">
   ids = (int *) calloc(num_node_sets, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-913"></A><EM CLASS="code">
   num_nodes_per_set = (int *) calloc(num_node_sets, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-914"></A><EM CLASS="code">
   num_df_per_set = (int *) calloc(num_node_sets, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-915"></A><EM CLASS="code">
   node_ind = (int *) calloc(num_node_sets, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-916"></A><EM CLASS="code">
   df_ind = (int *) calloc(num_node_sets, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-917"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-918"></A><EM CLASS="code">
   error = ex_inquire (exoid, EX_INQ_NS_NODE_LEN, &amp;list_len, &amp;fdum, cdum);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-919"></A><EM CLASS="code">
   node_list = (int *) calloc(list_len, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-920"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-921"></A><EM CLASS="code">
   error = ex_inquire (exoid, EX_INQ_NS_DF_LEN, &amp;list_len, &amp;fdum, cdum);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-922"></A><EM CLASS="code">
   dist_fact = (float *) calloc(list_len, sizeof(float));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-923"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-924"></A><EM CLASS="code">
   error = ex_get_concat_node_sets (exoid,ids,num_nodes_per_set,num_df_per_set,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-925"></A><EM CLASS="code">
                                    node_ind, df_ind, node_list, dist_fact);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-926"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-927"></A><EM CLASS="code">
   free (ids);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-928"></A><EM CLASS="code">
   free (num_nodes_per_set);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-929"></A><EM CLASS="code">
   free (df_ind);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-930"></A><EM CLASS="code">
   free (node_ind);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-931"></A><EM CLASS="code">
   free (num_df_per_set);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-932"></A><EM CLASS="code">
   free (node_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-933"></A><EM CLASS="code">
   free (dist_fact);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-934"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-935"></A><EM CLASS="code">
/* read individual side sets */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-936"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-937"></A><EM CLASS="code">
   ids = (int *) calloc(num_side_sets, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-938"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-939"></A><EM CLASS="code">
   error = ex_get_side_set_ids (exoid, ids);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-940"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-941"></A><EM CLASS="code">
   for (i=0; i&lt;num_side_sets; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-942"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-943"></A><EM CLASS="code">
      error = ex_get_side_set_param (exoid, ids[i], &amp;num_sides_in_set, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-944"></A><EM CLASS="code">
                                     &amp;num_df_in_set);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-945"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-946"></A><EM CLASS="code">
      /* Note: The # of elements is same as # of sides!  */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-947"></A><EM CLASS="code">
      num_elem_in_set = num_sides_in_set;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-948"></A><EM CLASS="code">
      elem_list = (int *) calloc(num_elem_in_set, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-949"></A><EM CLASS="code">
      side_list = (int *) calloc(num_sides_in_set, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-950"></A><EM CLASS="code">
      node_ctr_list = (int *) calloc(num_elem_in_set, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-951"></A><EM CLASS="code">
      node_list = (int *) calloc(num_elem_in_set*21, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-952"></A><EM CLASS="code">
      dist_fact = (float *) calloc(num_df_in_set, sizeof(float));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-953"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-954"></A><EM CLASS="code">
      error = ex_get_side_set (exoid, ids[i], elem_list, side_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-955"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-956"></A><EM CLASS="code">
      error = ex_get_side_set_node_list (exoid, ids[i], node_ctr_list,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-957"></A><EM CLASS="code">
                                         node_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-958"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-959"></A><EM CLASS="code">
      if (num_df_in_set &gt; 0)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-960"></A><EM CLASS="code">
      {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-961"></A><EM CLASS="code">
        error = ex_get_side_set_dist_fact (exoid, ids[i], dist_fact);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-962"></A><EM CLASS="code">
      }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-963"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-964"></A><EM CLASS="code">
      free (elem_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-965"></A><EM CLASS="code">
      free (side_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-966"></A><EM CLASS="code">
      free (node_ctr_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-967"></A><EM CLASS="code">
      free (node_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-968"></A><EM CLASS="code">
      free (dist_fact);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-969"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-970"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-971"></A><EM CLASS="code">
   /* read side set properties */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-972"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-973"></A><EM CLASS="code">
   error = ex_inquire (exoid, EX_INQ_SS_PROP, &amp;num_props, &amp;fdum, cdum);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-974"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-975"></A><EM CLASS="code">
   for (i=0; i&lt;num_props; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-976"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-977"></A><EM CLASS="code">
      prop_names[i] = (char *) calloc ((MAX_VAR_NAME_LENGTH+1), sizeof(char));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-978"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-979"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-980"></A><EM CLASS="code">
   error = ex_get_prop_names(exoid,EX_SIDE_SET,prop_names);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-981"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-982"></A><EM CLASS="code">
   for (i=0; i&lt;num_props; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-983"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-984"></A><EM CLASS="code">
     for (j=0; j&lt;num_side_sets; j++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-985"></A><EM CLASS="code">
     {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-986"></A><EM CLASS="code">
       error = ex_get_prop(exoid, EX_SIDE_SET, ids[j], prop_names[i],</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-987"></A><EM CLASS="code">
                           &amp;prop_value);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-988"></A><EM CLASS="code">
     }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-989"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-990"></A><EM CLASS="code">
   for (i=0; i&lt;num_props; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-991"></A><EM CLASS="code">
     free(prop_names[i]);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-992"></A><EM CLASS="code">
   free (ids);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-993"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-994"></A><EM CLASS="code">
   error = ex_inquire (exoid, EX_INQ_SIDE_SETS, &amp;num_side_sets, &amp;fdum, cdum);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-995"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-996"></A><EM CLASS="code">
   if (num_side_sets &gt; 0)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-997"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-998"></A><EM CLASS="code">
     error = ex_inquire(exoid, EX_INQ_SS_ELEM_LEN, &amp;elem_list_len, &amp;fdum, cdum);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-999"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1000"></A><EM CLASS="code">
     error = ex_inquire(exoid, EX_INQ_SS_NODE_LEN, &amp;node_list_len, &amp;fdum, cdum);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1001"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1002"></A><EM CLASS="code">
     error = ex_inquire(exoid, EX_INQ_SS_DF_LEN, &amp;df_list_len, &amp;fdum, cdum);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1003"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1004"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1005"></A><EM CLASS="code">
/* read concatenated side sets; this produces the same information as</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1006"></A><EM CLASS="code">
 * the above code which reads individual side sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1007"></A><EM CLASS="code">
 */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1008"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1009"></A><EM CLASS="code">
/* concatenated side set read */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1010"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1011"></A><EM CLASS="code">
   ids = (int *) calloc(num_side_sets, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1012"></A><EM CLASS="code">
   num_elem_per_set = (int *) calloc(num_side_sets, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1013"></A><EM CLASS="code">
   num_df_per_set = (int *) calloc(num_side_sets, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1014"></A><EM CLASS="code">
   elem_ind = (int *) calloc(num_side_sets, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1015"></A><EM CLASS="code">
   df_ind = (int *) calloc(num_side_sets, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1016"></A><EM CLASS="code">
   elem_list = (int *) calloc(elem_list_len, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1017"></A><EM CLASS="code">
   side_list = (int *) calloc(elem_list_len, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1018"></A><EM CLASS="code">
   dist_fact = (float *) calloc(df_list_len, sizeof(float));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1019"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1020"></A><EM CLASS="code">
   error = ex_get_concat_side_sets (exoid, ids, num_elem_per_set, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1021"></A><EM CLASS="code">
                                    num_df_per_set, elem_ind, df_ind, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1022"></A><EM CLASS="code">
                                    elem_list, side_list, dist_fact);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1023"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1024"></A><EM CLASS="code">
   free (ids);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1025"></A><EM CLASS="code">
   free (num_elem_per_set);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1026"></A><EM CLASS="code">
   free (num_df_per_set);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1027"></A><EM CLASS="code">
   free (df_ind);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1028"></A><EM CLASS="code">
   free (elem_ind);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1029"></A><EM CLASS="code">
   free (elem_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1030"></A><EM CLASS="code">
   free (side_list);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1031"></A><EM CLASS="code">
   free (dist_fact);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1032"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1033"></A><EM CLASS="code">
/* end of concatenated side set read */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1034"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1035"></A><EM CLASS="code">
/* read QA records */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1036"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1037"></A><EM CLASS="code">
   ex_inquire (exoid, EX_INQ_QA, &amp;num_qa_rec, &amp;fdum, cdum);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1038"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1039"></A><EM CLASS="code">
   for (i=0; i&lt;num_qa_rec; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1040"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1041"></A><EM CLASS="code">
      for (j=0; j&lt;4; j++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1042"></A><EM CLASS="code">
      {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1043"></A><EM CLASS="code">
         qa_record[i][j] = (char *) calloc ((MAX_STR_LENGTH+1), sizeof(char));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1044"></A><EM CLASS="code">
      }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1045"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1046"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1047"></A><EM CLASS="code">
   error = ex_get_qa (exoid, qa_record); </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1048"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1049"></A><EM CLASS="code">
/* read information records */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1050"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1051"></A><EM CLASS="code">
   error = ex_inquire (exoid, EX_INQ_INFO, &amp;num_info, &amp;fdum, cdum);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1052"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1053"></A><EM CLASS="code">
   for (i=0; i&lt;num_info; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1054"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1055"></A><EM CLASS="code">
      info[i] = (char *) calloc ((MAX_LINE_LENGTH+1), sizeof(char));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1056"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1057"></A><EM CLASS="code">
   error = ex_get_info (exoid, info); </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1058"></A><EM CLASS="code">
   for (i=0; i&lt;num_info; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1059"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1060"></A><EM CLASS="code">
     free(info[i]);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1061"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1062"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1063"></A><EM CLASS="code">
/* read global variables parameters and names */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1064"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1065"></A><EM CLASS="code">
   error = ex_get_var_param (exoid, &quot;g&quot;, &amp;num_glo_vars);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1066"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1067"></A><EM CLASS="code">
   for (i=0; i&lt;num_glo_vars; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1068"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1069"></A><EM CLASS="code">
      var_names[i] = (char *) calloc ((MAX_STR_LENGTH+1), sizeof(char));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1070"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1071"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1072"></A><EM CLASS="code">
   error = ex_get_var_names (exoid, &quot;g&quot;, num_glo_vars, var_names);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1073"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1074"></A><EM CLASS="code">
   for (i=0; i&lt;num_glo_vars; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1075"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1076"></A><EM CLASS="code">
      free(var_names[i]);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1077"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1078"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1079"></A><EM CLASS="code">
/* read nodal variables parameters and names */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1080"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1081"></A><EM CLASS="code">
   error = ex_get_var_param (exoid, &quot;n&quot;, &amp;num_nod_vars);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1082"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1083"></A><EM CLASS="code">
   for (i=0; i&lt;num_nod_vars; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1084"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1085"></A><EM CLASS="code">
      var_names[i] = (char *) calloc ((MAX_STR_LENGTH+1), sizeof(char));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1086"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1087"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1088"></A><EM CLASS="code">
   error = ex_get_var_names (exoid, &quot;n&quot;, num_nod_vars, var_names);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1089"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1090"></A><EM CLASS="code">
   for (i=0; i&lt;num_nod_vars; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1091"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1092"></A><EM CLASS="code">
      free(var_names[i]);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1093"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1094"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1095"></A><EM CLASS="code">
/* read element variables parameters and names */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1096"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1097"></A><EM CLASS="code">
   error = ex_get_var_param (exoid, &quot;e&quot;, &amp;num_ele_vars);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1098"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1099"></A><EM CLASS="code">
   for (i=0; i&lt;num_ele_vars; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1100"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1101"></A><EM CLASS="code">
      var_names[i] = (char *) calloc ((MAX_STR_LENGTH+1), sizeof(char));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1102"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1103"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1104"></A><EM CLASS="code">
   error = ex_get_var_names (exoid, &quot;e&quot;, num_ele_vars, var_names);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1105"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1106"></A><EM CLASS="code">
   for (i=0; i&lt;num_ele_vars; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1107"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1108"></A><EM CLASS="code">
      free(var_names[i]);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1109"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1110"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1111"></A><EM CLASS="code">
/* read element variable truth table */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1112"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1113"></A><EM CLASS="code">
   truth_tab = (int *) calloc ((num_elem_blk*num_ele_vars), sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1114"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1115"></A><EM CLASS="code">
   error = ex_get_elem_var_tab (exoid, num_elem_blk, num_ele_vars, truth_tab);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1116"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1117"></A><EM CLASS="code">
   free (truth_tab);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1118"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1119"></A><EM CLASS="code">
/* determine how many time steps are stored */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1120"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1121"></A><EM CLASS="code">
   error = ex_inquire (exoid, EX_INQ_TIME, &amp;num_time_steps, &amp;fdum, cdum);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1122"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1123"></A><EM CLASS="code">
/* read time value at one time step */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1124"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1125"></A><EM CLASS="code">
   time_step = 3;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1126"></A><EM CLASS="code">
   error = ex_get_time (exoid, time_step, &amp;time_value);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1127"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1128"></A><EM CLASS="code">
/* read time values at all time steps */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1129"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1130"></A><EM CLASS="code">
   time_values = (float *) calloc (num_time_steps, sizeof(float));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1131"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1132"></A><EM CLASS="code">
   error = ex_get_all_times (exoid, time_values);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1133"></A><EM CLASS="code">
   free (time_values);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1134"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1135"></A><EM CLASS="code">
/* read all global variables at one time step */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1136"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1137"></A><EM CLASS="code">
   var_values = (float *) calloc (num_glo_vars, sizeof(float));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1138"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1139"></A><EM CLASS="code">
   error = ex_get_glob_vars (exoid, time_step, num_glo_vars, var_values);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1140"></A><EM CLASS="code">
   free (var_values); </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1141"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1142"></A><EM CLASS="code">
/* read a single global variable through time */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1143"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1144"></A><EM CLASS="code">
   var_index = 1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1145"></A><EM CLASS="code">
   beg_time = 1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1146"></A><EM CLASS="code">
   end_time = -1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1147"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1148"></A><EM CLASS="code">
   var_values = (float *) calloc (num_time_steps, sizeof(float));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1149"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1150"></A><EM CLASS="code">
   error = ex_get_glob_var_time (exoid, var_index, beg_time, end_time, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1151"></A><EM CLASS="code">
                                 var_values);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1152"></A><EM CLASS="code">
   free (var_values); </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1153"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1154"></A><EM CLASS="code">
/* read a nodal variable at one time step */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1155"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1156"></A><EM CLASS="code">
   var_values = (float *) calloc (num_nodes, sizeof(float));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1157"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1158"></A><EM CLASS="code">
   error = ex_get_nodal_var (exoid, time_step, var_index, num_nodes, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1159"></A><EM CLASS="code">
                             var_values);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1160"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1161"></A><EM CLASS="code">
   free (var_values); </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1162"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1163"></A><EM CLASS="code">
/* read a nodal variable through time */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1164"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1165"></A><EM CLASS="code">
   var_values = (float *) calloc (num_time_steps, sizeof(float));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1166"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1167"></A><EM CLASS="code">
   node_num = 1;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1168"></A><EM CLASS="code">
   error = ex_get_nodal_var_time (exoid, var_index, node_num, beg_time, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1169"></A><EM CLASS="code">
                                  end_time, var_values);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1170"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1171"></A><EM CLASS="code">
   free (var_values); </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1172"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1173"></A><EM CLASS="code">
/* read an element variable at one time step */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1174"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1175"></A><EM CLASS="code">
   ids = (int *) calloc(num_elem_blk, sizeof(int));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1176"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1177"></A><EM CLASS="code">
   error = ex_get_elem_blk_ids (exoid, ids);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1178"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1179"></A><EM CLASS="code">
   for (i=0; i&lt;num_elem_blk; i++)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1180"></A><EM CLASS="code">
   {</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1181"></A><EM CLASS="code">
      var_values = (float *) calloc (num_elem_in_block[i], sizeof(float));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1182"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1183"></A><EM CLASS="code">
      error = ex_get_elem_var (exoid, time_step, var_index, ids[i], </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1184"></A><EM CLASS="code">
                               num_elem_in_block[i], var_values);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1185"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1186"></A><EM CLASS="code">
      free (var_values); </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1187"></A><EM CLASS="code">
   }</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1188"></A><EM CLASS="code">
   free (num_elem_in_block);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1189"></A><EM CLASS="code">
   free(ids);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1190"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1191"></A><EM CLASS="code">
/* read an element variable through time */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1192"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1193"></A><EM CLASS="code">
   var_values = (float *) calloc (num_time_steps, sizeof(float));</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1194"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1195"></A><EM CLASS="code">
   var_index = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1196"></A><EM CLASS="code">
   elem_num = 2;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1197"></A><EM CLASS="code">
   error = ex_get_elem_var_time (exoid, var_index, elem_num, beg_time, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1198"></A><EM CLASS="code">
                                  end_time, var_values);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1199"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1200"></A><EM CLASS="code">
   free (var_values); </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1201"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1202"></A><EM CLASS="code">
   error = ex_close (exoid);</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1203"></A><EM CLASS="code">
}</EM>
</P>
</DIV>
<DIV>
<H4 CLASS="Heading">
<A NAME="50334055_pgfId-1204"></A>FORTRAN Write <A NAME="50334055_marker-60"></A>Example Code</H4>
<P CLASS="Body">
<A NAME="50334055_pgfId-2000"></A>The following Fortran program creates an EXODUS II file and populates it.  Although this sample code does not conform entirely to the ANSI Fortran-77 standard (i.e., lengths of variable names, included files, etc.), it has successfully compiled and executed on all UNIX workstations we have attempted and is included only as an example.</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1205"></A><EM CLASS="code">
      program testwt</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1206"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1207"></A><EM CLASS="code">
c This is a test program for the Fortran binding of the EXODUS II</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1208"></A><EM CLASS="code">
c database write routines.</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1209"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1210"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1211"></A><EM CLASS="code">
      include `exodusII.inc'</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1212"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1213"></A><EM CLASS="code">
      integer iin, iout</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1214"></A><EM CLASS="code">
      integer exoid, num_dim, num_nodes, num_elem, num_elem_blk</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1215"></A><EM CLASS="code">
      integer num_elem_in_block(2), num_node_sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1216"></A><EM CLASS="code">
      integer num_side_sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1217"></A><EM CLASS="code">
      integer i, j, k, m, elem_map(2), connect(4) </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1218"></A><EM CLASS="code">
      integer node_list(10), elem_list(10), side_list(10)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1219"></A><EM CLASS="code">
      integer ebids(2),ids(2), num_nodes_per_set(2), num_elem_per_set(2)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1220"></A><EM CLASS="code">
      integer num_df_per_set(2)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1221"></A><EM CLASS="code">
      integer df_ind(2), node_ind(2), elem_ind(2), num_qa_rec, num_info</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1222"></A><EM CLASS="code">
      integer num_glo_vars, num_nod_vars, num_ele_vars</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1223"></A><EM CLASS="code">
      integer truth_tab(3,2)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1224"></A><EM CLASS="code">
      integer whole_time_step, num_time_steps</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1225"></A><EM CLASS="code">
      integer cpu_word_size, io_word_size</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1226"></A><EM CLASS="code">
      integer prop_array(2)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1227"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1228"></A><EM CLASS="code">
      real glob_var_vals(10), nodal_var_vals(8) </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1229"></A><EM CLASS="code">
      real time_value, elem_var_vals(20)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1230"></A><EM CLASS="code">
      real x(8), y(8), dummy(1)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1231"></A><EM CLASS="code">
      real attrib(1), dist_fact(8)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1232"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1233"></A><EM CLASS="code">
      character*(MXSTLN) coord_names(3)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1234"></A><EM CLASS="code">
      character*(MXSTLN) cname</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1235"></A><EM CLASS="code">
      character*(MXSTLN) var_names(3)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1236"></A><EM CLASS="code">
      character*(MXSTLN) qa_record(4,2)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1237"></A><EM CLASS="code">
      character*(MXLNLN) inform(3)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1238"></A><EM CLASS="code">
      character*(MXSTLN) prop_names(2)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1239"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1240"></A><EM CLASS="code">
      data iin /5/, iout /6/</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1241"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1242"></A><EM CLASS="code">
      cpu_word_size = 0</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1243"></A><EM CLASS="code">
      io_word_size = 0</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1244"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1245"></A><EM CLASS="code">
c  create EXODUS II files </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1246"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1247"></A><EM CLASS="code">
      exoid = excre (&quot;test.exo&quot;,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1248"></A><EM CLASS="code">
     1	 	     EXCLOB, cpu_word_size, io_word_size, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1249"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1250"></A><EM CLASS="code">
c  initialize file with parameters</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1251"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1252"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1253"></A><EM CLASS="code">
      num_dim = 2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1254"></A><EM CLASS="code">
      num_nodes = 8</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1255"></A><EM CLASS="code">
      num_elem = 2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1256"></A><EM CLASS="code">
      num_elem_blk = 2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1257"></A><EM CLASS="code">
      num_node_sets = 2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1258"></A><EM CLASS="code">
      num_side_sets = 2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1259"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1260"></A><EM CLASS="code">
      call expini (exoid, &quot;This is a test&quot;, num_dim, num_nodes, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1261"></A><EM CLASS="code">
     1             num_elem, num_elem_blk, num_node_sets, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1262"></A><EM CLASS="code">
     2             num_side_sets, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1263"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2103"></A>&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2104"></A>&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2105"></A>&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1264"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1265"></A><EM CLASS="code">
c  write nodal coordinates values and names to database</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1266"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1267"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1268"></A><EM CLASS="code">
      x(1) = 0.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1269"></A><EM CLASS="code">
      x(2) = 1.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1270"></A><EM CLASS="code">
      x(3) = 1.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1271"></A><EM CLASS="code">
      x(4) = 0.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1272"></A><EM CLASS="code">
      x(5) = 1.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1273"></A><EM CLASS="code">
      x(6) = 2.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1274"></A><EM CLASS="code">
      x(7) = 2.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1275"></A><EM CLASS="code">
      x(8) = 1.0</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1276"></A><EM CLASS="code">
      y(1) = 0.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1277"></A><EM CLASS="code">
      y(2) = 0.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1278"></A><EM CLASS="code">
      y(3) = 1.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1279"></A><EM CLASS="code">
      y(4) = 1.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1280"></A><EM CLASS="code">
      y(5) = 0.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1281"></A><EM CLASS="code">
      y(6) = 0.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1282"></A><EM CLASS="code">
      y(7) = 1.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1283"></A><EM CLASS="code">
      y(8) = 1.0</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1284"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1285"></A><EM CLASS="code">
      call expcor (exoid, x, y, dummy, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1286"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1287"></A><EM CLASS="code">
      coord_names(1) = &quot;xcoor&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1288"></A><EM CLASS="code">
      coord_names(2) = &quot;ycoor&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1289"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1290"></A><EM CLASS="code">
      call expcon (exoid, coord_names, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1291"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1292"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1293"></A><EM CLASS="code">
c write element order map</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1294"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1295"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1296"></A><EM CLASS="code">
      do 10 i = 1, num_elem</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1297"></A><EM CLASS="code">
         elem_map(i) = i</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1298"></A><EM CLASS="code">
10    continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1299"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1300"></A><EM CLASS="code">
      call expmap (exoid, elem_map, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1301"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1302"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1303"></A><EM CLASS="code">
c write element block parameters</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1304"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1305"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1306"></A><EM CLASS="code">
      num_elem_in_block(1) = 1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1307"></A><EM CLASS="code">
      num_elem_in_block(2) = 1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1308"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1309"></A><EM CLASS="code">
      ebids(1) = 10</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1310"></A><EM CLASS="code">
      ebids(2) = 11</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1311"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1312"></A><EM CLASS="code">
      cname = &quot;QUAD&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1313"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1314"></A><EM CLASS="code">
      call expelb (exoid,ebids(1),cname,num_elem_in_block(1),4,1,ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1315"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1316"></A><EM CLASS="code">
      call expelb (exoid,ebids(2),cname,num_elem_in_block(2),4,1,ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1317"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1318"></A><EM CLASS="code">
c  write element block properties</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1319"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1320"></A><EM CLASS="code">
      prop_names(1) = &quot;TOP&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1321"></A><EM CLASS="code">
      prop_names(2) = &quot;RIGHT&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1322"></A><EM CLASS="code">
      call exppn(exoid,EXEBLK,2,prop_names,ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1323"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1324"></A><EM CLASS="code">
      call expp(exoid, EXEBLK, ebids(1), &quot;TOP&quot;, 1, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1325"></A><EM CLASS="code">
      call expp(exoid, EXEBLK, ebids(2), &quot;RIGHT&quot;, 1, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1327"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1328"></A><EM CLASS="code">
c write element connectivity</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1329"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1330"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1331"></A><EM CLASS="code">
      connect(1) = 1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1332"></A><EM CLASS="code">
      connect(2) = 2 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1333"></A><EM CLASS="code">
      connect(3) = 3 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1334"></A><EM CLASS="code">
      connect(4) = 4</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1335"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1336"></A><EM CLASS="code">
      call expelc (exoid, ebids(1), connect, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1338"></A><EM CLASS="code">
      connect(1) = 5</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1339"></A><EM CLASS="code">
      connect(2) = 6 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1340"></A><EM CLASS="code">
      connect(3) = 7 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1341"></A><EM CLASS="code">
      connect(4) = 8</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1342"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1343"></A><EM CLASS="code">
      call expelc (exoid, ebids(2), connect, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1344"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1345"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1346"></A><EM CLASS="code">
c write element block attributes</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1347"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1348"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1349"></A><EM CLASS="code">
      attrib(1) = 3.14159</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1350"></A><EM CLASS="code">
      call expeat (exoid, ebids(1), attrib, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1351"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1352"></A><EM CLASS="code">
      attrib(1) = 6.14159</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1353"></A><EM CLASS="code">
      call expeat (exoid, ebids(2), attrib, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1354"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1355"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1356"></A><EM CLASS="code">
c write individual node sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1357"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1358"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1359"></A><EM CLASS="code">
      node_list(1) = 100 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1360"></A><EM CLASS="code">
      node_list(2) = 101 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1361"></A><EM CLASS="code">
      node_list(3) = 102 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1362"></A><EM CLASS="code">
      node_list(4) = 103 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1363"></A><EM CLASS="code">
      node_list(5) = 104 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1364"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1365"></A><EM CLASS="code">
      dist_fact(1) = 1.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1366"></A><EM CLASS="code">
      dist_fact(2) = 2.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1367"></A><EM CLASS="code">
      dist_fact(3) = 3.0</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1368"></A><EM CLASS="code">
      dist_fact(4) = 4.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1369"></A><EM CLASS="code">
      dist_fact(5) = 5.0</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1370"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1371"></A><EM CLASS="code">
      call expnp (exoid, 20, 5, 5, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1372"></A><EM CLASS="code">
      call expns (exoid, 20, node_list, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1373"></A><EM CLASS="code">
      call expnsd (exoid, 20, dist_fact, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1374"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1375"></A><EM CLASS="code">
      node_list(1) = 200 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1376"></A><EM CLASS="code">
      node_list(2) = 201 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1377"></A><EM CLASS="code">
      node_list(3) = 202 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1378"></A><EM CLASS="code">
   </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1379"></A><EM CLASS="code">
      dist_fact(1) = 1.1 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1380"></A><EM CLASS="code">
      dist_fact(2) = 2.1 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1381"></A><EM CLASS="code">
      dist_fact(3) = 3.1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1382"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1383"></A><EM CLASS="code">
      call expnp (exoid, 21, 3, 3, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1384"></A><EM CLASS="code">
      call expns (exoid, 21, node_list, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1385"></A><EM CLASS="code">
      call expnsd (exoid, 21, dist_fact, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1386"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1387"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1388"></A><EM CLASS="code">
c write concatenated node sets; this produces the same information as</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1389"></A><EM CLASS="code">
c the above code which writes individual node sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1390"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1391"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1392"></A><EM CLASS="code">
      ids(1) = 20 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1393"></A><EM CLASS="code">
      ids(2) = 21</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1394"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1395"></A><EM CLASS="code">
      num_nodes_per_set(1) = 5 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1396"></A><EM CLASS="code">
      num_nodes_per_set(2) = 3</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1397"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1398"></A><EM CLASS="code">
      num_df_per_set(1) = 5 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1399"></A><EM CLASS="code">
      num_df_per_set(2) = 3</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1400"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1401"></A><EM CLASS="code">
      node_ind(1) = 1 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1402"></A><EM CLASS="code">
      node_ind(2) = 6</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1403"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1404"></A><EM CLASS="code">
      df_ind(1) = 1 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1405"></A><EM CLASS="code">
      df_ind(2) = 6</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1406"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1407"></A><EM CLASS="code">
      node_list(1) = 100 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1408"></A><EM CLASS="code">
      node_list(2) = 101 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1409"></A><EM CLASS="code">
      node_list(3) = 102 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1410"></A><EM CLASS="code">
      node_list(4) = 103 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1411"></A><EM CLASS="code">
      node_list(5) = 104 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1412"></A><EM CLASS="code">
      node_list(6) = 200 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1413"></A><EM CLASS="code">
      node_list(7) = 201 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1414"></A><EM CLASS="code">
      node_list(8) = 202</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1415"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1416"></A><EM CLASS="code">
      dist_fact(1) = 1.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1417"></A><EM CLASS="code">
      dist_fact(2) = 2.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1418"></A><EM CLASS="code">
      dist_fact(3) = 3.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1419"></A><EM CLASS="code">
      dist_fact(4) = 4.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1420"></A><EM CLASS="code">
      dist_fact(5) = 5.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1421"></A><EM CLASS="code">
      dist_fact(6) = 1.1 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1422"></A><EM CLASS="code">
      dist_fact(7) = 2.1 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1423"></A><EM CLASS="code">
      dist_fact(8) = 3.1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1424"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2170"></A>c commented out because individual node sets already written</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1425"></A><EM CLASS="code">
c      call expcns (exoid, ids, num_nodes_per_set, num_df_per_set,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1426"></A><EM CLASS="code">
c     1        node_ind, df_ind, node_list, dist_fact, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1427"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1428"></A><EM CLASS="code">
c     write node set properties</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1429"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1430"></A><EM CLASS="code">
      prop_names(1) = &quot;FACE&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1431"></A><EM CLASS="code">
      call expp(exoid, EXNSET, 20, prop_names(1), 4, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1432"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1433"></A><EM CLASS="code">
      call expp(exoid, EXNSET, 21, prop_names(1), 5, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1434"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1435"></A><EM CLASS="code">
      prop_array(1) = 1000</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1436"></A><EM CLASS="code">
      prop_array(2) = 2000</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1437"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1438"></A><EM CLASS="code">
      prop_names(1) = &quot;FRONT&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1439"></A><EM CLASS="code">
      call exppa(exoid, EXNSET, prop_names(1), prop_array, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1440"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1441"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1442"></A><EM CLASS="code">
c write individual side sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1443"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1444"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1445"></A><EM CLASS="code">
      elem_list(1) = 11</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1446"></A><EM CLASS="code">
      elem_list(2) = 12</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1447"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1448"></A><EM CLASS="code">
      side_list(1) = 1 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1449"></A><EM CLASS="code">
      side_list(2) = 2 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1450"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1451"></A><EM CLASS="code">
      dist_fact(1) = 30.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1452"></A><EM CLASS="code">
      dist_fact(2) = 30.1 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1453"></A><EM CLASS="code">
      dist_fact(3) = 30.2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1454"></A><EM CLASS="code">
      dist_fact(4) = 30.3</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1455"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1456"></A><EM CLASS="code">
      call expsp (exoid, 30, 2, 4, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1457"></A><EM CLASS="code">
      call expss (exoid, 30, elem_list, side_list, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1458"></A><EM CLASS="code">
      call expssd (exoid, 30, dist_fact, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1459"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1460"></A><EM CLASS="code">
      elem_list(1) = 13</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1461"></A><EM CLASS="code">
      elem_list(2) = 14</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1462"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1463"></A><EM CLASS="code">
      side_list(1) = 3</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1464"></A><EM CLASS="code">
      side_list(2) = 4</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1465"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1466"></A><EM CLASS="code">
      dist_fact(1) = 31.0</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1467"></A><EM CLASS="code">
      dist_fact(2) = 31.1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1468"></A><EM CLASS="code">
      dist_fact(3) = 31.2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1469"></A><EM CLASS="code">
      dist_fact(4) = 31.3</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1470"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1471"></A><EM CLASS="code">
      call expsp (exoid, 31, 2, 4, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1472"></A><EM CLASS="code">
      call expss (exoid, 31, elem_list, side_list, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1473"></A><EM CLASS="code">
      call expssd (exoid, 31, dist_fact, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1474"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1475"></A><EM CLASS="code">
c write concatenated side sets; this produces the same information as</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1476"></A><EM CLASS="code">
c the above code which writes individual side sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1477"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1478"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1479"></A><EM CLASS="code">
      ids(1) = 30</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1480"></A><EM CLASS="code">
      ids(2) = 31</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1482"></A><EM CLASS="code">
      num_elem_per_set(1) = 2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1483"></A><EM CLASS="code">
      num_elem_per_set(2) = 2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1484"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1485"></A><EM CLASS="code">
      num_df_per_set(1) = 4</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1486"></A><EM CLASS="code">
      num_df_per_set(2) = 4</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1487"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1488"></A><EM CLASS="code">
      elem_ind(1) = 1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1489"></A><EM CLASS="code">
      elem_ind(2) = 3</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1490"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1491"></A><EM CLASS="code">
      df_ind(1) = 1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1492"></A><EM CLASS="code">
      df_ind(2) = 5</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1493"></A><EM CLASS="code">
   </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1494"></A><EM CLASS="code">
      elem_list(1) = 11 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1495"></A><EM CLASS="code">
      elem_list(2) = 12</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1496"></A><EM CLASS="code">
      elem_list(3) = 13 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1497"></A><EM CLASS="code">
      elem_list(4) = 14</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1498"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1499"></A><EM CLASS="code">
      side_list(1) = 1 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1500"></A><EM CLASS="code">
      side_list(2) = 2 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1501"></A><EM CLASS="code">
      side_list(3) = 3 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1502"></A><EM CLASS="code">
      side_list(4) = 4</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1503"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1504"></A><EM CLASS="code">
      dist_fact(1) = 30.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1505"></A><EM CLASS="code">
      dist_fact(2) = 30.1 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1506"></A><EM CLASS="code">
      dist_fact(3) = 30.2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1507"></A><EM CLASS="code">
      dist_fact(4) = 30.3 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1508"></A><EM CLASS="code">
      dist_fact(5) = 31.0 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1509"></A><EM CLASS="code">
      dist_fact(6) = 31.1 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1510"></A><EM CLASS="code">
      dist_fact(7) = 31.2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1511"></A><EM CLASS="code">
      dist_fact(8) = 31.3 </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1512"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2173"></A>c commented out because individual side sets already written</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1513"></A><EM CLASS="code">
c      call expcss (exoid, ids, num_elem_per_set, num_df_per_set, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1514"></A><EM CLASS="code">
c     1             elem_ind, df_ind, elem_list, side_list, dist_fact,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1515"></A><EM CLASS="code">
c     2             ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1516"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1517"></A><EM CLASS="code">
      prop_names(1) = &quot;COLOR&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1518"></A><EM CLASS="code">
      call expp(exoid, EXSSET, 30, prop_names(1), 100, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1519"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1520"></A><EM CLASS="code">
      call expp(exoid, EXSSET, 31, prop_names(1), 101, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1521"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1522"></A><EM CLASS="code">
c write QA records</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1523"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1524"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1525"></A><EM CLASS="code">
      num_qa_rec = 2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1526"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1527"></A><EM CLASS="code">
      qa_record(1,1) = &quot;TESTWT fortran version&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1528"></A><EM CLASS="code">
      qa_record(2,1) = &quot;testwt&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1529"></A><EM CLASS="code">
      qa_record(3,1) = &quot;07/07/93&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1530"></A><EM CLASS="code">
      qa_record(4,1) = &quot;15:41:33&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1531"></A><EM CLASS="code">
      qa_record(1,2) = &quot;FASTQ&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1532"></A><EM CLASS="code">
      qa_record(2,2) = &quot;fastq&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1533"></A><EM CLASS="code">
      qa_record(3,2) = &quot;07/07/93&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1534"></A><EM CLASS="code">
      qa_record(4,2) = &quot;16:41:33&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1535"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1536"></A><EM CLASS="code">
      call expqa (exoid, num_qa_rec, qa_record, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1537"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1538"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1539"></A><EM CLASS="code">
c write information records</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1540"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1541"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1542"></A><EM CLASS="code">
      num_info = 3</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1543"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1544"></A><EM CLASS="code">
      inform(1) = &quot;This is the first information record.&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1545"></A><EM CLASS="code">
      inform(2) = &quot;This is the second information record.&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1546"></A><EM CLASS="code">
      inform(3) = &quot;This is the third information record.&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1547"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1548"></A><EM CLASS="code">
      call expinf (exoid, num_info, inform, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1549"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2110"></A>&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2111"></A>&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2112"></A>&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1550"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2114"></A><EM CLASS="code">
c write results variables parameters and names</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1551"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1552"></A><EM CLASS="code">
      num_glo_vars = 1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1553"></A><EM CLASS="code">
  </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1554"></A><EM CLASS="code">
      var_names(1) = &quot;glo_vars&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1555"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1556"></A><EM CLASS="code">
      call expvp (exoid, &quot;g&quot;, num_glo_vars, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1557"></A><EM CLASS="code">
      call expvan (exoid, &quot;g&quot;, num_glo_vars, var_names, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1558"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1559"></A><EM CLASS="code">
      num_nod_vars = 2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1560"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1561"></A><EM CLASS="code">
      var_names(1) = &quot;nod_var0&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1562"></A><EM CLASS="code">
      var_names(2) = &quot;nod_var1&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1563"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1564"></A><EM CLASS="code">
      call expvp (exoid, &quot;n&quot;, num_nod_vars, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1565"></A><EM CLASS="code">
      call expvan (exoid, &quot;n&quot;, num_nod_vars, var_names, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1566"></A><EM CLASS="code">
   </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1567"></A><EM CLASS="code">
      num_ele_vars = 3</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1568"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1569"></A><EM CLASS="code">
      var_names(1) = &quot;ele_var0&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1570"></A><EM CLASS="code">
      var_names(2) = &quot;ele_var1&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1571"></A><EM CLASS="code">
      var_names(3) = &quot;ele_var2&quot;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1572"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1573"></A><EM CLASS="code">
      call expvp (exoid, &quot;e&quot;, num_ele_vars, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1574"></A><EM CLASS="code">
      call expvan (exoid, &quot;e&quot;, num_ele_vars, var_names, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1575"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1576"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1577"></A><EM CLASS="code">
c write element variable truth table</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1578"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1579"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1580"></A><EM CLASS="code">
      k = 0</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1581"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1582"></A><EM CLASS="code">
      do 30 i = 1,num_elem_blk</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1583"></A><EM CLASS="code">
         do 20 j = 1,num_ele_vars</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1584"></A><EM CLASS="code">
            truth_tab(j,i) = 1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1585"></A><EM CLASS="code">
20       continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1586"></A><EM CLASS="code">
30    continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1587"></A><EM CLASS="code">
      call expvtt (exoid, num_elem_blk, num_ele_vars, truth_tab,ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1588"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1589"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1590"></A><EM CLASS="code">
c for each time step, write the analysis results;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1591"></A><EM CLASS="code">
c the code below fills the arrays glob_var_vals, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1592"></A><EM CLASS="code">
c nodal_var_vals, and elem_var_vals with values for debugging purposes;</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1593"></A><EM CLASS="code">
c obviously the analysis code will populate these arrays</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1594"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1595"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1596"></A><EM CLASS="code">
      whole_time_step = 1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1597"></A><EM CLASS="code">
      num_time_steps = 10</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1598"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1599"></A><EM CLASS="code">
      do 110 i = 1, num_time_steps</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1600"></A><EM CLASS="code">
        time_value = real(i)/100.</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1601"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1602"></A><EM CLASS="code">
c write time value</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1603"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1604"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1605"></A><EM CLASS="code">
        call exptim (exoid, whole_time_step, time_value, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1606"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1607"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1608"></A><EM CLASS="code">
c write global variables</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1609"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1610"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1611"></A><EM CLASS="code">
        do 50 j = 1, num_glo_vars</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1612"></A><EM CLASS="code">
          glob_var_vals(j) = real(j+1) * time_value</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1613"></A><EM CLASS="code">
50      continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1614"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1615"></A><EM CLASS="code">
        call expgv (exoid, whole_time_step, num_glo_vars, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1616"></A><EM CLASS="code">
     1              glob_var_vals, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1617"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2115"></A>&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2116"></A>&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2117"></A>&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1618"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1619"></A><EM CLASS="code">
c write nodal variables</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1620"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1621"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1622"></A><EM CLASS="code">
        do 70 k = 1, num_nod_vars</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1623"></A><EM CLASS="code">
          do 60 j = 1, num_nodes</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1624"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1625"></A><EM CLASS="code">
            nodal_var_vals(j) = real(k) + (real(j) * time_value)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1626"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1627"></A><EM CLASS="code">
60        continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1628"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1629"></A><EM CLASS="code">
          call expnv (exoid, whole_time_step, k, num_nodes, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1630"></A><EM CLASS="code">
     1                nodal_var_vals, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1631"></A><EM CLASS="code">
70      continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1632"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1633"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1634"></A><EM CLASS="code">
c write element variables</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1635"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1636"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1637"></A><EM CLASS="code">
        do 100 k = 1, num_ele_vars</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1638"></A><EM CLASS="code">
          do 90 j = 1, num_elem_blk</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1639"></A><EM CLASS="code">
            do 80 m = 1, num_elem_in_block(j)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1640"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1641"></A><EM CLASS="code">
              elem_var_vals(m) = real(k+1) + real(j+1) + </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1642"></A><EM CLASS="code">
     1                          (real(m)*time_value)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1643"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1644"></A><EM CLASS="code">
80          continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1645"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1646"></A><EM CLASS="code">
            call expev (exoid, whole_time_step, k, ebids(j), </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1647"></A><EM CLASS="code">
     1                  num_elem_in_block(j), elem_var_vals, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1648"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1649"></A><EM CLASS="code">
90        continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1650"></A><EM CLASS="code">
100     continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1651"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1652"></A><EM CLASS="code">
        whole_time_step = whole_time_step + 1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1653"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1654"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1655"></A><EM CLASS="code">
c update the data file; this should be done at the end of every time </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1656"></A><EM CLASS="code">
c step to ensure that no data is lost if the analysis dies</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1657"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1658"></A><EM CLASS="code">
        call exupda (exoid, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1659"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1660"></A><EM CLASS="code">
110   continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1661"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1662"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1663"></A><EM CLASS="code">
c close the EXODUS files</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1664"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1665"></A><EM CLASS="code">
      call exclos (exoid, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1666"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1667"></A><EM CLASS="code">
      stop</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1668"></A><EM CLASS="code">
      end</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1669"></A><EM CLASS="code">
</EM>
&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Heading">
<A NAME="50334055_pgfId-1670"></A>FORTRAN Read <A NAME="50334055_marker-61"></A>Example Code</H4>
<P CLASS="Body">
<A NAME="50334055_pgfId-1999"></A>The following Fortran program reads data from an EXODUS II file:</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1671"></A><EM CLASS="code">
      program testrd</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1672"></A>&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1673"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1674"></A><EM CLASS="code">
c This is a test program for the Fortran binding of the EXODUS II</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1675"></A><EM CLASS="code">
c database read routines</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1676"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1677"></A><EM CLASS="code">
      implicit none</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1678"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1679"></A><EM CLASS="code">
      include `exodusII.inc'</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1680"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1681"></A><EM CLASS="code">
      integer iin, iout, ierr</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1682"></A><EM CLASS="code">
      integer exoid, num_dim, num_nodes, num_elem, num_elem_blk</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1683"></A><EM CLASS="code">
      integer num_node_sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1684"></A><EM CLASS="code">
      integer num_side_sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1685"></A><EM CLASS="code">
      integer i, j, elem_map(2), connect(4), node_list(10) </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1686"></A><EM CLASS="code">
      integer elem_list(10), side_list(10), ids(5) </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1687"></A><EM CLASS="code">
      integer num_elem_per_set(2), num_nodes_per_set(2)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1688"></A><EM CLASS="code">
      integer num_df_per_set(2)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1689"></A><EM CLASS="code">
      integer num_df_in_set, num_sides_in_set</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1690"></A><EM CLASS="code">
      integer df_ind(2), node_ind(2), elem_ind(2), num_qa_rec, num_info</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1691"></A><EM CLASS="code">
      integer num_glo_vars, num_nod_vars, num_ele_vars</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1692"></A><EM CLASS="code">
      integer truth_tab(3,2)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1693"></A><EM CLASS="code">
      integer num_time_steps</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1694"></A><EM CLASS="code">
      integer num_elem_in_block(2), num_nodes_per_elem(2)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1695"></A><EM CLASS="code">
      integer num_attr(2)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1696"></A><EM CLASS="code">
      integer num_nodes_in_set, num_elem_in_set</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1697"></A><EM CLASS="code">
      integer df_list_len, list_len, elem_list_len</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1698"></A><EM CLASS="code">
      integer node_num, time_step, var_index, beg_time, end_time</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1699"></A><EM CLASS="code">
      integer elem_num</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1700"></A><EM CLASS="code">
      integer cpu_ws,io_ws</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1701"></A><EM CLASS="code">
      integer num_props, prop_value</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1702"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1703"></A><EM CLASS="code">
      real time_value, time_values(10), var_values(10)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1704"></A><EM CLASS="code">
      real x(8), y(8), dummy(1)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1705"></A><EM CLASS="code">
      real attrib(1), dist_fact(8)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1706"></A><EM CLASS="code">
      real vers, fdum</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1707"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1708"></A><EM CLASS="code">
      character*(MXSTLN) coord_names(3), qa_record(4,2), var_names(3)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1709"></A><EM CLASS="code">
      character*(MXLNLN) inform(3), titl</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1710"></A><EM CLASS="code">
      character typ*(MXSTLN), cdum*1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1711"></A><EM CLASS="code">
      character*(MXSTLN) prop_names(3)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1712"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1713"></A><EM CLASS="code">
      data iin /5/, iout /6/</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1714"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1715"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1716"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1717"></A><EM CLASS="code">
c open EXODUS II files</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1718"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1719"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1720"></A><EM CLASS="code">
      cpu_ws = 0</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1721"></A><EM CLASS="code">
      io_ws = 0</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1722"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1723"></A><EM CLASS="code">
      exoid = exopen (&quot;test.exo&quot;, EXREAD, cpu_ws, io_ws, vers, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1724"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1725"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1726"></A><EM CLASS="code">
c read database parameters</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1727"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1728"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1729"></A><EM CLASS="code">
      call exgini (exoid, titl, num_dim, num_nodes, num_elem, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1730"></A><EM CLASS="code">
     1             num_elem_blk, num_node_sets, num_side_sets, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1731"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1732"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1733"></A><EM CLASS="code">
c read nodal coordinates values and names from database</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1734"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1735"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1736"></A><EM CLASS="code">
      call exgcor (exoid, x, y, dummy, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1737"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1738"></A><EM CLASS="code">
      call exgcon (exoid, coord_names, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1739"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1740"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1741"></A><EM CLASS="code">
c read element order map</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1742"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1743"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1744"></A><EM CLASS="code">
      call exgmap (exoid, elem_map, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1745"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1746"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1747"></A><EM CLASS="code">
c read element block parameters</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1748"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1749"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1750"></A><EM CLASS="code">
      call exgebi (exoid, ids, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1751"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1752"></A><EM CLASS="code">
      do 40 i = 1, num_elem_blk</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1753"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1754"></A><EM CLASS="code">
         call exgelb (exoid, ids(i), typ, num_elem_in_block(i),</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1755"></A><EM CLASS="code">
     1                num_nodes_per_elem(i), num_attr(i), ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1756"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1757"></A><EM CLASS="code">
40    continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1758"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1759"></A><EM CLASS="code">
c     read element block properties */</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1760"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1761"></A><EM CLASS="code">
      call exinq (exoid, EXNEBP, num_props, fdum, cdum, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1762"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1763"></A><EM CLASS="code">
      call exgpn(exoid, EXEBLK, prop_names, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1765"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1766"></A><EM CLASS="code">
      do 47 i = 1, num_props</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1767"></A><EM CLASS="code">
        do 45 j = 1, num_elem_blk</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1768"></A><EM CLASS="code">
          call exgp(exoid, EXEBLK,ids(j),prop_names(i),prop_value,ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1769"></A><EM CLASS="code">
45      continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1770"></A><EM CLASS="code">
47    continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1771"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1772"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1773"></A><EM CLASS="code">
c read element connectivity</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1774"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1775"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1776"></A><EM CLASS="code">
      do 60 i = 1, num_elem_blk</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1777"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1778"></A><EM CLASS="code">
         call exgelc (exoid, ids(i), connect, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1779"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1780"></A><EM CLASS="code">
60    continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1781"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1782"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1783"></A><EM CLASS="code">
c read element block attributes</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1784"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1785"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1786"></A><EM CLASS="code">
      do 70 i = 1, num_elem_blk</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1787"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1788"></A><EM CLASS="code">
         call exgeat (exoid, ids(i), attrib, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1789"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1790"></A><EM CLASS="code">
70    continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1791"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1792"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1793"></A><EM CLASS="code">
c read individual node sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1794"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1795"></A><EM CLASS="code">
      if (num_node_sets .gt. 0) then</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1796"></A><EM CLASS="code">
         call exgnsi (exoid, ids, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1797"></A><EM CLASS="code">
      endif</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1798"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1799"></A><EM CLASS="code">
      do 100 i = 1, num_node_sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1800"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1801"></A><EM CLASS="code">
         call exgnp (exoid, ids(i), num_nodes_in_set, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1802"></A><EM CLASS="code">
     1               num_df_in_set, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1803"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1804"></A><EM CLASS="code">
         call exgns (exoid, ids(i), node_list, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1805"></A><EM CLASS="code">
         call exgnsd (exoid, ids(i), dist_fact, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1806"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1807"></A><EM CLASS="code">
100   continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1808"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2178"></A>&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1809"></A><EM CLASS="code">
c     read node set properties</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1810"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1811"></A><EM CLASS="code">
      call exinq (exoid, EXNNSP, num_props, fdum, cdum, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1812"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1813"></A><EM CLASS="code">
      call exgpn(exoid, EXNSET, prop_names, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1814"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1815"></A><EM CLASS="code">
      do 107 i = 1, num_props</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1816"></A><EM CLASS="code">
        do 105 j = 1, num_node_sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1817"></A><EM CLASS="code">
          call exgp(exoid,EXNSET,ids(j),prop_names(i),prop_value,ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1818"></A><EM CLASS="code">
105      continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1819"></A><EM CLASS="code">
107    continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1820"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1821"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1822"></A><EM CLASS="code">
c read concatenated node sets; this produces the same information as</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1823"></A><EM CLASS="code">
c the above code which reads individual node sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1824"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1825"></A><EM CLASS="code">
      call exinq (exoid, EXNODS, num_node_sets, fdum, cdum, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1826"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1827"></A><EM CLASS="code">
      if (num_node_sets .gt. 0) then</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1828"></A><EM CLASS="code">
         call exinq (exoid, EXNSNL, list_len, fdum, cdum, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1829"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1830"></A><EM CLASS="code">
         call exinq (exoid, EXNSDF, list_len, fdum, cdum, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1831"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1832"></A><EM CLASS="code">
         call exgcns (exoid, ids, num_nodes_per_set, num_df_per_set,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1833"></A><EM CLASS="code">
     1                node_ind, df_ind, node_list, dist_fact, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1834"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1835"></A><EM CLASS="code">
      endif</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1837"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1838"></A><EM CLASS="code">
c read individual side sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1839"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1840"></A><EM CLASS="code">
      if (num_side_sets .gt. 0) then</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1841"></A><EM CLASS="code">
         call exgssi (exoid, ids, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1842"></A><EM CLASS="code">
      endif</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1843"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1844"></A><EM CLASS="code">
      do 190 i = 1, num_side_sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1845"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1846"></A><EM CLASS="code">
         call exgsp (exoid, ids(i), num_sides_in_set, num_df_in_set,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1847"></A><EM CLASS="code">
     1               ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1848"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1849"></A><EM CLASS="code">
         call exgss (exoid, ids(i), elem_list, side_list, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1850"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1851"></A><EM CLASS="code">
         call exgssd (exoid, ids(i), dist_fact, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1852"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1853"></A><EM CLASS="code">
         num_elem_in_set = num_sides_in_set</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1854"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1855"></A><EM CLASS="code">
190   continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1856"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1857"></A><EM CLASS="code">
c     read side set properties</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1858"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1859"></A><EM CLASS="code">
      call exinq (exoid, EXNSSP, num_props, fdum, cdum, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1860"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1861"></A><EM CLASS="code">
      call exgpn(exoid, EXSSET, prop_names, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1862"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1863"></A><EM CLASS="code">
      do 197 i = 1, num_props</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1864"></A><EM CLASS="code">
        do 195 j = 1, num_side_sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1865"></A><EM CLASS="code">
          call exgp(exoid, EXSSET,ids(j),prop_names(i),prop_value,ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1866"></A><EM CLASS="code">
195      continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1867"></A><EM CLASS="code">
197    continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1868"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1869"></A><EM CLASS="code">
      call exinq (exoid, EXSIDS, num_side_sets, fdum, cdum, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1870"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1871"></A><EM CLASS="code">
      if (num_side_sets .gt. 0) then</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1872"></A><EM CLASS="code">
         call exinq (exoid, EXSSEL, elem_list_len, fdum, cdum, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1874"></A><EM CLASS="code">
         call exinq (exoid, EXSSDF, df_list_len, fdum, cdum, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1875"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1876"></A><EM CLASS="code">
c read concatenated side sets; this produces the same information as</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1877"></A><EM CLASS="code">
c the above code which reads individual side sets</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1878"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1879"></A><EM CLASS="code">
         call exgcss (exoid, ids, num_elem_per_set, num_df_per_set, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1880"></A><EM CLASS="code">
     1             elem_ind, df_ind, elem_list, side_list, dist_fact,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1881"></A><EM CLASS="code">
     2             ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1883"></A><EM CLASS="code">
      endif</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1887"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1888"></A><EM CLASS="code">
c read QA records</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1889"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1890"></A><EM CLASS="code">
      call exinq (exoid, EXQA, num_qa_rec, fdum, cdum, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1891"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1892"></A><EM CLASS="code">
      call exgqa (exoid, qa_record, ierr) </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1893"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1894"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1895"></A><EM CLASS="code">
c read information records</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1896"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1897"></A><EM CLASS="code">
      call exinq (exoid, EXINFO, num_info, fdum, cdum, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1898"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1899"></A><EM CLASS="code">
      call exginf (exoid, inform, ierr) </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1900"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1901"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1902"></A><EM CLASS="code">
c read global variables parameters and names </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1903"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1904"></A><EM CLASS="code">
      call exgvp (exoid, &quot;g&quot;, num_glo_vars, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1905"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1906"></A><EM CLASS="code">
      call exgvan (exoid, &quot;g&quot;, num_glo_vars, var_names, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1907"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1908"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1909"></A><EM CLASS="code">
c read nodal variables parameters and names</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1910"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1911"></A><EM CLASS="code">
      call exgvp (exoid, &quot;n&quot;, num_nod_vars, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1912"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1913"></A><EM CLASS="code">
      call exgvan (exoid, &quot;n&quot;, num_nod_vars, var_names, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1914"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1915"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1916"></A><EM CLASS="code">
c read element variables parameters and names</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1917"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1918"></A><EM CLASS="code">
      call exgvp (exoid, &quot;e&quot;, num_ele_vars, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1919"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1920"></A><EM CLASS="code">
      call exgvan (exoid, &quot;e&quot;, num_ele_vars, var_names, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1921"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1922"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1923"></A><EM CLASS="code">
c read element variable truth table</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1924"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1925"></A><EM CLASS="code">
      call exgvtt (exoid, num_elem_blk, num_ele_vars, truth_tab, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1926"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1927"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1928"></A><EM CLASS="code">
c determine how many time steps are stored</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1929"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1930"></A><EM CLASS="code">
      call exinq (exoid, EXTIMS, num_time_steps, fdum, cdum, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1931"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1932"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1933"></A><EM CLASS="code">
c read time value at one time step</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1934"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1935"></A><EM CLASS="code">
      time_step = 3</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1936"></A><EM CLASS="code">
      call exgtim (exoid, time_step, time_value, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1937"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1938"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1939"></A><EM CLASS="code">
c read time values at all time steps</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1940"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1941"></A><EM CLASS="code">
      call exgatm (exoid, time_values, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1942"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1943"></A><EM CLASS="code">
      var_index = 1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1944"></A><EM CLASS="code">
      beg_time = 1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1945"></A><EM CLASS="code">
      end_time = -1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1946"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1947"></A><EM CLASS="code">
c read all global variables at one time step</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1948"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1949"></A><EM CLASS="code">
      call exggv (exoid, time_step, num_glo_vars, var_values, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1950"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1951"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1952"></A><EM CLASS="code">
c read a single global variable through time</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1953"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1954"></A><EM CLASS="code">
      call exggvt (exoid, var_index, beg_time, end_time, var_values,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1955"></A><EM CLASS="code">
     1             ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1956"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2131"></A>&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-2132"></A>&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1957"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1958"></A><EM CLASS="code">
c read a nodal variable at one time step</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1959"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1960"></A><EM CLASS="code">
      call exgnv (exoid, time_step, var_index, num_nodes, var_values,</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1961"></A><EM CLASS="code">
     1            ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1962"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1963"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1964"></A><EM CLASS="code">
c read a nodal variable through time</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1965"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1966"></A><EM CLASS="code">
      node_num = 1</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1967"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1968"></A><EM CLASS="code">
      call exgnvt (exoid, var_index, node_num, beg_time, end_time, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1969"></A><EM CLASS="code">
     1             var_values, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1970"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1971"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1972"></A><EM CLASS="code">
c read an element variable at one time step</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1973"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1974"></A><EM CLASS="code">
      call exgebi (exoid, ids, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1975"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1976"></A><EM CLASS="code">
      do 450 i = 1, num_elem_blk</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1977"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1978"></A><EM CLASS="code">
         call exgev (exoid, time_step, var_index, ids(i), </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1979"></A><EM CLASS="code">
     1               num_elem_in_block(i), var_values, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1980"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1981"></A><EM CLASS="code">
450   continue</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1982"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1983"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1984"></A><EM CLASS="code">
c read an element variable through time</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1985"></A><EM CLASS="code">
c</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1986"></A><EM CLASS="code">
      var_index = 2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1987"></A><EM CLASS="code">
      elem_num = 2</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1988"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1989"></A><EM CLASS="code">
      call exgevt (exoid, var_index, elem_num, beg_time, end_time, </EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1990"></A><EM CLASS="code">
     1             var_values, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1991"></A><EM CLASS="code">
 </EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1992"></A><EM CLASS="code">
      call exclos (exoid, ierr)</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1994"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1995"></A><EM CLASS="code">
      stop</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1996"></A><EM CLASS="code">
      end</EM>
</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1997"></A><EM CLASS="code">
</EM>
&nbsp;</P>
<P CLASS="singleline">
<A NAME="50334055_pgfId-1998"></A><EM CLASS="code">
</EM>
&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-5856"></A>A</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5857"></A>access mode 25, 26</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5858"></A>ASCII version of file 22</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5859"></A>attributes</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5860"></A>description 9</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5861"></A>number of 9, 65, 66, 68, 69</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5862"></A>read 75</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5863"></A>table of 9</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5864"></A>write 73</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-5865"></A>B</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5866"></A>boundary conditions 11, 12</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-5867"></A>C</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5868"></A>character strings 5</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5869"></A>clobber mode 23, 24</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5870"></A>close file 27</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5871"></A>concatenated node sets</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5872"></A>description 11</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5873"></A>read 91</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5874"></A>write 87</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5875"></A>concatenated side sets</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5876"></A>description 15</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5877"></A>read 112</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5878"></A>write 108</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5879"></A>connectivity array 71, 72</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5880"></A>conventions</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5881"></A>general 4</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5882"></A>node ordering 9</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5883"></A>convert</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5884"></A>netCDF to ASCII 22</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5885"></A>node list to side list 115</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5886"></A>coordinate names</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5887"></A>description 6</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5888"></A>read 55</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5889"></A>write 53</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5890"></A>coordinates, see nodal coordinates</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5891"></A>current 28</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-5892"></A>D</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5893"></A>dimensionality 5, 29, 30, 31, 32</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5894"></A>distribution factors, see side set; node set</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-5895"></A>E</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5896"></A>efficiency issues A-1</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5897"></A>element attributes, see attributes</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5898"></A>element block</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5899"></A>description 8</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5900"></A>ID 65, 66, 68, 69</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5901"></A>ID, description 8</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5902"></A>number of 5, 29, 30, 31, 32</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5903"></A>parameters, read 68</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5904"></A>parameters, write 65</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5905"></A>read IDs 70, 128</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5906"></A>element connectivity</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5907"></A>description 9</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5908"></A>read 72</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5909"></A>write 71</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5910"></A>element number map</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5911"></A>description 7</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5912"></A>read 61</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5913"></A>write 59</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5914"></A>element numbering 7, 8</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5915"></A>element order map 8, 62, 64</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5916"></A>element results, see element variable</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5917"></A>element topology 9</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5918"></A>element type 8, 65, 66, 68, 69</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5919"></A>table of 9</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5920"></A>element variable 20</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5921"></A>description 4</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5922"></A>read values 152, 154</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5923"></A>truth table 20</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5924"></A>truth table, read 147</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5925"></A>truth table,description 20</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5926"></A>truth table,write 145</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5927"></A>write values 149</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5928"></A>elements</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-5929"></A>number of 5, 29, 30, 31, 32</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5930"></A>error level 47</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5931"></A>error messages C-1</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5932"></A>error reporting 45</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5933"></A>ex_close 27, B-1</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5934"></A>ex_create 23, B-1</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5935"></A>ex_cvt_nodes_to_sides 115, B-1</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5936"></A>ex_err 45, B-1</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5937"></A>ex_get_all_times 19, 143, B-1</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5938"></A>ex_get_concat_node_sets 11, 91, B-1</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5939"></A>ex_get_concat_side_sets 15, 112, B-2</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5940"></A>ex_get_coord 6, 51, B-2</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5941"></A>ex_get_coord_names 6, 55, B-2</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5942"></A>ex_get_elem_attr 9, 75, B-2</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5943"></A>ex_get_elem_blk_ids 8, 70, B-2</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5944"></A>ex_get_elem_block 8, 68, B-2</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5945"></A>ex_get_elem_conn 9, 72, B-2</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5946"></A>ex_get_elem_num_map 7, B-2</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5947"></A>ex_get_elem_var 20, 152, B-2</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5948"></A>ex_get_elem_var_tab 20, 147, B-3</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5949"></A>ex_get_elem_var_time 20, 154, B-3</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5950"></A>ex_get_glob_var_time 19, 161, B-3</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5951"></A>ex_get_glob_vars 19, 159, B-3</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5952"></A>ex_get_info 6, 39, B-3</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5953"></A>ex_get_init 5, 31, B-3</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5954"></A>ex_get_map 8, 64, B-3</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5955"></A>ex_get_nodal_var 19, 165, B-3</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5956"></A>ex_get_nodal_var_time 19, 167, B-3</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5957"></A>ex_get_node_num_map 7, 58, 61, B-4</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5958"></A>ex_get_node_set 11, 82, B-4</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5959"></A>ex_get_node_set_dist_fact 11, 85, B-4</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5960"></A>ex_get_node_set_ids 11, 86, B-4</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5961"></A>ex_get_node_set_param 11, 79, B-4</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5962"></A>ex_get_prop 18, 124, B-4</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5963"></A>ex_get_prop_array 18, 128, B-4</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5964"></A>ex_get_prop_names 18, 120, B-4</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5965"></A>ex_get_qa 6, 35, B-4</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5966"></A>ex_get_side_set 14, 100, B-4</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5967"></A>ex_get_side_set_dist_fact 15, 104, B-4</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5968"></A>ex_get_side_set_ids 14, 105, B-4</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5969"></A>ex_get_side_set_node_list 14, 15, 106, B-5</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5970"></A>ex_get_side_set_param 14, 96, B-5</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5971"></A>ex_get_time 19, 141, B-5</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5972"></A>ex_get_var_names 19, 137, B-5</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5973"></A>ex_get_var_param 19, 133, B-5</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5974"></A>ex_inquire 41, B-5</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5975"></A>ex_open 25, B-5</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5976"></A>ex_opts 47, B-5</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5977"></A>ex_put_concat_node_sets 11, 87, B-5</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5978"></A>ex_put_concat_side_sets 15, 108, B-6</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5979"></A>ex_put_coord 6, 49, B-6</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5980"></A>ex_put_coord_names 6, 53, B-6</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5981"></A>ex_put_elem_attr 9, 73, B-6</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5982"></A>ex_put_elem_block 8, 65, B-6</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5983"></A>ex_put_elem_conn 9, 71, B-6</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5984"></A>ex_put_elem_num_map 7, B-6</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5985"></A>ex_put_elem_var 20, 149, B-6</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5986"></A>ex_put_elem_var_tab 20, 145, B-6</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5987"></A>ex_put_glob_vars 19, 157, B-6</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5988"></A>ex_put_info 6, 37, B-7</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5989"></A>ex_put_init 5, 29, B-7</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5990"></A>ex_put_map 8, 62, B-7</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5991"></A>ex_put_nodal_var 19, 163, B-7</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5992"></A>ex_put_node_num_map 7, 56, 59, B-7</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5993"></A>ex_put_node_set 11, 81, B-7</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5994"></A>ex_put_node_set_dist_fact 11, 83, B-7</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5995"></A>ex_put_node_set_param 11, 77, B-7</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5996"></A>ex_put_prop 18, 122, B-7</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5997"></A>ex_put_prop_array 18, 126, B-7</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5998"></A>ex_put_prop_param 18, 118, B-8</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-5999"></A>ex_put_qa 6, 33, B-8</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6000"></A>ex_put_side_set 14, 98, B-8</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6001"></A>ex_put_side_set_dist_fact 15, 102, B-8</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6002"></A>ex_put_side_set_param 14, 94, B-8</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6003"></A>ex_put_time 19, 139, B-8</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6004"></A>ex_put_var_names 19, 135, B-8</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6005"></A>ex_put_var_param 19, 131, B-8</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6006"></A>ex_update 22, 28, B-8</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6007"></A>examples</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6008"></A>C code D-1, D-10</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6009"></A>Fortran code D-17, D-24</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6010"></A>EXCLOS 27, B-9</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6011"></A>EXCN2S 116, B-9</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6012"></A>EXCRE 24, B-9</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6013"></A>EXERR 46, B-9</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6014"></A>EXGATM 19, 144, B-9</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6015"></A>EXGCNS 11, 92, B-9</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6016"></A>EXGCON 6, 55, B-9</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6017"></A>EXGCOR 6, 52, B-9</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6018"></A>EXGCSS 15, 113, B-10</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6019"></A>EXGEAT 9, 75, B-10</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6020"></A>EXGEBI 8, 70, B-10</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6021"></A>EXGELB 8, 69, B-10</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6022"></A>EXGELC 9, 72, B-10</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6023"></A>EXGENM 7, B-10</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6024"></A>EXGEV 20, 153, B-10</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6025"></A>EXGEVT 20, 155, B-11</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6026"></A>EXGGV 19, 160, B-11</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6027"></A>EXGGVT 19, 162, B-11</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6028"></A>EXGINF 6, 39, B-11</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6029"></A>EXGINI 5, 32, B-11</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6030"></A>EXGMAP 8, 58, 61, 64, B-11</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6031"></A>EXGNNM 7, B-11</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6032"></A>EXGNP 11, 80, B-11</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6033"></A>EXGNS 11, 82, B-12</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6034"></A>EXGNSD 11, 85, B-12</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6035"></A>EXGNSI 11, 86, B-12</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6036"></A>EXGNV 19, 166, B-12</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6037"></A>EXGNVT 19, 168, B-12</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6038"></A>EXGP 18, 124, B-12</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6039"></A>EXGPA 18, 129, B-12</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6040"></A>EXGPN 18, 121, B-12</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6041"></A>EXGQA 6, 36, B-12</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6042"></A>EXGSP 14, 97, B-13</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6043"></A>EXGSS 14, 100, B-13</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6044"></A>EXGSSD 15, 104, B-13</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6045"></A>EXGSSI 14, 105, B-13</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6046"></A>EXGSSN 14, 15, 107, B-13</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6047"></A>EXGTIM 19, 141, B-13</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6048"></A>EXGVAN 19, 138, B-13</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6049"></A>EXGVP 19, 133, B-13</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6050"></A>EXGVTT 20, 148, B-13</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6051"></A>EXINQ 42, B-14</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6052"></A>EXOPEN 26, B-14</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6053"></A>EXOPTS 47, B-14</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6054"></A>EXPCNS 11, 88, B-14</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6055"></A>EXPCON 6, 53, B-14</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6056"></A>EXPCOR 6, 50, B-14</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6057"></A>EXPCSS 15, 110, B-14</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6058"></A>EXPEAT 9, 73, B-15</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6059"></A>EXPELB 8, 66, B-15</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6060"></A>EXPELC 9, 71, B-15</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6061"></A>EXPENM 7, B-15</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6062"></A>EXPEV 20, 150, B-15</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6063"></A>EXPGV 19, 158, B-15</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6064"></A>EXPINF 6, 37, B-15</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6065"></A>EXPINI 5, 30, B-15</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6066"></A>EXPMAP 8, 62, B-16</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6067"></A>EXPNNM 7, 56, 59, B-16</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6068"></A>EXPNP 11, 78, B-16</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6069"></A>EXPNS 11, 81, B-16</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6070"></A>EXPNSD 11, 83, B-16</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6071"></A>EXPNV 19, 164, B-16</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6072"></A>EXPP 18, 123, B-16</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6073"></A>EXPPA 18, 127, B-16</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6074"></A>EXPPN 18, 119, B-17</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6075"></A>EXPQA 6, 34, B-17</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6076"></A>EXPSP 14, 95, B-17</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6077"></A>EXPSS 14, 98, B-17</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6078"></A>EXPSSD 15, 102, B-17</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6079"></A>EXPTIM 19, 139, B-17</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6080"></A>EXPVAN 19, 136, B-17</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6081"></A>EXPVP 19, 132, B-17</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6082"></A>EXPVTT 20, 146, B-17</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6083"></A>EXUPDA 22, 28, B-17</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-6084"></A>F</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6085"></A>flush buffers 22, 28</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6086"></A>function call summary B-1</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-6087"></A>G</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6088"></A>global variable</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6089"></A>description 4, 19</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6090"></A>read values 159, 161</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6091"></A>write values 157</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-6092"></A>I</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6093"></A>information data</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6094"></A>description 6</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6095"></A>read 39</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6096"></A>write 37</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6097"></A>initialization 4, 29, 31</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6098"></A>inquire parameters 41</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-6099"></A>M</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6100"></A>model 4, 48</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-6101"></A>N</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6102"></A>ncdump 22</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6103"></A>netCDF 3, 15, 22</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6104"></A>implementation of EXODUS A-1</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6105"></A>nodal coordinates</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6106"></A>description 6</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6107"></A>read 51</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6108"></A>write 49</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6109"></A>nodal variable</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6110"></A>description 4, 19</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6111"></A>read values 165, 167</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6112"></A>write values 163</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6113"></A>node number map 58</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6114"></A>description 7</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6115"></A>write 56</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6116"></A>node numbering 7</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6117"></A>node ordering 9</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6118"></A>node set</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6119"></A>concatenated 11, 87, 91</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6120"></A>description 11</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6121"></A>distribution factors 11, 77, 79, 83, 85</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6122"></A>distribution factors,description 11</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6123"></A>ID 11</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6124"></A>node list 11</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6125"></A>number of 5, 29, 30, 31, 32</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6126"></A>read 79, 82</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6127"></A>read IDs 86, 128</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6128"></A>write 77, 81</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6129"></A>nodes</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6130"></A>number of 5, 29, 30, 31, 32</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-6131"></A>O</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6132"></A>object property</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6133"></A>array 118, 126, 128</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6134"></A>description 17</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6135"></A>names 118, 120</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6136"></A>value 18, 122, 124</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6137"></A>open file 25</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-6138"></A>Q</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6139"></A>quality assurance (QA) records</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6140"></A>description 6</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6141"></A>read 35</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6142"></A>write 33</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6143"></A>query database 41</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-6144"></A>R</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6145"></A>results</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6146"></A>data description 19</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6147"></A>element, see element variable</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6148"></A>global, see global variable</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6149"></A>nodal, see nodal variable</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6150"></A>variable names 19, 135, 137</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6151"></A>variable parameters 131, 133</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-6152"></A>S</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6153"></A>side set</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6154"></A>concatenated 15, 108, 112</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6155"></A>description 12</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6156"></A>distribution factors 14, 94, 96, 102, 104</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6157"></A>distribution factors,description 15</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6158"></A>element list 14</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6159"></A>ID 14</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6160"></A>node count list 15</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6161"></A>node list 14, 106</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6162"></A>node ordering 16</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6163"></A>number of 5, 29, 30, 31, 32</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6164"></A>parameters 14, 94, 96</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6165"></A>read 100</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6166"></A>read IDs 105, 128</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6167"></A>side list 14</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6168"></A>side numbering 13</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6169"></A>write 98</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-6170"></A>T</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6171"></A>testrd</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6172"></A>C version D-10</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6173"></A>Fortran version D-24</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6174"></A>testwt</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6175"></A>C version D-1</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6176"></A>Fortran version D-17</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6177"></A>time step</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6178"></A>description 19</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6179"></A>time value</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6180"></A>description 19</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6181"></A>read 141, 143</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6182"></A>write 139</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6183"></A>title 5, 29, 30, 31, 32</P>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6184"></A>truth table, see element variable</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-6185"></A>U</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6186"></A>update file 28</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-6187"></A>V</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6188"></A>version 5, 25, 26</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-6189"></A>W</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6190"></A>word size</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6191"></A>compute 23, 24, 25, 26</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6192"></A>I/O 23, 24, 25, 26</P>
<P CLASS="Level2IX">
<A NAME="50334056_pgfId-6193"></A>I/O, description 5</P>
</DIV>
<DIV>
<H4 CLASS="GroupTitlesIX">
<A NAME="50334056_pgfId-6194"></A>X</H4>
<P CLASS="Level1IX">
<A NAME="50334056_pgfId-6195"></A>XDR 3</P>
</DIV>
</DIV>
</DIV>
</BODY>
</HTML>
