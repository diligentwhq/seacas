				VI. Results

6.1 Metrics Used
   When producing the output of the load balancer, the user can
specify how much detail on load balancing statistics should be
printed.  These statistics tell the user some information on what went
on during load balancing. If the user asks for statistics, they are
printed to standard output after the load balancer has completed. The
first information given is the total time used by the load
balancer. The time is given in seconds, and tells approximately how
fast the algorithm worked. Individual parts of the code are then
examined. "Number of partition iters" gives the number of recursive
calls the partitioner the load balancer had to use. Objects sent and
received during the initial generation of the tree is the next set of
information given. These objects were migrated to form the initial
grouping of the octants. Following this is the number of object sent
and received after load balancing. This gives a rough idea on the
communication needed to balance the processor loads, which is the next
set of output given. The processor loads are separated into the
different phases of the balancer. The "Initial Load" is the load on
the processors before any migration has taken place; the "Load Before
Balancing" is the load on the processors after the initial tree was
generated; and finally "Load After Balancing" is the load on the
processors with the new decomposition. Time statistics are also
present to see where most of the activities are taking
place. "Start-up time" is the time needed to create the initial
tree. This includes the partitioning of the subdomains to the
different processors and the time to migrate and build the tree using
this grouping. "Partition time" gives the amount of time to partition
the objects into the new decomposition. Included is the time to
calculate the cost of each subtree local to the processor and marking
all the objects to be migrated. The last timer, "Migration notice
time," gives the amount of time it took to set up the return values
from the load balancer to the application. Other metrics may be useful
to the user, and will be included in future work.

6.2 Comparisons And Conclusion
   Comparisons of the octree load balancer, with its various space
filling curves, have been made against the Recursive Coordinate
Bisection (RCB) method previously implemented in the Dynamic Load
Balancing library. The overall result shows that the octree algorithm
is slower than RCB, but depending on which space filling curve used,
the times do vary. In cases where the Morton Indexing scheme and the
Gray Code algorithm are used, the times show a slight increase. This
is especially true for the small test cases used. The 3x3 and 10x10
problems in two-dimensions showed at most a 1.77 time increase. With
larger test cases, such as the 20,000-element tilted reactor in 3D,
the time comparison grows larger, up to eight times as much for the
time needed by the load balancer to complete. The rate of time growth
for the Hilbert Curve proved to be much more greater than the Morton
Indexing or Gray Code; a more drastic time difference is very
present. Even in the smaller cases, it can be seen, with results being
4-9 times longer. In large cases, a maximum time difference of 82.42
times longer was found using the 20,000-element tilted reactor. With
more elements, it is expected that an algorithm will take more time,
but time growth was hoped to be steady.  Again comparing to RCB, the
Hilbert was the most costly algorithm. Analysis of this show that a
major portion of the time is spent during the initial tree
generation. Many of the example runs for the different space filling
curves used show that over 50% of the time in the load balancer is
spent with generating the initial tree. A maximum was found in the
20,000-element tilted reactor, using the Hilbert Curve, of 97.3% of the
time generating the initial tree. The generating of the tree is an
important piece for certain parts of the code, but a major portion
should not be spent in that area. Further investigation of this result
will be needed.
   It is not known how well the decompositions created compare to one
another. As expected, sample runs show discontinuities with the Morton
and Gray Code schemes. The boundaries created between processors did
not show a tendency towards "jaggedness," except with problems of
round-off errors on the coordinates of the objects. This would happen
if a line of objects lie exactly on the boundary between two
subdomains. With round-off errors, these objects could lie on either
subdomain despite the fact that boundary object should default to the
domain owned by the lower-numbered octant. Ways to examine the new
decompositions and to know how to compare the results will also be
implemented in the future.


			VII. Future Work

   The work that has been completed to date has made some advancements
in the octree load balancer and partitioner. In doing so, it has
created some avenues in which improvements can be made. As mentioned
previously, the Gray code should be modified so that it produces a
non-intersecting curve; as it is implemented, the Gray code does
not produce a true space filling curve. The Hilbert curve could also be
modified so that the 3D version of the code can be scaled down to
2D. Two different functions exist for the 3D and 2D Hilbert curve,
but if the pattern used to make the 3D curve were modified so that the
bottom face produces a 2D Hilbert curve, then the second function
would not be necessary. 
   Modification in running efficiencies are also needed. When setting
up the initial tree in the function gen_tree_from_input_data(), a tree
is built to determine which subdomain should be assigned to a
processor. This tree is then deleted since its information is stored
in an array, and memory used by that initial tree is unnecessary. The
initial subdomain distribution should be calculable without the need
for building this tree. Also when distributing the subdomains, areas
where there are no objects of interest should be ignored. There are
cases when the initial tree would assign a processor areas that are
empty. This can cause a greater communication cost during the load
balancing/partitioning phase. Since there are no objects on that
processor after the initial tree, its load is 0, and a relatively large
portion of object would then have to be imported to achieve balance. It
would also be more efficient if the initial tree was not built every
time the load balancer is called. After the first run through the
balancer, the decomposition should be close enough to an octree
decomposition, even with mesh refinements, so that the initial tree
grouping would be unnecessary.
   The question of efficient use of the load balancer on 3D surfaces
curves has also been posed. A projection from 3-space to 2-space
without loss or overlapping of objects on the surface would allow the
load balancer to use 2D algorithms. The 2D algorithm is slightly
faster and uses a lot less memory, again improving efficiency of the
code. It is not certain whether such a mapping exists, but the idea
should be looked into.
   Finally, good metrics used to measure the results can also be
implemented. This will allow the user to determine how well the
algorithms performed. Some metrics have been given, but other useful
ones should be considered: information on the domain decomposition,
neighboring processors, and the number of discontinuous regions. This
would help in comparing domain decomposition results.
