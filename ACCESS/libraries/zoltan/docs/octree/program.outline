			      II. Program Outline

octree_load_balancer_algorithm()
{
  octree initialization
  {  
    set space filling curve method

    initialize counters and global variables
  }

  generate tree from input data
  {   

    retrieve object information (LB_tag, Coordinates and Weights) and
	store in a linked list of objects

    find global minimum and maximum coordinate bounds of all objects
    
    levels of refinement = ceiling(log base 8 (number of processors))

    create a root node with global min and max coordinate bounds

    subdivide the root and the global domain to "levels of refinement"
        calculated above, assigning geometric subdomains to child nodes

    evenly divide leaf nodes among the processors; store which processor 
	gets which subdomain of the global domain. For the subdomains on local
	processor, create local roots.

    delete root node and subtree, keeping the stored subdomain partitioning 
	and local root just created.

    octree insert objects (list of objects)
    {
      for each entry in the list of objects
      {
        compare the object's coordinates with the subdomain bounds in each 
	    local root

	if the coordinates fit inside bounds of a local root
	{
	  recursively traverse down subtree using coordinate information to 
	      find which child to visit next, until there is a terminal octant

	  add object to list of objects associated with terminal octant

          if number of object in list > max # of objects allowed
	    oct_terminal_refine
            {
	      remove list from terminal octant

	      refine octant to have 8 child octants

	      insert each of the parent octant's object into appropriate 
		  child octant

              for each child octant
              {
                if number of object in list > max # of objects allowed
		  oct_terminal_refine /* max number of recursive calls to 
		             	       * oct_terminal_refine is 10
				       */
              }
            } /* end of oct_terminal_refine */
	} 
        else the coordinates do not fit inside bounds of the local root
	  mark object as orphaned
      } /* end of for loop for each entry in the list of objects */
    } /* end of octree insert objects */

    migrate orphaned objects
    {
      use stored subdomain partition from above to find to which processor to
          migrate orphaned objects

      use comm_create and comm_do to migrate orphans to new processors
    }

    octree insert objects(received orphans)
  } /* end of generate tree from input data */

  depth-first search partition octree
  {
    for each local root
    {
      compute costs
      {
	if octant is terminal
        {
          costs = sum of weights of all objects associated

          return cost
	}
	else
	{
	  for(i = 0; i < 8; i++)
	    cost += compute cost of child(i)

	  return cost
	}
      } /* end of compute costs */
    } /* end of for loop through local roots */
  
    initialize partition variables
    {
      my_cost = sum of cost of all local roots

      global_cost = MPI_Allreduce(my_cost)

      pref_cost = MPI_Scan(my_cost)    /* summed cost of lowered-numbered 
                                          processors */

      optimal_cost = global_cost / number of processors

      partition = (int)(pref_cost / optimal_cost)

      total = partition * optimal_cost  /* total cost of lowered-numbered
					   partitions */

      pcost = pref_cost - total   /* load already given to current partition */
    } /* end of initialize partition variables */

    calculate partition assignments
    {
      for each local root
      {
        visit all subtrees
        {
	  retrieve cost

  	  calculate how much more load is needed for the ideal load 
	      behind = partition * optimal_cost - total

	  if subtree cost can be added without overfilling
	      ((pcost+cost) <= (optimal_cost+behind))
	  {
            there is no overflow, entire subtree can be placed in 
	        current partition

            tag all objects associated with subtree to be in current partition

	    add cost of subtree to the partition cost: pcost += cost
	  }
	  else there is overflow
	  {
	    for each child octant
              visit all subtrees

	    if terminal octant
	    {
              amount of space left in partition = behind + optimal_cost - pcost

              if cost does not overflow too much (cost < 2*(amount_space_left))
	        tag all objects to current partition
	      else
	      {
	        increment partition counter

	        update total load already assigned (total += pcost)

      	        since starting a new partition, there should be no
		    residual cost, pcost = 0

	        tag all objects to current partition
	      }
	    } /* end of if terminal octant */
	  } /* end of else there is overflow */
        } /* end of visit all subtrees */
      } /* end of for loop through local roots */
    } /* end of calculate partition assignments */
  } /* end of depth-first search partition octree */

  depth-first search migrate
  {
    setup migration based on the partition tags calculated in depth-first
        search partition

    migrate object to new processor (partition == processor number)
  }

  fix tags
  {
    fix return data structure import_tags to include objects that were 
        previously imported during generate tree from input data, and
	exclude tags that were either:
            1. exported during generate tree from input data and re-imported
	    2. imported during generate tree from input data and re-exported
  }

  print statistics
}
