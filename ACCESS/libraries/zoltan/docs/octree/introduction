                                I. Introduction
1.1 Project Goals
   The goal of the project was to take work that has been completed at
Rensselaer Polytechnic Institute (RPI) [4] [6] [7] [9] on dynamic load
balancing techniques using the octree data structure and modify it to
be used by the SIERRA project through the Dynamic Load Balancing (DLB)
library created and maintained at Sandia National Laboratories. It was
realized that some changes would be necessary in doing so, but the
overall idea of the load balancer should remain the same. Any
improvements or enhancements that could be implemented while making
changes would also be explored.

   In importing the new octree system, it was hoped that a new
dimension of versatility would be added into the DLB library. With
added versatility, the chance of creating a better decomposition would
be increased, allowing applications to choose methods that would
suit individual needs. Once implemented, the different techniques
should be tested with varying inputs to see how the different
algorithms compare, and what trade-offs, if any, exist. Details on the
internal workings of the code should be well documented before the
separation date, in the hopes that others who may continue the work
will have an informative resource for referencing.

1.2 Description Of the Work Done
   Extensive efforts have been applied to integrating RPI's octree
data structure and load balancer/partitioner into the DLB library of
Sandia. Some of the data structures were made to be more generalized
so the load balancer would not become application specific.
Applications are now able to choose from Recursive Coordinate
Bisection (RCB) [3], the original load balancing scheme, or the newly
added Octree Partitioner (Octpart) [4] [6] [7] [9] when trying to do
load balancing on multiprocessors. In response to a request made by
the SIERRA project, different space filling curves can be used to span
the spatial area being examined. Currently, the choices available are:
1) Morton Indexing (also known as Z-curve), 2) Gray Code [1] [2] [11],
and 3) Hilbert Curve [1] [2] [5] [10]. Tests have been conducted
on the current implementation, and the results are described in detail
in section 6.2 below.

1.3 Changes Made To RPI's System
   The RPI load balancing code had to be made more general to enhance
flexibility, which may not have been possible if just an interface was
created between the application and the balancer. Efforts were made to
keep RPI load balancing and partitioning algorithms intact with minor
changes as necessary. Data structures had to be modified to no longer
be dependent on mesh regions generated by a specific modeler [9].
Instead of balancing on regions of a mesh, the program uses a generic
structure usually referred to as "objects." It is not necessary to
know what these objects are; only their coordinates, weights (if not
uniform), and identification tags are needed. Within the load balancing
algorithm, they are treated in the same manner as the mesh regions
were, thus keeping the same functionality.

   The other change necessary was the generation of the tree before
the actual load balancing. When object datums are retrieved by the
load balancer, their initial decomposition is already distributed
among the processors; because of this, we have no global view of how
the octree structure should be. With RPI's system, some knowledge of the
global structure existed since the mesh (the data used by their octree
load balancer) was created using an octree algorithm [7] [9]. In this
implementation, there is no pre-existing geometric grouping. A new
algorithm had to be created which gives processors an object grouping
so that the partitioner during load balancing would produce a better
decomposition. This helps to limit the number of discontinuities, but
does not guarantee that there will not be any; how the area of
interest is being traversed also plays an important factor.

1.4 Enhancements Made To RPI's System
   As stated in the goals above, enhancements to the existing code
would be made if possible. To this end, new ordering schemes were
added to the octree structure. The ordering of the nodes of the octree
structure creates a space filling curve that spans the area of
interest. In the original code, the octree only used the Morton
Indexing scheme, otherwise known as the "Z-curve" [7] [9]; now two
additional methods are incorporated into the octree library. The first
of the new orderings used the Gray Code algorithm. Gray Code is a
method of encoding a series of numbers so that between any two
sequential numbers, there is only one bit change [1] [2] [11]. Taking
this idea and expanding it to octree orderings, given eight child
octants created by one subdivision of a node, there is only one
direction change (x, y, or z) between any two sequentially traversed
child octants. The Gray code encoding is applied to the octant
numbering of "child nodes." The second ordering implemented is the Hilbert
Curve. This was achieved with the help of H. Carter Edwards [5] of the
SIERRA project at Sandia National Laboratories, who provided the
encoding algorithm. The Hilbert Curve is an extension of the Gray
Code. Again, there is only a one bit change between any two
consecutive numbers, but a more smooth curve is created by rotating or
flipping segments of the curve to maintain continuity. Sudden jumps
that exist in the Z-curve and Gray Code are avoided in the hopes of
giving a better decomposition. Using the Hilbert Curve, with the
grouped objects mentioned in section 1.3, the user is guaranteed to
have continuous partition regions after load balancing. Further
explanation of the space filling curves used are in section 3.3 below.
