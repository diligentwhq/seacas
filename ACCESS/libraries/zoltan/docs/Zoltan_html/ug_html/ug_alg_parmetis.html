<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.76 [en] (X11; U; Linux 2.4.2-2smp i686) [Netscape]">
   <meta name="sandia.approved" content="SAND99-1377">
   <meta name="author" content="karen devine, kddevin@sandia.gov">
   <title>Zoltan User's Guide:  ParMETIS Interface</title>
<!-----------------------------------------------------------------------------
 ! Zoltan Library for Parallel Applications            !
 ! Copyright (c) 2000,2001,2002, Sandia National Laboratories.                !
 ! This document is released under the GNU Lesser General Public License.     !
 ! For more info, see the README file in the top-level Zoltan directory.      !
 !----------------------------------------------------------------------------!
-->
<!-- CVS File Information
     $RCSfile: ug_alg_parmetis.html,v $
     $Author: gdsjaar $
     $Date: 2009/06/09 18:37:56 $
     $Revision: 1.1 $
-->
</head>
<body bgcolor="#FFFFFF">

<div align=right><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp;
|&nbsp; <a href="ug_alg_jostle.html">Next</a>&nbsp; |&nbsp; <a href="ug_alg_reftree.html">Previous</a></i></b></div>

Note: See also <a href="ug_alg_phg.html">hypergraph partitioning</a>. <p>

<h2>
<a NAME="ParMETIS"></a>Graph partitioning: ParMETIS</h2>
<a href="http://www-users.cs.umn.edu/~karypis/metis/parmetis/">ParMETIS</a>
is a parallel library for graph partitioning (for static load balancing)
and repartitioning (for dynamic load balancing) developed at the University
of Minnesota by Karypis, Schloegel and Kumar [<a href="ug_refs.html#parmetis">Karypis
and Kumar</a>]. ParMETIS is therefore strictly speaking not a method but
rather a collection of methods. In the Zoltan context, ParMETIS is a method
with many sub-methods. Zoltan provides an interface to all the ParMETIS
(sub-)methods.&nbsp; The user selects which ParMETIS method to use through
the parameter PARMETIS_METHOD. Most of the ParMETIS methods are based on
either multilevel Kernighan-Lin partitioning or a diffusion algorithm.
The names of the ParMETIS methods used by Zoltan are identical to those
in the ParMETIS library. For further information about the various <a href="http://www-users.cs.umn.edu/~karypis/metis/parmetis/">ParMETIS</a>
methods and parameters, please consult the <a href="http://www-users.cs.umn.edu/~karypis/metis/parmetis/">ParMETIS</a>
User's Guide.
<p>Graph partitioning is a useful abstraction for load balancing. The main
idea is to represent the computational application as a weighted graph.
The nodes or vertices in the graph correspond to objects in Zoltan.&nbsp;
Each object may have a weight that normally represents the amount of computation.
The edges or arcs in the graph usually correspond to communication costs.
In graph partitioning, the problem is to find a partitioning of the graph
(that is,&nbsp; each vertex is assigned to one out of <i>k</i> possible
sets called partitions) that minimizes the cut size (weight) subject to
the partitions having approximately equal size (weight). In repartitioning,
it is assumed that a partitioning already exists. The problem is to find
a good partitioning that is also "similar" in some sense to the existing
partitioning. This keeps the migration cost low. All the problems described
above are NP-hard so no efficient exact algorithm is known. We remark that
in Zoltan 1.*, the number of partitions is always the same as the number
of MPI processes (which is normally equal to the number of processors).
<p>We give only a brief summary of the various ParMETIS methods here; for
more details see the <a href="http://www-users.cs.umn.edu/~karypis/metis/parmetis/">ParMETIS</a>
documentation. The methods fall into three categories:
<ol>
<li>
Part* - Perform graph partitioning without consideration of the initial
distribution.</li>

<li>
AdaptiveRepart (ParMETIS 3) and Repart* (ParMETIS 2)&nbsp; - Incremental
algorithms with small migration cost.</li>

<li>
Refine* - Refines a given partitioning (balance).&nbsp; Can be applied
multiple times to reduce the communication cost (cut weight) if desired.</li>
</ol>
As a rule of thumb, use one of the Part* methods if you have a poor initial
balance and you are willing to spend some time doing migration. One such
case is static load balancing; that is, you need to balance only once.
Use AdaptiveRepart or the Repart* methods when you have a reasonably good
load balance that you wish to update incrementally. These methods are well
suited&nbsp; for dynamic load balancing (for example,&nbsp; adaptive mesh
refinement). A reasonable strategy is to call PartKway once to obtain a
good initial balance and&nbsp; later update this balance using AdaptiveRepart
(Repart* in ParMetis 2.0).
<p>Zoltan is currently compatible with ParMETIS versions 3.1 and 2.0.&nbsp;
There is no guarantee that Zoltan will work correctly if you have a different
version of ParMETIS on your computer. (ParMETIS 3.0 will work with Zoltan in most cases, but is not officially supported. ParMETIS 3.1 is highly recommended.
The 2.0 version will soon become obsolete and may not be supported in future Zoltan versions.) 
The ParMETIS source code can be obtained from the <a href="http://www-users.cs.umn.edu/~karypis/metis/parmetis/">ParMETIS
home page</a>. As a courtesy service,&nbsp; a recent, compatible version of the
ParMETIS source code is distributed with Zoltan. However, ParMETIS is a
completely separate library. If you do not wish to install ParMETIS, it
is possible to compile Zoltan without any references to ParMETIS&nbsp;
(when you 'make' Zoltan, comment out the PARMETIS_LIBPATH variable in the
configuration file <i><a href="ug_usage.html#Building the Library">Utilities/Config/Config.&lt;platform></a></i>).
<p>Note that Zoltan ignores the imbalance tolerance parameter IMBALANCE_TOL
when ParMETIS 2.0 is used (the default value 1.05 is used), while IMBALANCE_TOL
works correctly with ParMETIS 3.0.&nbsp; Zoltan supports the multiconstraint
feature of ParMETIS 3 through multiple object weights (see <i><a href="ug_param.html#General_Parameters">OBJ_WEIGHT_DIM</a></i>).

<p>The graph given to Zoltan/ParMETIS must be symmetric. Any self edges
(loops) will be ignored. Multiple edges between a pair of vertices is not
allowed. All weights must be non-negative. The graph does not have to be
connected.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP><b>Method String:</b></td>

<td><b>GRAPH</b> or <b>PARMETIS</b></td>
</tr>

<tr>
<td><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; PARMETIS_METHOD</i></td>

<td>The ParMETIS method to be used; currently nine are available.&nbsp;
<br><i>PartKway</i> - multilevel Kernighan-Lin partitioning&nbsp;
<br><i>PartGeom</i> - space filling curves (coordinate based)&nbsp;
<br><i>PartGeomKway</i> - hybrid method based on PartKway and PartGeom
(needs both&nbsp; graph data and coordinates)&nbsp;
<br><i>AdaptiveRepart - </i>adaptive repartitioning (only in ParMETIS 3.0
and higher)
<br><i>RepartLDiffusion</i> - diffusion algorithm (local)&nbsp;
<br><i>RepartGDiffusion</i> - diffusion algorithm (global)&nbsp;
<br><i>RepartRemap</i> - multilevel partioning with remap seeking to minimize
migration cost&nbsp;
<br><i>RepartMLRemap</i> - similar to RepartRemap but with additional multilevel
refinement&nbsp;
<br><i>RefineKway</i> - refine the current partitioning (balance)</td>
</tr>

<tr>
<td></td>

<td>The method names are case insensitive.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>PARMETIS_OUTPUT_LEVEL</i></td>

<td>Amount of output the load-balancing algorithm should produce.&nbsp;
<br>0 = no output, 1 = print timing info. Turning on more bits displays
more information (for example, 3=1+2, 5=1+4, 7=1+2+4).</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; <i>PARMETIS_COARSE_ALG</i></td>

<td>Coarse algorithm for PartKway. 1 = serial, 2 = parallel. (ParMETIS
2 only)</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; <i>PARMETIS_SEED</i></td>

<td>Random seed for ParMETIS.</td>
</tr>

<tr VALIGN=TOP NOSAVE>
<td>&nbsp;&nbsp;&nbsp; <i>PARMETIS_ITR</i></td>

<td NOSAVE>Ratio of interprocessor communication time to redistribution
time. A high value will emphasize reducing the edge cut, while a small
value will try to keep the change in the new partition (distribution) small.
This parameter is only used by AdaptiveRepart. A value of between 100 and
1000 is good for most problems.</td>
</tr>

<tr VALIGN=TOP NOSAVE>
<td>&nbsp;&nbsp;&nbsp; <i>USE_OBJ_SIZE</i></td>

<td NOSAVE>Use (or not use) the available information about object sizes
to estimate migration cost. This parameter is currently only relevant for
AdaptiveRepart.</td>
</tr>

<tr VALIGN=TOP NOSAVE>
<td>&nbsp;&nbsp;&nbsp; <i>CHECK_GRAPH</i></td>

<td NOSAVE>Level of error checking for graph input: 0 = no checking, 1
= on-processor checking, 2 = full checking. (CHECK_GRAPH==2 is very slow
and should be used only during debugging).</td>
</tr>

<tr VALIGN=TOP NOSAVE>
<td>&nbsp;&nbsp;&nbsp; <i>SCATTER_GRAPH</i></td>

<td NOSAVE>Scatter graph data by distributing contiguous chunks of objects
(vertices) of roughly equal size to each processor before calling the partitioner.
0 = don't scatter; 1 = scatter only if all objects are on a single processor;
2 = scatter if at least one processor owns no objects (recommended to avoid
a bug in ParMETIS 2.0); 3 = always scatter.&nbsp;</td>
</tr>

<tr>
<td VALIGN=TOP><b>Default values:</b></td>

<td></td>
</tr>

<tr>
<td></td>

<td><i>PARMETIS_METHOD</i> = RepartGDiffusion</td>
</tr>

<tr>
<td></td>

<td><i>PARMETIS_OUTPUT_LEVEL</i> = 0</td>
</tr>

<tr>
<td></td>

<td><i>PARMETIS_COARSE_ALG </i>= 2</td>
</tr>

<tr>
<td></td>

<td><i>PARMETIS_SEED </i>= 15</td>
</tr>

<tr>
<td></td>

<td><i>PARMETIS_ITR </i>= 100</td>
</tr>

<tr>
<td></td>

<td><i>USE_OBJ_SIZE </i>= 1</td>
</tr>

<tr>
<td></td>

<td><i>CHECK_GRAPH</i> = 1</td>
</tr>

<tr>
<td></td>

<td><i>SCATTER_GRAPH </i>= 1</td>
</tr>

<tr>
<td VALIGN=TOP><b>Required Query Functions:</b></td>

<td></td>
</tr>

<tr>
<td>For all submethods:</td>

<td><b><a href="ug_query_lb.html#ZOLTAN_NUM_OBJ_FN">ZOLTAN_NUM_OBJ_FN</a></b></td>
</tr>

<tr>
<td></td>

<td><b><a href="ug_query_lb.html#ZOLTAN_OBJ_LIST_FN">ZOLTAN_OBJ_LIST_FN</a></b>
or <b><a href="ug_query_lb.html#ZOLTAN_FIRST_OBJ_FN">ZOLTAN_FIRST_OBJ_FN</a></b>/<b><a href="ug_query_lb.html#ZOLTAN_NEXT_OBJ_FN">ZOLTAN_NEXT_OBJ_FN</a></b>
pair</td>
</tr>

<tr>
<td>Only PartGeom &amp; PartGeomKway:</td>

<td><b><a href="ug_query_lb.html#ZOLTAN_NUM_GEOM_FN">ZOLTAN_NUM_GEOM_FN</a></b></td>
</tr>

<tr>
<td></td>

<td>
<b><a href="ug_query_lb.html#ZOLTAN_GEOM_MULTI_FN">ZOLTAN_GEOM_MULTI_FN</a></b>
or <b><a href="ug_query_lb.html#ZOLTAN_GEOM_FN">ZOLTAN_GEOM_FN</a></b>
</td>

</tr>

<tr VALIGN=TOP NOSAVE>
<td>All but PartGeom:</td>

<td NOSAVE>
<b><a href="ug_query_lb.html#ZOLTAN_NUM_EDGES_MULTI_FN">ZOLTAN_NUM_EDGES_MULTI_FN</a></b> or
<b><a href="ug_query_lb.html#ZOLTAN_NUM_EDGES_FN">ZOLTAN_NUM_EDGES_FN</a></b>
<br>
<b><a href="ug_query_lb.html#ZOLTAN_EDGE_LIST_MULTI_FN">ZOLTAN_EDGE_LIST_MULTI_FN</a></b> or
<b><a href="ug_query_lb.html#ZOLTAN_EDGE_LIST_FN">ZOLTAN_EDGE_LIST_FN</a></b>
</td>
</tr>
</table>

<p>
<hr WIDTH="100%">[<a href="ug.html">Table of Contents</a>&nbsp; | <a href="ug_alg_jostle.html">Next:&nbsp;
Jostle</a>&nbsp; |&nbsp; <a href="ug_alg_reftree.html">Previous:&nbsp;
Refinement Tree Partitioning</a>]
</body>
</html>
