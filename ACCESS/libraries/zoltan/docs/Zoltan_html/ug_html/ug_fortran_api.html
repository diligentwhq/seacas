<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <meta name="sandia.approved" content="SAND99-1377">
   <meta name="author" content="karen devine, kddevin@sandia.gov">
   <title>Zoltan User's Guide:  FORTRAN API</title>
<!-----------------------------------------------------------------------------
 ! Zoltan Library for Parallel Applications            !
 ! Copyright (c) 2000,2001,2002, Sandia National Laboratories.                !
 ! This document is released under the GNU Lesser General Public License.     !
 ! For more info, see the README file in the top-level Zoltan directory.      !
 !----------------------------------------------------------------------------!
-->
<!-- CVS File Information
     $RCSfile: ug_fortran_api.html,v $
     $Author: gdsjaar $
     $Date: 2009/06/09 18:37:56 $
     $Revision: 1.1 $
-->

</head>
<body bgcolor="#FFFFFF">

<div align=right><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp;
|&nbsp; <a href="ug_fortran_77.html">Next</a>&nbsp; |&nbsp; <a href="ug_fortran_apps.html">Previous</a></i></b></div>

<h2>
<a NAME="fortran ug api"></a>FORTRAN API</h2>
The Fortran interface for each <a href="ug_interface.html">Zoltan Interface
Function</a> and <a href="ug_query.html">Application-Registered Query Function</a>
is given along with the C interface. This section contains some general
information about the design and use of the Fortran interface.
<ul><a href="#fortran ug api names">Names</a>
<br><a href="#fortran ug api zoltan module">Zoltan module</a>
<br><a href="#fortran ug api numeric types">Numeric types</a>
<br><a href="#fortran ug api structures">Structures</a>
<br><a href="#fortran ug api IDs">Global and local IDs</a>
<br><a href="#fortran ug api query">Query function data</a></ul>

<h3>
<a NAME="fortran ug api names"></a>Names</h3>
All procedure, variable, defined constant and structure names are identical
to those in the C interface, except that in Fortran they are case insensitive
(either upper or lower case letters can be used).
<br>&nbsp;
<h3>
<a NAME="fortran ug api zoltan module"></a>Zoltan module</h3>
MODULE <i>zoltan</i> provides access to all entities in Zoltan that are of use
to the application, including kind type parameters, named constants, procedures,
and derived types. Any program unit (e.g., main program, module, external
subroutine) that needs access to an entity from Zoltan must contain the
statement
<ul>USE zoltan</ul>
near the beginning.
<h3>
<a NAME="fortran ug api numeric types"></a>Numeric types</h3>
The correspondence between Fortran and C numeric types is achieved through
the use of kind type parameters. In most cases, the default kind for a
Fortran type will match the corresponding C type, but this is not guaranteed.
To insure portability of the application code, it is highly recommended
that the following kind type parameters be used in the declaration of all
variables and constants that will be passed to a Zoltan procedure:
<br>&nbsp;
<center><table BORDER WIDTH="80%" NOSAVE >
<tr NOSAVE>
<td NOSAVE><b>C</b></td>

<td><b>Fortran</b></td>
</tr>

<tr>
<td>int</td>

<td>INTEGER(KIND=Zoltan_INT)</td>
</tr>

<tr>
<td>float</td>

<td>REAL(KIND=Zoltan_FLOAT)</td>
</tr>

<tr>
<td>double</td>

<td>REAL(KIND=Zoltan_DOUBLE)&nbsp;</td>
</tr>
</table></center>

<p>Note that "KIND=" is optional in declaration statements. The kind number
for constants can be attached to the constant, e.g., 1.0_Zoltan_DOUBLE.
<br>&nbsp;
<h3>
<a NAME="fortran ug api structures"></a>Structures</h3>
For any struct in the C interface to Zoltan, e.g. <b><a href="../dev_html/dev_lb_structs.html#Zoltan_Struct">Zoltan_Struct</a></b>,
there is a corresponding derived type in the Fortran interface. Variables
of this type are declared as demonstrated below:
<ul>TYPE(Zoltan_Struct) :: zz</ul>
In the Fortran interface, the internal components of the derived type are
PRIVATE and not accessible to the application. However, the application
simply passes these variables around, and never needs to access the internal
components.
<h3>
<a NAME="fortran ug api IDs"></a>Global and local IDs</h3>
While the C implementation uses arrays of unsigned integers to represent
<a href="ug_usage.html#Data Types for Object IDs">global and local IDs</a>,&nbsp;
the Fortran interface uses arrays of integers, as unsigned integers are
not available in Fortran.&nbsp; Thus, each ID is represented as an array
(possibly of size 1) of integers.&nbsp; Applications that use other data
types for their IDs can convert between their data types and Zoltan's in
the <a href="ug_query.html">application-registered query functions</a>.
<h3>
<a NAME="fortran ug api query"></a>Query function data</h3>
<b><a href="ug_interface_init.html#Zoltan_Set_Fn">Zoltan_Set_Fn</a></b> allows
the application to pass a pointer to data that will subsequently be passed
to the query function being registered. From Fortran this is an optional
argument, or can be one of several types. In the simplest cases, an intrinsic
array containing the data will be sufficient. For these cases, data can
be an assumed size array of type INTEGER(Zoltan_INT), REAL(Zoltan_FLOAT) or REAL(Zoltan_DOUBLE).
When the argument is omitted in the call to the registration function, a
data argument will still be passed to the query function.  This should be
declared as an assumed size array of type INTEGER(Zoltan_INT) and never used.

<p>For more complicated situations, the application may need to pass data
in a user-defined type. The strong type checking of Fortran does not allow
passing an arbitrary type without modifying the Fortran interface for each
desired type. So the Fortran interface provides a type to be used for this
purpose, <b>Zoltan_User_Data_1</b>. Since different types of data may need
to be passed to different query functions, four such types are provided,
using the numerals 1, 2, 3 and 4 as the last character in the name of the
type. These types are defined by the application in <i>zoltan_user_data.f90</i>.
If not needed, they must be defined, but can be almost empty as in
<i>fort/zoltan_user_data.f90</i>.
<p>The application may use these types in any appropriate way. If desired,
it can define these types to contain the application's data and use the
type throughout the application. But it is anticipated that in most cases,
the desired type already exists in the application, and the <b>Zoltan_User_Data_x</b>
types will be used as "wrapper types," containing one or more pointers
to the existing types. For example,
<ul>TYPE mesh
<ul>! an existing data type with whatever defines a mesh</ul>
END TYPE mesh
<p>TYPE Zoltan_User_Data_2
<ul>TYPE(mesh), POINTER :: ptr</ul>
END TYPE Zoltan_User_Data_2</ul>
The application would then set the pointer to the data before calling Zoltan_Set_Fn:
<ul>TYPE(mesh) :: meshdata
<br>TYPE(Zoltan_User_Data_2) :: query_data
<br>TYPE(Zoltan_Struct) :: zz
<br>INTEGER(Zoltan_INT), EXTERNAL :: num_obj_func ! not required for module
procedures
<p>query_data%ptr => meshdata
<br>ierr = Zoltan_Set_Fn(zz,ZOLTAN_NUM_OBJ_FN_TYPE,num_obj_func,query_data)</ul>
Note that the existing data type must be available when <b>Zoltan_User_Data_x</b>
is defined. Therefore it must be defined either in<i> zoltan_user_data.f90</i>
or in a module that is compiled before <i>zoltan_user_data.f90</i> and <b>USE</b>d
by MODULE<i> zoltan_user_data</i>. For an example that uses a wrapper type,
see <i>fdriver/zoltan_user_data.f90</i>.
<p>
<hr WIDTH="100%">
<br>[<a href="ug.html">Table of Contents</a>&nbsp; |&nbsp; <a href="ug_fortran_77.html">Next:&nbsp;
FORTRAN 77</a>&nbsp; |&nbsp; <a href="ug_fortran_apps.html">Previous:&nbsp;
FORTRAN--Compiling Applications</a>
</body>
</html>
